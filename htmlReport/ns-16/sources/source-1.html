


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Advice</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.asm</a>
</div>

<h1>Coverage Summary for Class: Advice (net.bytebuddy.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Advice</td>
<td class="coverageStat">
  <span class="percent">
    30.8%
  </span>
  <span class="absValue">
    (8/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.7%
  </span>
  <span class="absValue">
    (10/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.4%
  </span>
  <span class="absValue">
    (39/92)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Advice$AdviceVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithoutExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithoutExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AllArguments</td>
  </tr>
  <tr>
    <td class="name">Advice$Argument</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForRegularInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inactive</td>
<td class="coverageStat">
  <span class="percent">
    13.3%
  </span>
  <span class="absValue">
    (2/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.8%
  </span>
  <span class="absValue">
    (3/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (5/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.3%
  </span>
  <span class="absValue">
    (19/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$CodeTranslationVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/80)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (9/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithDiscardedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithRetainedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (1/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.2%
  </span>
  <span class="absValue">
    (14/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithoutExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForType</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.7%
  </span>
  <span class="absValue">
    (5/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.8%
  </span>
  <span class="absValue">
    (7/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55%
  </span>
  <span class="absValue">
    (11/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (28/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$6</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$7</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$8</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$9</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$OfNonDefault</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Relocation</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.5%
  </span>
  <span class="absValue">
    (19/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Suppressing</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Unresolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Enter</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Exit</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldGetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldSetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldValue</td>
  </tr>
  <tr>
    <td class="name">Advice$Local</td>
  </tr>
  <tr>
    <td class="name">Advice$NoExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$AdviceType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (10/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (13/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (4/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.8%
  </span>
  <span class="absValue">
    (7/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.1%
  </span>
  <span class="absValue">
    (8/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForExitValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (4/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$ReaderFactory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WriterFactory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$1</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$3</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$4</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$5</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForLocalValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.8%
  </span>
  <span class="absValue">
    (3/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.3%
  </span>
  <span class="absValue">
    (11/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.9%
  </span>
  <span class="absValue">
    (7/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStubValue</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40.9%
  </span>
  <span class="absValue">
    (9/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThrowable$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForUnusedValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$OnNonDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Origin</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Return</td>
  </tr>
  <tr>
    <td class="name">Advice$SelfCallHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$StubValue</td>
  </tr>
  <tr>
    <td class="name">Advice$This</td>
  </tr>
  <tr>
    <td class="name">Advice$Thrown</td>
  </tr>
  <tr>
    <td class="name">Advice$Unused</td>
  </tr>
  <tr>
    <td class="name">Advice$WithCustomMapping</td>
<td class="coverageStat">
  <span class="percent">
    14.6%
  </span>
  <span class="absValue">
    (7/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (2/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.8%
  </span>
  <span class="absValue">
    (16/101)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    35.9%
  </span>
  <span class="absValue">
    (134/373)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10.6%
  </span>
  <span class="absValue">
    (60/568)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.3%
  </span>
  <span class="absValue">
    (378/1206)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.asm;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.Documented;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.annotation.Repeatable;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.TreeMap;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.description.type.TypeList.Explicit;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator.ForClassLoader;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.SuperMethodCall;
&nbsp;import net.bytebuddy.implementation.FieldAccessor.FieldNameExtractor.ForBeanProperty;
&nbsp;import net.bytebuddy.implementation.bytecode.Addition;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.Removal;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.implementation.bytecode.Throw;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.MethodConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.NullConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.SerializedConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.AnnotationVisitor;
&nbsp;import net.bytebuddy.jar.asm.Attribute;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.Label;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.TypePath;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.AsmClassReader;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.ConstantValue;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.JavaConstant.MethodHandle;
&nbsp;import net.bytebuddy.utility.JavaConstant.MethodType;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor;
&nbsp;import net.bytebuddy.utility.visitor.LineNumberPrependingMethodVisitor;
&nbsp;import net.bytebuddy.utility.visitor.StackAwareMethodVisitor;
&nbsp;
&nbsp;@Enhance
&nbsp;public class Advice implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper, Implementation {
&nbsp;    @AlwaysNull
&nbsp;    private static final AsmClassReader UNDEFINED = null;
&nbsp;    private static final MethodDescription.InDefinedShape SKIP_ON;
&nbsp;    private static final MethodDescription.InDefinedShape SKIP_ON_INDEX;
&nbsp;    private static final MethodDescription.InDefinedShape PREPEND_LINE_NUMBER;
&nbsp;    private static final MethodDescription.InDefinedShape INLINE_ENTER;
&nbsp;    private static final MethodDescription.InDefinedShape SUPPRESS_ENTER;
&nbsp;    private static final MethodDescription.InDefinedShape REPEAT_ON;
&nbsp;    private static final MethodDescription.InDefinedShape REPEAT_ON_INDEX;
&nbsp;    private static final MethodDescription.InDefinedShape ON_THROWABLE;
&nbsp;    private static final MethodDescription.InDefinedShape BACKUP_ARGUMENTS;
&nbsp;    private static final MethodDescription.InDefinedShape INLINE_EXIT;
&nbsp;    private static final MethodDescription.InDefinedShape SUPPRESS_EXIT;
&nbsp;    private final Dispatcher.Resolved.ForMethodEnter methodEnter;
&nbsp;    private final Dispatcher.Resolved.ForMethodExit methodExit;
&nbsp;    private final Assigner assigner;
&nbsp;    private final ExceptionHandler exceptionHandler;
&nbsp;    private final Implementation delegate;
&nbsp;
&nbsp;    protected Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit) {
&nbsp;        this(methodEnter, methodExit, Assigner.DEFAULT, Advice.ExceptionHandler.Default.SUPPRESSING, SuperMethodCall.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    private Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, Assigner assigner, ExceptionHandler exceptionHandler, Implementation delegate) {
&nbsp;        this.methodEnter = methodEnter;
&nbsp;        this.methodExit = methodExit;
&nbsp;        this.assigner = assigner;
&nbsp;        this.exceptionHandler = exceptionHandler;
&nbsp;        this.delegate = delegate;
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(Class&lt;?&gt; advice) {
&nbsp;        return to(advice, ForClassLoader.of(advice.getClassLoader()));
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(Class&lt;?&gt; advice, ClassFileLocator classFileLocator) {
&nbsp;        return to(ForLoadedType.of(advice), classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(TypeDescription advice) {
&nbsp;        return to(advice, net.bytebuddy.dynamic.ClassFileLocator.NoOp.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
&nbsp;        return to(advice, Advice.PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.emptyList(), Advice.Delegator.ForRegularInvocation.Factory.INSTANCE, net.bytebuddy.utility.AsmClassReader.Factory.Default.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    protected static Advice to(TypeDescription advice, PostProcessor.Factory postProcessorFactory, ClassFileLocator classFileLocator, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
&nbsp;        Dispatcher.Unresolved methodEnter = Advice.Dispatcher.Inactive.INSTANCE;
&nbsp;        Dispatcher.Unresolved methodExit = Advice.Dispatcher.Inactive.INSTANCE;
&nbsp;
&nbsp;        for(MethodDescription.InDefinedShape methodDescription : advice.getDeclaredMethods()) {
&nbsp;            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);
&nbsp;            methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);
&nbsp;        }
&nbsp;
&nbsp;        if (!methodEnter.isAlive() &amp;&amp; !methodExit.isAlive()) {
&nbsp;            throw new IllegalArgumentException(&quot;No advice defined by &quot; + advice);
&nbsp;        } else {
&nbsp;            try {
&nbsp;                AsmClassReader classReader = !methodEnter.isBinary() &amp;&amp; !methodExit.isBinary() ? UNDEFINED : classReaderFactory.make(classFileLocator.locate(advice.getName()).resolve());
&nbsp;                return new Advice(methodEnter.asMethodEnter(userFactories, classReader, methodExit, postProcessorFactory), methodExit.asMethodExit(userFactories, classReader, methodEnter, postProcessorFactory));
&nbsp;            } catch (IOException exception) {
&nbsp;                throw new IllegalStateException(&quot;Error reading class file of &quot; + advice, exception);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice) {
&nbsp;        ClassLoader enterLoader = enterAdvice.getClassLoader();
&nbsp;        ClassLoader exitLoader = exitAdvice.getClassLoader();
&nbsp;        return to(enterAdvice, exitAdvice, (ClassFileLocator)(enterLoader == exitLoader ? ForClassLoader.of(enterLoader) : new ClassFileLocator.Compound(new ClassFileLocator[]{ForClassLoader.of(enterLoader), ForClassLoader.of(exitLoader)})));
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice, ClassFileLocator classFileLocator) {
&nbsp;        return to(ForLoadedType.of(enterAdvice), ForLoadedType.of(exitAdvice), classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
&nbsp;        return to(enterAdvice, exitAdvice, net.bytebuddy.dynamic.ClassFileLocator.NoOp.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
&nbsp;        return to(enterAdvice, exitAdvice, Advice.PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.emptyList(), Advice.Delegator.ForRegularInvocation.Factory.INSTANCE, net.bytebuddy.utility.AsmClassReader.Factory.Default.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    protected static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, PostProcessor.Factory postProcessorFactory, ClassFileLocator classFileLocator, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
&nbsp;        Dispatcher.Unresolved methodEnter = Advice.Dispatcher.Inactive.INSTANCE;
&nbsp;        Dispatcher.Unresolved methodExit = Advice.Dispatcher.Inactive.INSTANCE;
&nbsp;
<b class="fc">&nbsp;        for(MethodDescription.InDefinedShape methodDescription : enterAdvice.getDeclaredMethods()) {</b>
&nbsp;            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);
&nbsp;        }
&nbsp;
&nbsp;        if (!methodEnter.isAlive()) {
&nbsp;            throw new IllegalArgumentException(&quot;No enter advice defined by &quot; + enterAdvice);
<b class="fc">&nbsp;        } else {</b>
&nbsp;            for(MethodDescription.InDefinedShape methodDescription : exitAdvice.getDeclaredMethods()) {
&nbsp;                methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);
&nbsp;            }
&nbsp;
&nbsp;            if (!methodExit.isAlive()) {
&nbsp;                throw new IllegalArgumentException(&quot;No exit advice defined by &quot; + exitAdvice);
&nbsp;            } else {
&nbsp;                try {
&nbsp;                    return new Advice(methodEnter.asMethodEnter(userFactories, methodEnter.isBinary() ? classReaderFactory.make(classFileLocator.locate(enterAdvice.getName()).resolve()) : UNDEFINED, methodExit, postProcessorFactory), methodExit.asMethodExit(userFactories, methodExit.isBinary() ? classReaderFactory.make(classFileLocator.locate(exitAdvice.getName()).resolve()) : UNDEFINED, methodEnter, postProcessorFactory));
&nbsp;                } catch (IOException exception) {
&nbsp;                    throw new IllegalStateException(&quot;Error reading class file of &quot; + enterAdvice + &quot; or &quot; + exitAdvice, exception);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Dispatcher.Unresolved locate(Class&lt;? extends Annotation&gt; type, MethodDescription.InDefinedShape property, Dispatcher.Unresolved dispatcher, MethodDescription.InDefinedShape methodDescription, Delegator.Factory delegatorFactory) {
&nbsp;        AnnotationDescription annotation = methodDescription.getDeclaredAnnotations().ofType(type);
&nbsp;        if (annotation == null) {
&nbsp;            return dispatcher;
&nbsp;        } else if (dispatcher.isAlive()) {
&nbsp;            throw new IllegalStateException(&quot;Duplicate advice for &quot; + dispatcher + &quot; and &quot; + methodDescription);
&nbsp;        } else if (!methodDescription.isStatic()) {
&nbsp;            throw new IllegalStateException(&quot;Advice for &quot; + methodDescription + &quot; is not static&quot;);
&nbsp;        } else {
&nbsp;            return (Dispatcher.Unresolved)((Boolean)annotation.getValue(property).resolve(Boolean.class) ? new Dispatcher.Inlining(methodDescription) : new Dispatcher.Delegating(methodDescription, delegatorFactory));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static WithCustomMapping withCustomMapping() {
&nbsp;        return new WithCustomMapping();
&nbsp;    }
&nbsp;
&nbsp;    public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;        return (new AsmVisitorWrapper.ForDeclaredMethods()).invokable(matcher, new AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper[]{this});
&nbsp;    }
&nbsp;
&nbsp;    public MethodVisitor wrap(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, TypePool typePool, int writerFlags, int readerFlags) {
&nbsp;        return !instrumentedMethod.isAbstract() &amp;&amp; !instrumentedMethod.isNative() ? this.doWrap(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, writerFlags, readerFlags) : methodVisitor;
&nbsp;    }
&nbsp;
&nbsp;    protected MethodVisitor doWrap(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, int writerFlags, int readerFlags) {
&nbsp;        if (this.methodEnter.isPrependLineNumber()) {
&nbsp;            methodVisitor = new LineNumberPrependingMethodVisitor(methodVisitor);
&nbsp;        }
&nbsp;
&nbsp;        if (!this.methodExit.isAlive()) {
&nbsp;            return new AdviceVisitor.WithoutExitAdvice(methodVisitor, implementationContext, this.assigner, this.exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, this.methodEnter, writerFlags, readerFlags);
&nbsp;        } else if (this.methodExit.getThrowable().represents(NoExceptionHandler.class)) {
&nbsp;            return new AdviceVisitor.WithExitAdvice.WithoutExceptionHandling(methodVisitor, implementationContext, this.assigner, this.exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, this.methodEnter, this.methodExit, writerFlags, readerFlags);
&nbsp;        } else if (instrumentedMethod.isConstructor()) {
&nbsp;            throw new IllegalStateException(&quot;Cannot catch exception during constructor call for &quot; + instrumentedMethod);
&nbsp;        } else {
&nbsp;            return new AdviceVisitor.WithExitAdvice.WithExceptionHandling(methodVisitor, implementationContext, this.assigner, this.exceptionHandler.resolve(instrumentedMethod, instrumentedType), instrumentedType, instrumentedMethod, this.methodEnter, this.methodExit, writerFlags, readerFlags, this.methodExit.getThrowable());
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;        return this.delegate.prepare(instrumentedType);
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public ByteCodeAppender appender(Implementation.Target implementationTarget) {</b>
<b class="fc">&nbsp;        return new Appender(this, implementationTarget, this.delegate.appender(implementationTarget));</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public Advice withAssigner(Assigner assigner) {</b>
<b class="fc">&nbsp;        return new Advice(this.methodEnter, this.methodExit, assigner, this.exceptionHandler, this.delegate);</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public Advice withExceptionPrinting() {</b>
<b class="fc">&nbsp;        return this.withExceptionHandler((ExceptionHandler)Advice.ExceptionHandler.Default.PRINTING);</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    public Advice withExceptionHandler(StackManipulation exceptionHandler) {
&nbsp;        return this.withExceptionHandler((ExceptionHandler)(new ExceptionHandler.Simple(exceptionHandler)));
&nbsp;    }
&nbsp;
&nbsp;    public Advice withExceptionHandler(ExceptionHandler exceptionHandler) {
&nbsp;        return new Advice(this.methodEnter, this.methodExit, this.assigner, exceptionHandler, this.delegate);
&nbsp;    }
&nbsp;
&nbsp;    public Implementation wrap(Implementation implementation) {
&nbsp;        return new Advice(this.methodEnter, this.methodExit, this.assigner, this.exceptionHandler, implementation);
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        MethodList&lt;MethodDescription.InDefinedShape&gt; enter = ForLoadedType.of(OnMethodEnter.class).getDeclaredMethods();
&nbsp;        SKIP_ON = (MethodDescription.InDefinedShape)((MethodList)enter.filter(ElementMatchers.named(&quot;skipOn&quot;))).getOnly();
&nbsp;        SKIP_ON_INDEX = (MethodDescription.InDefinedShape)((MethodList)enter.filter(ElementMatchers.named(&quot;skipOnIndex&quot;))).getOnly();
&nbsp;        PREPEND_LINE_NUMBER = (MethodDescription.InDefinedShape)((MethodList)enter.filter(ElementMatchers.named(&quot;prependLineNumber&quot;))).getOnly();
&nbsp;        INLINE_ENTER = (MethodDescription.InDefinedShape)((MethodList)enter.filter(ElementMatchers.named(&quot;inline&quot;))).getOnly();
&nbsp;        SUPPRESS_ENTER = (MethodDescription.InDefinedShape)((MethodList)enter.filter(ElementMatchers.named(&quot;suppress&quot;))).getOnly();
&nbsp;        MethodList&lt;MethodDescription.InDefinedShape&gt; exit = ForLoadedType.of(OnMethodExit.class).getDeclaredMethods();
&nbsp;        REPEAT_ON = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;repeatOn&quot;))).getOnly();
&nbsp;        REPEAT_ON_INDEX = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;repeatOnIndex&quot;))).getOnly();
&nbsp;        ON_THROWABLE = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;onThrowable&quot;))).getOnly();
&nbsp;        BACKUP_ARGUMENTS = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;backupArguments&quot;))).getOnly();
&nbsp;        INLINE_EXIT = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;inline&quot;))).getOnly();
&nbsp;        SUPPRESS_EXIT = (MethodDescription.InDefinedShape)((MethodList)exit.filter(ElementMatchers.named(&quot;suppress&quot;))).getOnly();
&nbsp;    }
&nbsp;
&nbsp;    public boolean equals(@MaybeNull Object var1) {
&nbsp;        if (this == var1) {
&nbsp;            return true;
&nbsp;        } else if (var1 == null) {
&nbsp;            return false;
&nbsp;        } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        } else if (!this.methodEnter.equals(((Advice)var1).methodEnter)) {
&nbsp;            return false;
&nbsp;        } else if (!this.methodExit.equals(((Advice)var1).methodExit)) {
&nbsp;            return false;
&nbsp;        } else if (!this.assigner.equals(((Advice)var1).assigner)) {
&nbsp;            return false;
&nbsp;        } else if (!this.exceptionHandler.equals(((Advice)var1).exceptionHandler)) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            return this.delegate.equals(((Advice)var1).delegate);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public int hashCode() {
&nbsp;        return ((((this.getClass().hashCode() * 31 + this.methodEnter.hashCode()) * 31 + this.methodExit.hashCode()) * 31 + this.assigner.hashCode()) * 31 + this.exceptionHandler.hashCode()) * 31 + this.delegate.hashCode();
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    protected interface Dispatcher {</b>
<b class="fc">&nbsp;        @AlwaysNull</b>
<b class="fc">&nbsp;        MethodVisitor IGNORE_METHOD = null;</b>
<b class="fc">&nbsp;        @AlwaysNull</b>
&nbsp;        AnnotationVisitor IGNORE_ANNOTATION = null;
&nbsp;
&nbsp;        boolean isAlive();
&nbsp;
&nbsp;        TypeDefinition getAdviceType();
&nbsp;
&nbsp;        public static enum Inactive implements Unresolved, Resolved.ForMethodEnter, Resolved.ForMethodExit, Bound {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Inactive() {
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean isAlive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isBinary() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getAdviceType() {
<b class="nc">&nbsp;                return ForLoadedType.of(Void.TYPE);</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrependLineNumber() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition getActualAdviceType() {
&nbsp;                return ForLoadedType.of(Void.TYPE);
&nbsp;            }
&nbsp;
&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="nc">&nbsp;                return Collections.emptyMap();</b>
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getThrowable() {
&nbsp;                return Advice.NoExceptionHandler.DESCRIPTION;
&nbsp;            }
&nbsp;
&nbsp;            public ArgumentHandler.Factory getArgumentHandlerFactory() {
&nbsp;                return Advice.ArgumentHandler.Factory.SIMPLE;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {</b>
&nbsp;                return this;
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public void prepare() {
&nbsp;            }
&nbsp;
&nbsp;            public void initialize() {
&nbsp;            }
&nbsp;
&nbsp;            public void apply() {
&nbsp;            }
&nbsp;
&nbsp;            public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
&nbsp;                return this;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Inlining implements Unresolved {
&nbsp;            protected final MethodDescription.InDefinedShape adviceMethod;
<b class="fc">&nbsp;            private final Map&lt;String, TypeDefinition&gt; namedTypes;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected Inlining(MethodDescription.InDefinedShape adviceMethod) {</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
&nbsp;                this.namedTypes = new HashMap();
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                for(ParameterDescription parameterDescription : adviceMethod.getParameters()) {</b>
&nbsp;                    AnnotationDescription.Loadable&lt;Local&gt; annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);
&nbsp;                    if (annotationDescription != null) {
<b class="pc">&nbsp;                        String name = (String)annotationDescription.getValue(Advice.OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);</b>
<b class="fc">&nbsp;                        TypeDefinition previous = (TypeDefinition)this.namedTypes.put(name, parameterDescription.getType());</b>
&nbsp;                        if (previous != null &amp;&amp; !previous.equals(parameterDescription.getType())) {
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Local variable for &quot; + name + &quot; is defined with inconsistent types&quot;);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isAlive() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isBinary() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getAdviceType() {
<b class="nc">&nbsp;                return this.adviceMethod.getReturnType().asErasure();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {</b>
&nbsp;                return this.namedTypes;
&nbsp;            }
&nbsp;
&nbsp;            public Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {
&nbsp;                if (classReader == null) {
&nbsp;                    throw new IllegalStateException(&quot;Class reader not expected null&quot;);
&nbsp;                } else {
&nbsp;                    return Advice.Dispatcher.Inlining.Resolved.ForMethodEnter.of(this.adviceMethod, postProcessorFactory.make(this.adviceMethod, false), this.namedTypes, userFactories, methodExit.getAdviceType(), classReader, methodExit.isAlive());
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {</b>
&nbsp;                Map&lt;String, TypeDefinition&gt; namedTypes = new HashMap(methodEnter.getNamedTypes());
&nbsp;                Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes = new HashMap();
&nbsp;
&nbsp;                for(Map.Entry&lt;String, TypeDefinition&gt; entry : this.namedTypes.entrySet()) {
&nbsp;                    TypeDefinition typeDefinition = (TypeDefinition)namedTypes.get(entry.getKey());
&nbsp;                    TypeDefinition uninitializedTypeDefinition = (TypeDefinition)uninitializedNamedTypes.get(entry.getKey());
&nbsp;                    if (typeDefinition == null &amp;&amp; uninitializedTypeDefinition == null) {
&nbsp;                        namedTypes.put(entry.getKey(), entry.getValue());
&nbsp;                        uninitializedNamedTypes.put(entry.getKey(), entry.getValue());
&nbsp;                    } else if (!(typeDefinition == null ? uninitializedTypeDefinition : typeDefinition).equals(entry.getValue())) {
&nbsp;                        throw new IllegalStateException(&quot;Local variable for &quot; + (String)entry.getKey() + &quot; is defined with inconsistent types&quot;);
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                return Advice.Dispatcher.Inlining.Resolved.ForMethodExit.of(this.adviceMethod, postProcessorFactory.make(this.adviceMethod, true), namedTypes, uninitializedNamedTypes, userFactories, classReader, methodEnter.getAdviceType());
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return &quot;Delegate to &quot; + this.adviceMethod;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
<b class="nc">&nbsp;                } else if (var1 == null) {</b>
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
<b class="nc">&nbsp;                } else if (!this.adviceMethod.equals(((Inlining)var1).adviceMethod)) {</b>
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.namedTypes.equals(((Inlining)var1).namedTypes);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.adviceMethod.hashCode()) * 31 + this.namedTypes.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class Resolved extends Resolved.AbstractBase {
&nbsp;                protected final AsmClassReader classReader;
&nbsp;
&nbsp;                protected Resolved(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, AsmClassReader classReader) {
&nbsp;                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, Advice.OffsetMapping.Factory.AdviceType.INLINING);
&nbsp;                    this.classReader = classReader;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler var1);
&nbsp;
&nbsp;                protected abstract MethodVisitor apply(MethodVisitor var1, Implementation.Context var2, Assigner var3, ArgumentHandler.ForInstrumentedMethod var4, MethodSizeHandler.ForInstrumentedMethod var5, StackMapFrameHandler.ForInstrumentedMethod var6, TypeDescription var7, MethodDescription var8, SuppressionHandler.Bound var9, RelocationHandler.Bound var10, StackManipulation var11);
&nbsp;
&nbsp;                protected class AdviceMethodInliner extends ClassVisitor implements Bound {
<b class="nc">&nbsp;                    protected final TypeDescription instrumentedType;</b>
<b class="nc">&nbsp;                    protected final MethodDescription instrumentedMethod;</b>
<b class="nc">&nbsp;                    protected final MethodVisitor methodVisitor;</b>
&nbsp;                    protected final Implementation.Context implementationContext;
<b class="nc">&nbsp;                    protected final Assigner assigner;</b>
<b class="nc">&nbsp;                    protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;</b>
&nbsp;                    protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
<b class="nc">&nbsp;                    protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;</b>
<b class="nc">&nbsp;                    protected final SuppressionHandler.Bound suppressionHandler;</b>
&nbsp;                    protected final RelocationHandler.Bound relocationHandler;
<b class="nc">&nbsp;                    protected final StackManipulation exceptionHandler;</b>
<b class="nc">&nbsp;                    protected final AsmClassReader classReader;</b>
&nbsp;                    protected final List&lt;Label&gt; labels;
&nbsp;
<b class="nc">&nbsp;                    protected AdviceMethodInliner(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, AsmClassReader classReader) {</b>
<b class="nc">&nbsp;                        super(OpenedClassReader.ASM_API);</b>
<b class="nc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                        this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                        this.methodVisitor = methodVisitor;
&nbsp;                        this.implementationContext = implementationContext;
<b class="nc">&nbsp;                        this.assigner = assigner;</b>
&nbsp;                        this.argumentHandler = argumentHandler;
&nbsp;                        this.methodSizeHandler = methodSizeHandler;
&nbsp;                        this.stackMapFrameHandler = stackMapFrameHandler;
&nbsp;                        this.suppressionHandler = suppressionHandler;
&nbsp;                        this.relocationHandler = relocationHandler;
&nbsp;                        this.exceptionHandler = exceptionHandler;
&nbsp;                        this.classReader = classReader;
&nbsp;                        this.labels = new ArrayList();
&nbsp;                    }
&nbsp;
&nbsp;                    public void prepare() {
&nbsp;                        this.classReader.accept(new ExceptionTableExtractor(), 6);
&nbsp;                        this.suppressionHandler.onPrepare(this.methodVisitor);
&nbsp;                    }
&nbsp;
&nbsp;                    public void initialize() {
&nbsp;                        for(Map.Entry&lt;Integer, TypeDefinition&gt; typeDefinition : Resolved.this.resolveInitializationTypes(this.argumentHandler).entrySet()) {
&nbsp;                            if (!((TypeDefinition)typeDefinition.getValue()).represents(Boolean.TYPE) &amp;&amp; !((TypeDefinition)typeDefinition.getValue()).represents(Byte.TYPE) &amp;&amp; !((TypeDefinition)typeDefinition.getValue()).represents(Short.TYPE) &amp;&amp; !((TypeDefinition)typeDefinition.getValue()).represents(Character.TYPE) &amp;&amp; !((TypeDefinition)typeDefinition.getValue()).represents(Integer.TYPE)) {
<b class="fc">&nbsp;                                if (((TypeDefinition)typeDefinition.getValue()).represents(Long.TYPE)) {</b>
<b class="fc">&nbsp;                                    this.methodVisitor.visitInsn(9);</b>
<b class="fc">&nbsp;                                    this.methodVisitor.visitVarInsn(55, (Integer)typeDefinition.getKey());</b>
<b class="pc">&nbsp;                                } else if (((TypeDefinition)typeDefinition.getValue()).represents(Float.TYPE)) {</b>
<b class="nc">&nbsp;                                    this.methodVisitor.visitInsn(11);</b>
<b class="pc">&nbsp;                                    this.methodVisitor.visitVarInsn(56, (Integer)typeDefinition.getKey());</b>
<b class="nc">&nbsp;                                } else if (((TypeDefinition)typeDefinition.getValue()).represents(Double.TYPE)) {</b>
&nbsp;                                    this.methodVisitor.visitInsn(14);
<b class="pc">&nbsp;                                    this.methodVisitor.visitVarInsn(57, (Integer)typeDefinition.getKey());</b>
&nbsp;                                } else {
&nbsp;                                    this.methodVisitor.visitInsn(1);
&nbsp;                                    this.methodVisitor.visitVarInsn(58, (Integer)typeDefinition.getKey());
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                this.methodVisitor.visitInsn(3);
&nbsp;                                this.methodVisitor.visitVarInsn(54, (Integer)typeDefinition.getKey());
&nbsp;                            }
&nbsp;
&nbsp;                            this.methodSizeHandler.requireStackSize(((TypeDefinition)typeDefinition.getValue()).getStackSize().getSize());
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public void apply() {
&nbsp;                        this.classReader.accept(this, 2 | this.stackMapFrameHandler.getReaderHint());
&nbsp;                    }
&nbsp;
&nbsp;                    @MaybeNull
&nbsp;                    public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
&nbsp;                        return (MethodVisitor)(Resolved.this.adviceMethod.getInternalName().equals(internalName) &amp;&amp; Resolved.this.adviceMethod.getDescriptor().equals(descriptor) ? new ExceptionTableSubstitutor(Resolved.this.apply(this.methodVisitor, this.implementationContext, this.assigner, this.argumentHandler, this.methodSizeHandler, this.stackMapFrameHandler, this.instrumentedType, this.instrumentedMethod, this.suppressionHandler, this.relocationHandler, this.exceptionHandler)) : Advice.Dispatcher.IGNORE_METHOD);
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    protected class ExceptionTableExtractor extends ClassVisitor {
&nbsp;                        protected ExceptionTableExtractor() {
&nbsp;                            super(OpenedClassReader.ASM_API);
&nbsp;                        }
&nbsp;
&nbsp;                        @MaybeNull
&nbsp;                        public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
&nbsp;                            return (MethodVisitor)(Resolved.this.adviceMethod.getInternalName().equals(internalName) &amp;&amp; Resolved.this.adviceMethod.getDescriptor().equals(descriptor) ? AdviceMethodInliner.this.new ExceptionTableCollector(AdviceMethodInliner.this.methodVisitor) : Advice.Dispatcher.IGNORE_METHOD);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class ExceptionTableCollector extends MethodVisitor {
<b class="pc">&nbsp;                        private final MethodVisitor methodVisitor;</b>
&nbsp;
<b class="nc">&nbsp;                        protected ExceptionTableCollector(MethodVisitor methodVisitor) {</b>
&nbsp;                            super(OpenedClassReader.ASM_API);
&nbsp;                            this.methodVisitor = methodVisitor;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitTryCatchBlock(Label start, Label end, Label handler, @MaybeNull String type) {
&nbsp;                            this.methodVisitor.visitTryCatchBlock(start, end, handler, type);
&nbsp;                            AdviceMethodInliner.this.labels.addAll(Arrays.asList(start, end, handler));
&nbsp;                        }
&nbsp;
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
&nbsp;                            return this.methodVisitor.visitTryCatchAnnotation(typeReference, typePath, descriptor, visible);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected class ExceptionTableSubstitutor extends MethodVisitor {
&nbsp;                        private final Map&lt;Label, Label&gt; substitutions = new IdentityHashMap();
&nbsp;                        private int index;
&nbsp;
<b class="nc">&nbsp;                        protected ExceptionTableSubstitutor(MethodVisitor methodVisitor) {</b>
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, methodVisitor);</b>
&nbsp;                        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {</b>
&nbsp;                            this.substitutions.put(start, AdviceMethodInliner.this.labels.get(this.index++));
&nbsp;                            this.substitutions.put(end, AdviceMethodInliner.this.labels.get(this.index++));
<b class="nc">&nbsp;                            Label actualHandler = (Label)AdviceMethodInliner.this.labels.get(this.index++);</b>
&nbsp;                            this.substitutions.put(handler, actualHandler);
&nbsp;                            ((CodeTranslationVisitor)this.mv).propagateHandler(actualHandler);
&nbsp;                        }
&nbsp;
&nbsp;                        @MaybeNull
<b class="nc">&nbsp;                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {</b>
<b class="nc">&nbsp;                            return Advice.Dispatcher.IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public void visitLabel(Label label) {</b>
&nbsp;                            super.visitLabel(this.resolve(label));
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitJumpInsn(int opcode, Label label) {
&nbsp;                            super.visitJumpInsn(opcode, this.resolve(label));
&nbsp;                        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                        public void visitTableSwitchInsn(int minimum, int maximum, Label defaultOption, Label... label) {</b>
&nbsp;                            super.visitTableSwitchInsn(minimum, maximum, defaultOption, this.resolve(label));
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public void visitLookupSwitchInsn(Label defaultOption, int[] keys, Label[] label) {
<b class="nc">&nbsp;                            super.visitLookupSwitchInsn(this.resolve(defaultOption), keys, this.resolve(label));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        private Label[] resolve(Label[] label) {
&nbsp;                            Label[] resolved = new Label[label.length];
&nbsp;                            int index = 0;
&nbsp;
<b class="nc">&nbsp;                            for(Label aLabel : label) {</b>
&nbsp;                                resolved[index++] = this.resolve(aLabel);
&nbsp;                            }
&nbsp;
&nbsp;                            return resolved;
&nbsp;                        }
&nbsp;
&nbsp;                        private Label resolve(Label label) {
<b class="nc">&nbsp;                            Label substitution = (Label)this.substitutions.get(label);</b>
&nbsp;                            return substitution == null ? label : substitution;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
<b class="nc">&nbsp;                protected abstract static class ForMethodEnter extends Resolved implements Resolved.ForMethodEnter {</b>
&nbsp;                    private final Map&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;                    private final boolean prependLineNumber;
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, AsmClassReader classReader) {
&nbsp;                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(Advice.OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForAllArguments.Factory.INSTANCE, Advice.OffsetMapping.ForThisReference.Factory.INSTANCE, Advice.OffsetMapping.ForField.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, Advice.OffsetMapping.ForOrigin.Factory.INSTANCE, Advice.OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, Advice.OffsetMapping.ForUnusedValue.Factory.INSTANCE, Advice.OffsetMapping.ForStubValue.INSTANCE, Advice.OffsetMapping.ForThrowable.Factory.INSTANCE, Advice.OffsetMapping.ForExitValue.Factory.of(exitType), new OffsetMapping.ForLocalValue.Factory(namedTypes), new OffsetMapping.Factory.Illegal(Thrown.class), new OffsetMapping.Factory.Illegal(Enter.class), new OffsetMapping.Factory.Illegal(Return.class)), userFactories), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SUPPRESS_ENTER).resolve(TypeDescription.class), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SKIP_ON).resolve(TypeDescription.class), (Integer)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SKIP_ON_INDEX).resolve(Integer.class), classReader);
<b class="nc">&nbsp;                        this.namedTypes = namedTypes;</b>
&nbsp;                        this.prependLineNumber = (Boolean)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.PREPEND_LINE_NUMBER).resolve(Boolean.class);
&nbsp;                    }
&nbsp;
&nbsp;                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, AsmClassReader classReader, boolean methodExit) {
&nbsp;                        return (Resolved.ForMethodEnter)(methodExit ? new WithRetainedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader) : new WithDiscardedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler argumentHandler) {
<b class="nc">&nbsp;                        SortedMap&lt;Integer, TypeDefinition&gt; resolved = new TreeMap();</b>
&nbsp;
&nbsp;                        for(Map.Entry&lt;String, TypeDefinition&gt; entry : this.namedTypes.entrySet()) {
&nbsp;                            resolved.put(argumentHandler.named((String)entry.getKey()), entry.getValue());
&nbsp;                        }
&nbsp;
&nbsp;                        return resolved;
&nbsp;                    }
&nbsp;
&nbsp;                    public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
&nbsp;                        return new AdviceMethodInliner(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, this.suppressionHandler.bind(exceptionHandler), this.relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler, this.classReader);
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public boolean isPrependLineNumber() {
&nbsp;                        return this.prependLineNumber;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDefinition getActualAdviceType() {
&nbsp;                        return this.adviceMethod.getReturnType();
&nbsp;                    }
&nbsp;
&nbsp;                    public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="nc">&nbsp;                        return this.namedTypes;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    protected MethodVisitor apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                        return this.doApply(methodVisitor, implementationContext, assigner, argumentHandler.bindEnter(this.adviceMethod), methodSizeHandler.bindEnter(this.adviceMethod), stackMapFrameHandler.bindEnter(this.adviceMethod), instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    protected MethodVisitor doApply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                        Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings = new HashMap();
&nbsp;
<b class="nc">&nbsp;                        for(Map.Entry&lt;Integer, OffsetMapping&gt; entry : this.offsetMappings.entrySet()) {</b>
&nbsp;                            offsetMappings.put(entry.getKey(), ((OffsetMapping)entry.getValue()).resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, Advice.OffsetMapping.Sort.ENTER));
&nbsp;                        }
&nbsp;
&nbsp;                        return new CodeTranslationVisitor(methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, assigner, this.adviceMethod, offsetMappings, suppressionHandler, relocationHandler, exceptionHandler, this.postProcessor, false);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.prependLineNumber != ((ForMethodEnter)var1).prependLineNumber) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.namedTypes.equals(((ForMethodEnter)var1).namedTypes);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (super.hashCode() * 31 + this.namedTypes.hashCode()) * 31 + this.prependLineNumber;
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithRetainedEnterType extends ForMethodEnter {
&nbsp;                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, AsmClassReader classReader) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDefinition getAdviceType() {
&nbsp;                            return this.adviceMethod.getReturnType();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithDiscardedEnterType extends ForMethodEnter {
&nbsp;                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, AsmClassReader classReader) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDefinition getAdviceType() {
&nbsp;                            return ForLoadedType.of(Void.TYPE);
&nbsp;                        }
&nbsp;
&nbsp;                        protected MethodVisitor doApply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                            methodSizeHandler.requireLocalVariableLengthPadding(this.adviceMethod.getReturnType().getStackSize().getSize());
&nbsp;                            return super.doApply(methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected abstract static class ForMethodExit extends Resolved implements Resolved.ForMethodExit {
&nbsp;                    private final Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes;
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, AsmClassReader classReader, TypeDefinition enterType) {
&nbsp;                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(Advice.OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForAllArguments.Factory.INSTANCE, Advice.OffsetMapping.ForThisReference.Factory.INSTANCE, Advice.OffsetMapping.ForField.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, Advice.OffsetMapping.ForOrigin.Factory.INSTANCE, Advice.OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, Advice.OffsetMapping.ForUnusedValue.Factory.INSTANCE, Advice.OffsetMapping.ForStubValue.INSTANCE, Advice.OffsetMapping.ForEnterValue.Factory.of(enterType), Advice.OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()), new OffsetMapping.ForLocalValue.Factory(namedTypes), Advice.OffsetMapping.ForReturnValue.Factory.INSTANCE, Advice.OffsetMapping.ForThrowable.Factory.of(adviceMethod)), userFactories), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.SUPPRESS_EXIT).resolve(TypeDescription.class), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.REPEAT_ON).resolve(TypeDescription.class), (Integer)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.REPEAT_ON_INDEX).resolve(Integer.class), classReader);
&nbsp;                        this.uninitializedNamedTypes = uninitializedNamedTypes;
&nbsp;                        this.backupArguments = (Boolean)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.BACKUP_ARGUMENTS).resolve(Boolean.class);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, AsmClassReader classReader, TypeDefinition enterType) {
&nbsp;                        TypeDescription throwable = (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.ON_THROWABLE).resolve(TypeDescription.class);
&nbsp;                        return (Resolved.ForMethodExit)(throwable.represents(NoExceptionHandler.class) ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType) : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType, throwable));
&nbsp;                    }
&nbsp;
&nbsp;                    public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
&nbsp;                        return this.uninitializedNamedTypes;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler argumentHandler) {
&nbsp;                        SortedMap&lt;Integer, TypeDefinition&gt; resolved = new TreeMap();
&nbsp;
&nbsp;                        for(Map.Entry&lt;String, TypeDefinition&gt; entry : this.uninitializedNamedTypes.entrySet()) {
&nbsp;                            resolved.put(argumentHandler.named((String)entry.getKey()), entry.getValue());
&nbsp;                        }
&nbsp;
&nbsp;                        if (!this.adviceMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            resolved.put(argumentHandler.exit(), this.adviceMethod.getReturnType());
&nbsp;                        }
&nbsp;
&nbsp;                        return resolved;
&nbsp;                    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    protected MethodVisitor apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {</b>
<b class="nc">&nbsp;                        return this.doApply(methodVisitor, implementationContext, assigner, argumentHandler.bindExit(this.adviceMethod, this.getThrowable().represents(NoExceptionHandler.class)), methodSizeHandler.bindExit(this.adviceMethod), stackMapFrameHandler.bindExit(this.adviceMethod), instrumentedType, instrumentedMethod, suppressionHandler, relocationHandler, exceptionHandler);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    private MethodVisitor doApply(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                        Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings = new HashMap();
&nbsp;
&nbsp;                        for(Map.Entry&lt;Integer, OffsetMapping&gt; entry : this.offsetMappings.entrySet()) {
<b class="nc">&nbsp;                            offsetMappings.put(entry.getKey(), ((OffsetMapping)entry.getValue()).resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, Advice.OffsetMapping.Sort.EXIT));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        return new CodeTranslationVisitor(methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, instrumentedType, instrumentedMethod, assigner, this.adviceMethod, offsetMappings, suppressionHandler, relocationHandler, exceptionHandler, this.postProcessor, true);
&nbsp;                    }
&nbsp;
&nbsp;                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
&nbsp;                        return this.backupArguments ? Advice.ArgumentHandler.Factory.COPYING : Advice.ArgumentHandler.Factory.SIMPLE;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDefinition getAdviceType() {
&nbsp;                        return this.adviceMethod.getReturnType();
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {</b>
&nbsp;                        return new AdviceMethodInliner(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, this.suppressionHandler.bind(exceptionHandler), this.relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler, this.classReader);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.backupArguments != ((ForMethodExit)var1).backupArguments) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.uninitializedNamedTypes.equals(((ForMethodExit)var1).uninitializedNamedTypes);
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (super.hashCode() * 31 + this.uninitializedNamedTypes.hashCode()) * 31 + this.backupArguments;
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    @Enhance</b>
&nbsp;                    protected static class WithExceptionHandler extends ForMethodExit {
&nbsp;                        private final TypeDescription throwable;
&nbsp;
&nbsp;                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, AsmClassReader classReader, TypeDefinition enterType, TypeDescription throwable) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);
&nbsp;                            this.throwable = throwable;
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription getThrowable() {
&nbsp;                            return this.throwable;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (!super.equals(var1)) {
<b class="nc">&nbsp;                                return false;</b>
&nbsp;                            } else if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.throwable.equals(((WithExceptionHandler)var1).throwable);
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return super.hashCode() * 31 + this.throwable.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    protected static class WithoutExceptionHandler extends ForMethodExit {</b>
&nbsp;                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, AsmClassReader classReader, TypeDefinition enterType) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDescription getThrowable() {
&nbsp;                            return Advice.NoExceptionHandler.DESCRIPTION;
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class CodeTranslationVisitor extends MethodVisitor {
&nbsp;                protected final MethodVisitor methodVisitor;
&nbsp;                protected final Implementation.Context implementationContext;
&nbsp;                protected final ArgumentHandler.ForAdvice argumentHandler;
&nbsp;                protected final MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;                protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;                private final Assigner assigner;
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;                private final Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings;
&nbsp;                private final SuppressionHandler.Bound suppressionHandler;
&nbsp;                private final RelocationHandler.Bound relocationHandler;
&nbsp;                private final StackManipulation exceptionHandler;
&nbsp;                private final PostProcessor postProcessor;
&nbsp;                private final boolean exit;
&nbsp;                protected final Label endOfMethod;
&nbsp;
&nbsp;                protected CodeTranslationVisitor(MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, MethodDescription.InDefinedShape adviceMethod, Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, PostProcessor postProcessor, boolean exit) {
&nbsp;                    super(OpenedClassReader.ASM_API, StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod));
&nbsp;                    this.methodVisitor = methodVisitor;
&nbsp;                    this.implementationContext = implementationContext;
&nbsp;                    this.argumentHandler = argumentHandler;
&nbsp;                    this.methodSizeHandler = methodSizeHandler;
&nbsp;                    this.stackMapFrameHandler = stackMapFrameHandler;
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.instrumentedMethod = instrumentedMethod;
&nbsp;                    this.assigner = assigner;
&nbsp;                    this.adviceMethod = adviceMethod;
&nbsp;                    this.offsetMappings = offsetMappings;
&nbsp;                    this.suppressionHandler = suppressionHandler;
&nbsp;                    this.relocationHandler = relocationHandler;
&nbsp;                    this.exceptionHandler = exceptionHandler;
&nbsp;                    this.postProcessor = postProcessor;
&nbsp;                    this.exit = exit;
&nbsp;                    this.endOfMethod = new Label();
&nbsp;                }
&nbsp;
&nbsp;                protected void propagateHandler(Label label) {
&nbsp;                    ((StackAwareMethodVisitor)this.mv).register(label, Collections.singletonList(StackSize.SINGLE));
&nbsp;                }
&nbsp;
&nbsp;                public void visitParameter(String name, int modifiers) {
&nbsp;                }
&nbsp;
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
&nbsp;                    return Advice.Dispatcher.IGNORE_ANNOTATION;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;                    return Advice.Dispatcher.IGNORE_ANNOTATION;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    return Advice.Dispatcher.IGNORE_ANNOTATION;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
&nbsp;                    return Advice.Dispatcher.IGNORE_ANNOTATION;
&nbsp;                }
&nbsp;
&nbsp;                public void visitAttribute(Attribute attribute) {
&nbsp;                }
&nbsp;
&nbsp;                public void visitCode() {
&nbsp;                    this.suppressionHandler.onStart(this.methodVisitor);
&nbsp;                }
&nbsp;
&nbsp;                public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                    this.stackMapFrameHandler.translateFrame(this.methodVisitor, type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                }
&nbsp;
&nbsp;                public void visitVarInsn(int opcode, int offset) {
&nbsp;                    OffsetMapping.Target target = (OffsetMapping.Target)this.offsetMappings.get(offset);
&nbsp;                    if (target != null) {
&nbsp;                        StackManipulation stackManipulation;
&nbsp;                        StackSize expectedGrowth;
&nbsp;                        switch (opcode) {
&nbsp;                            case 21:
&nbsp;                            case 23:
&nbsp;                            case 25:
&nbsp;                                stackManipulation = target.resolveRead();
&nbsp;                                expectedGrowth = StackSize.SINGLE;
&nbsp;                                break;
&nbsp;                            case 22:
&nbsp;                            case 24:
&nbsp;                                stackManipulation = target.resolveRead();
&nbsp;                                expectedGrowth = StackSize.DOUBLE;
&nbsp;                                break;
&nbsp;                            case 26:
&nbsp;                            case 27:
&nbsp;                            case 28:
&nbsp;                            case 29:
&nbsp;                            case 30:
&nbsp;                            case 31:
&nbsp;                            case 32:
&nbsp;                            case 33:
&nbsp;                            case 34:
&nbsp;                            case 35:
&nbsp;                            case 36:
&nbsp;                            case 37:
&nbsp;                            case 38:
&nbsp;                            case 39:
&nbsp;                            case 40:
&nbsp;                            case 41:
&nbsp;                            case 42:
&nbsp;                            case 43:
&nbsp;                            case 44:
&nbsp;                            case 45:
&nbsp;                            case 46:
&nbsp;                            case 47:
&nbsp;                            case 48:
&nbsp;                            case 49:
&nbsp;                            case 50:
&nbsp;                            case 51:
&nbsp;                            case 52:
&nbsp;                            case 53:
&nbsp;                            default:
&nbsp;                                throw new IllegalStateException(&quot;Unexpected opcode: &quot; + opcode);
&nbsp;                            case 54:
&nbsp;                            case 55:
&nbsp;                            case 56:
&nbsp;                            case 57:
&nbsp;                            case 58:
&nbsp;                                stackManipulation = target.resolveWrite();
&nbsp;                                expectedGrowth = StackSize.ZERO;
&nbsp;                        }
&nbsp;
&nbsp;                        this.methodSizeHandler.requireStackSizePadding(stackManipulation.apply(this.mv, this.implementationContext).getMaximalSize() - expectedGrowth.getSize());
&nbsp;                    } else {
&nbsp;                        this.mv.visitVarInsn(opcode, this.argumentHandler.mapped(offset));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void visitIincInsn(int offset, int value) {
&nbsp;                    OffsetMapping.Target target = (OffsetMapping.Target)this.offsetMappings.get(offset);
&nbsp;                    if (target != null) {
&nbsp;                        this.methodSizeHandler.requireStackSizePadding(target.resolveIncrement(value).apply(this.mv, this.implementationContext).getMaximalSize());
&nbsp;                    } else {
&nbsp;                        this.mv.visitIincInsn(this.argumentHandler.mapped(offset), value);
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void visitInsn(int opcode) {
&nbsp;                    switch (opcode) {
&nbsp;                        case 172:
&nbsp;                            this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(54, 21, StackSize.SINGLE));
&nbsp;                            break;
&nbsp;                        case 173:
&nbsp;                            this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(55, 22, StackSize.DOUBLE));
&nbsp;                            break;
&nbsp;                        case 174:
&nbsp;                            this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(56, 23, StackSize.SINGLE));
&nbsp;                            break;
&nbsp;                        case 175:
&nbsp;                            this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(57, 24, StackSize.DOUBLE));
&nbsp;                            break;
&nbsp;                        case 176:
&nbsp;                            this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(58, 25, StackSize.SINGLE));
&nbsp;                            break;
&nbsp;                        case 177:
&nbsp;                            ((StackAwareMethodVisitor)this.mv).drainStack();
&nbsp;                            break;
&nbsp;                        default:
&nbsp;                            this.mv.visitInsn(opcode);
&nbsp;                            return;
&nbsp;                    }
&nbsp;
&nbsp;                    this.mv.visitJumpInsn(167, this.endOfMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void visitEnd() {
&nbsp;                    this.suppressionHandler.onEnd(this.methodVisitor, this.implementationContext, this.methodSizeHandler, this.stackMapFrameHandler, this.adviceMethod.getReturnType());
&nbsp;                    this.methodVisitor.visitLabel(this.endOfMethod);
&nbsp;                    if (!this.adviceMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                        if (this.adviceMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.methodVisitor);
&nbsp;                            this.methodVisitor.visitVarInsn(55, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                        } else if (this.adviceMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.methodVisitor);
&nbsp;                            this.methodVisitor.visitVarInsn(56, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                        } else if (this.adviceMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.methodVisitor);
&nbsp;                            this.methodVisitor.visitVarInsn(57, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                        } else if (!this.adviceMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.methodVisitor);
&nbsp;                            this.methodVisitor.visitVarInsn(58, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        this.stackMapFrameHandler.injectReturnFrame(this.methodVisitor);
&nbsp;                        this.methodVisitor.visitVarInsn(54, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                    }
&nbsp;
&nbsp;                    this.methodSizeHandler.requireStackSize(this.postProcessor.resolve(this.instrumentedType, this.instrumentedMethod, this.assigner, this.argumentHandler, this.stackMapFrameHandler, this.exceptionHandler).apply(this.methodVisitor, this.implementationContext).getMaximalSize());
&nbsp;                    this.methodSizeHandler.requireStackSize(this.relocationHandler.apply(this.methodVisitor, this.implementationContext, this.exit ? this.argumentHandler.exit() : this.argumentHandler.enter()));
&nbsp;                    this.stackMapFrameHandler.injectCompletionFrame(this.methodVisitor);
&nbsp;                }
&nbsp;
&nbsp;                public void visitMaxs(int stackSize, int localVariableLength) {
&nbsp;                    this.methodSizeHandler.recordMaxima(stackSize, localVariableLength);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Delegating implements Unresolved {
&nbsp;            protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;            protected final Delegator.Factory delegatorFactory;
&nbsp;
&nbsp;            protected Delegating(MethodDescription.InDefinedShape adviceMethod, Delegator.Factory delegatorFactory) {
&nbsp;                this.adviceMethod = adviceMethod;
&nbsp;                this.delegatorFactory = delegatorFactory;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isAlive() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isBinary() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getAdviceType() {
&nbsp;                return this.adviceMethod.getReturnType().asErasure();
&nbsp;            }
&nbsp;
&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
&nbsp;                return Collections.emptyMap();
&nbsp;            }
&nbsp;
&nbsp;            public Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodExit, PostProcessor.Factory postProcessorFactory) {
&nbsp;                return Advice.Dispatcher.Delegating.Resolved.ForMethodEnter.of(this.adviceMethod, postProcessorFactory.make(this.adviceMethod, false), this.delegatorFactory.make(this.adviceMethod, false), userFactories, methodExit.getAdviceType(), methodExit.isAlive());
&nbsp;            }
&nbsp;
&nbsp;            public Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, @MaybeNull AsmClassReader classReader, Unresolved methodEnter, PostProcessor.Factory postProcessorFactory) {
&nbsp;                Map&lt;String, TypeDefinition&gt; namedTypes = methodEnter.getNamedTypes();
&nbsp;
&nbsp;                for(ParameterDescription parameterDescription : this.adviceMethod.getParameters()) {
&nbsp;                    AnnotationDescription.Loadable&lt;Local&gt; annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);
&nbsp;                    if (annotationDescription != null) {
&nbsp;                        String name = (String)annotationDescription.getValue(Advice.OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);
&nbsp;                        TypeDefinition typeDefinition = (TypeDefinition)namedTypes.get(name);
&nbsp;                        if (typeDefinition == null) {
&nbsp;                            throw new IllegalStateException(this.adviceMethod + &quot; attempts use of undeclared local variable &quot; + name);
&nbsp;                        }
&nbsp;
&nbsp;                        if (!typeDefinition.equals(parameterDescription.getType())) {
&nbsp;                            throw new IllegalStateException(this.adviceMethod + &quot; does not read variable &quot; + name + &quot; as &quot; + typeDefinition);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return Advice.Dispatcher.Delegating.Resolved.ForMethodExit.of(this.adviceMethod, postProcessorFactory.make(this.adviceMethod, true), this.delegatorFactory.make(this.adviceMethod, true), namedTypes, userFactories, methodEnter.getAdviceType());
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return &quot;Delegate to &quot; + this.adviceMethod;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.adviceMethod.equals(((Delegating)var1).adviceMethod)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.delegatorFactory.equals(((Delegating)var1).delegatorFactory);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.adviceMethod.hashCode()) * 31 + this.delegatorFactory.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class Resolved extends Resolved.AbstractBase {
&nbsp;                protected final Delegator delegator;
&nbsp;
&nbsp;                protected Resolved(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, Delegator delegator) {
&nbsp;                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, Advice.OffsetMapping.Factory.AdviceType.DELEGATION);
&nbsp;                    this.delegator = delegator;
&nbsp;                }
&nbsp;
&nbsp;                public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
&nbsp;                    return Collections.emptyMap();
&nbsp;                }
&nbsp;
&nbsp;                public Bound bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
&nbsp;                    if (!this.adviceMethod.isVisibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(this.adviceMethod + &quot; is not visible to &quot; + instrumentedMethod.getDeclaringType());
&nbsp;                    } else {
&nbsp;                        return this.resolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, exceptionHandler, relocation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Bound resolve(TypeDescription var1, MethodDescription var2, MethodVisitor var3, Implementation.Context var4, Assigner var5, ArgumentHandler.ForInstrumentedMethod var6, MethodSizeHandler.ForInstrumentedMethod var7, StackMapFrameHandler.ForInstrumentedMethod var8, StackManipulation var9, RelocationHandler.Relocation var10);
&nbsp;
&nbsp;                protected abstract static class AdviceMethodWriter implements Bound {
&nbsp;                    protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;                    private final MethodDescription instrumentedMethod;
&nbsp;                    private final Assigner assigner;
&nbsp;                    private final List&lt;OffsetMapping.Target&gt; offsetMappings;
&nbsp;                    protected final MethodVisitor methodVisitor;
&nbsp;                    protected final Implementation.Context implementationContext;
&nbsp;                    protected final ArgumentHandler.ForAdvice argumentHandler;
&nbsp;                    protected final MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;                    protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;                    private final SuppressionHandler.Bound suppressionHandler;
&nbsp;                    private final RelocationHandler.Bound relocationHandler;
&nbsp;                    private final StackManipulation exceptionHandler;
&nbsp;                    private final PostProcessor postProcessor;
&nbsp;                    private final Delegator delegator;
&nbsp;
&nbsp;                    protected AdviceMethodWriter(MethodDescription.InDefinedShape adviceMethod, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List&lt;OffsetMapping.Target&gt; offsetMappings, MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
&nbsp;                        this.adviceMethod = adviceMethod;
&nbsp;                        this.instrumentedType = instrumentedType;
&nbsp;                        this.instrumentedMethod = instrumentedMethod;
&nbsp;                        this.assigner = assigner;
&nbsp;                        this.postProcessor = postProcessor;
&nbsp;                        this.offsetMappings = offsetMappings;
&nbsp;                        this.methodVisitor = methodVisitor;
&nbsp;                        this.implementationContext = implementationContext;
&nbsp;                        this.argumentHandler = argumentHandler;
&nbsp;                        this.methodSizeHandler = methodSizeHandler;
&nbsp;                        this.stackMapFrameHandler = stackMapFrameHandler;
&nbsp;                        this.suppressionHandler = suppressionHandler;
&nbsp;                        this.relocationHandler = relocationHandler;
&nbsp;                        this.exceptionHandler = exceptionHandler;
&nbsp;                        this.delegator = delegator;
&nbsp;                    }
&nbsp;
&nbsp;                    public void prepare() {
&nbsp;                        this.suppressionHandler.onPrepare(this.methodVisitor);
&nbsp;                    }
&nbsp;
&nbsp;                    public void apply() {
&nbsp;                        this.suppressionHandler.onStart(this.methodVisitor);
&nbsp;                        int index = 0;
&nbsp;                        int currentStackSize = 0;
&nbsp;                        int maximumStackSize = 0;
&nbsp;
&nbsp;                        for(OffsetMapping.Target offsetMapping : this.offsetMappings) {
&nbsp;                            currentStackSize += ((ParameterDescription.InDefinedShape)this.adviceMethod.getParameters().get(index++)).getType().getStackSize().getSize();
&nbsp;                            maximumStackSize = Math.max(maximumStackSize, currentStackSize + offsetMapping.resolveRead().apply(this.methodVisitor, this.implementationContext).getMaximalSize());
&nbsp;                        }
&nbsp;
&nbsp;                        maximumStackSize = Math.max(maximumStackSize, this.delegator.apply(this.instrumentedType, this.instrumentedMethod).apply(this.methodVisitor, this.implementationContext).getMaximalSize());
&nbsp;                        this.suppressionHandler.onEndWithSkip(this.methodVisitor, this.implementationContext, this.methodSizeHandler, this.stackMapFrameHandler, this.adviceMethod.getReturnType());
&nbsp;                        if (!this.adviceMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                            if (this.adviceMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                                this.methodVisitor.visitVarInsn(55, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                            } else if (this.adviceMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                                this.methodVisitor.visitVarInsn(56, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                            } else if (this.adviceMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                                this.methodVisitor.visitVarInsn(57, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                            } else if (this.adviceMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                                this.methodVisitor.visitInsn(0);
&nbsp;                            } else {
&nbsp;                                this.methodVisitor.visitVarInsn(58, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            this.methodVisitor.visitVarInsn(54, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter());
&nbsp;                        }
&nbsp;
&nbsp;                        this.methodSizeHandler.requireStackSize(this.postProcessor.resolve(this.instrumentedType, this.instrumentedMethod, this.assigner, this.argumentHandler, this.stackMapFrameHandler, this.exceptionHandler).apply(this.methodVisitor, this.implementationContext).getMaximalSize());
&nbsp;                        this.methodSizeHandler.requireStackSize(this.relocationHandler.apply(this.methodVisitor, this.implementationContext, this.isExitAdvice() ? this.argumentHandler.exit() : this.argumentHandler.enter()));
&nbsp;                        this.stackMapFrameHandler.injectCompletionFrame(this.methodVisitor);
&nbsp;                        this.methodSizeHandler.requireStackSize(Math.max(maximumStackSize, this.adviceMethod.getReturnType().getStackSize().getSize()));
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(this.instrumentedMethod.getStackSize() + this.adviceMethod.getReturnType().getStackSize().getSize());
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract boolean isExitAdvice();
&nbsp;
&nbsp;                    protected static class ForMethodEnter extends AdviceMethodWriter {
&nbsp;                        protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List&lt;OffsetMapping.Target&gt; offsetMappings, MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
&nbsp;                            super(adviceMethod, instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        public void initialize() {
&nbsp;                        }
&nbsp;
&nbsp;                        protected boolean isExitAdvice() {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class ForMethodExit extends AdviceMethodWriter {
&nbsp;                        protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, PostProcessor postProcessor, List&lt;OffsetMapping.Target&gt; offsetMappings, MethodVisitor methodVisitor, Implementation.Context implementationContext, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler, Delegator delegator) {
&nbsp;                            super(adviceMethod, instrumentedType, instrumentedMethod, assigner, postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        public void initialize() {
&nbsp;                            if (!this.adviceMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.adviceMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                                if (this.adviceMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                                    this.methodVisitor.visitInsn(9);
&nbsp;                                    this.methodVisitor.visitVarInsn(55, this.argumentHandler.exit());
&nbsp;                                } else if (this.adviceMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                                    this.methodVisitor.visitInsn(11);
&nbsp;                                    this.methodVisitor.visitVarInsn(56, this.argumentHandler.exit());
&nbsp;                                } else if (this.adviceMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                                    this.methodVisitor.visitInsn(14);
&nbsp;                                    this.methodVisitor.visitVarInsn(57, this.argumentHandler.exit());
&nbsp;                                } else if (!this.adviceMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                                    this.methodVisitor.visitInsn(1);
&nbsp;                                    this.methodVisitor.visitVarInsn(58, this.argumentHandler.exit());
&nbsp;                                }
&nbsp;                            } else {
&nbsp;                                this.methodVisitor.visitInsn(3);
&nbsp;                                this.methodVisitor.visitVarInsn(54, this.argumentHandler.exit());
&nbsp;                            }
&nbsp;
&nbsp;                            this.methodSizeHandler.requireStackSize(this.adviceMethod.getReturnType().getStackSize().getSize());
&nbsp;                        }
&nbsp;
&nbsp;                        protected boolean isExitAdvice() {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected abstract static class ForMethodEnter extends Resolved implements Resolved.ForMethodEnter {
&nbsp;                    private final boolean prependLineNumber;
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, Delegator delegator) {
&nbsp;                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(Advice.OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForAllArguments.Factory.INSTANCE, Advice.OffsetMapping.ForThisReference.Factory.INSTANCE, Advice.OffsetMapping.ForField.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, Advice.OffsetMapping.ForOrigin.Factory.INSTANCE, Advice.OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, Advice.OffsetMapping.ForUnusedValue.Factory.INSTANCE, Advice.OffsetMapping.ForStubValue.INSTANCE, Advice.OffsetMapping.ForExitValue.Factory.of(exitType), new OffsetMapping.Factory.Illegal(Thrown.class), new OffsetMapping.Factory.Illegal(Enter.class), new OffsetMapping.Factory.Illegal(Local.class), new OffsetMapping.Factory.Illegal(Return.class)), userFactories), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SUPPRESS_ENTER).resolve(TypeDescription.class), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SKIP_ON).resolve(TypeDescription.class), (Integer)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.SKIP_ON_INDEX).resolve(Integer.class), delegator);
&nbsp;                        this.prependLineNumber = (Boolean)adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(Advice.PREPEND_LINE_NUMBER).resolve(Boolean.class);
&nbsp;                    }
&nbsp;
&nbsp;                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Delegator delegator, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, boolean methodExit) {
&nbsp;                        return (Resolved.ForMethodEnter)(methodExit ? new WithRetainedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator) : new WithDiscardedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isPrependLineNumber() {
&nbsp;                        return this.prependLineNumber;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDefinition getActualAdviceType() {
&nbsp;                        return this.adviceMethod.getReturnType();
&nbsp;                    }
&nbsp;
&nbsp;                    protected Bound resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
&nbsp;                        return this.doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler.bindEnter(this.adviceMethod), methodSizeHandler.bindEnter(this.adviceMethod), stackMapFrameHandler.bindEnter(this.adviceMethod), this.suppressionHandler.bind(exceptionHandler), this.relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                        List&lt;OffsetMapping.Target&gt; offsetMappings = new ArrayList(this.offsetMappings.size());
&nbsp;
&nbsp;                        for(OffsetMapping offsetMapping : this.offsetMappings.values()) {
&nbsp;                            offsetMappings.add(offsetMapping.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, Advice.OffsetMapping.Sort.ENTER));
&nbsp;                        }
&nbsp;
&nbsp;                        return new AdviceMethodWriter.ForMethodEnter(this.adviceMethod, instrumentedType, instrumentedMethod, assigner, this.postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, this.delegator);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.prependLineNumber == ((ForMethodEnter)var1).prependLineNumber;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.prependLineNumber;
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithRetainedEnterType extends ForMethodEnter {
&nbsp;                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, Delegator delegator) {
&nbsp;                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDefinition getAdviceType() {
&nbsp;                            return this.adviceMethod.getReturnType();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithDiscardedEnterType extends ForMethodEnter {
&nbsp;                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition exitType, Delegator delegator) {
&nbsp;                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeDefinition getAdviceType() {
&nbsp;                            return ForLoadedType.of(Void.TYPE);
&nbsp;                        }
&nbsp;
&nbsp;                        protected Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                            methodSizeHandler.requireLocalVariableLengthPadding(this.adviceMethod.getReturnType().getStackSize().getSize());
&nbsp;                            return super.doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected abstract static class ForMethodExit extends Resolved implements Resolved.ForMethodExit {
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition enterType, Delegator delegator) {
&nbsp;                        super(adviceMethod, postProcessor, CompoundList.of(Arrays.asList(Advice.OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForAllArguments.Factory.INSTANCE, Advice.OffsetMapping.ForThisReference.Factory.INSTANCE, Advice.OffsetMapping.ForField.Unresolved.Factory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE, Advice.OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE, Advice.OffsetMapping.ForOrigin.Factory.INSTANCE, Advice.OffsetMapping.ForSelfCallHandle.Factory.INSTANCE, Advice.OffsetMapping.ForUnusedValue.Factory.INSTANCE, Advice.OffsetMapping.ForStubValue.INSTANCE, Advice.OffsetMapping.ForEnterValue.Factory.of(enterType), Advice.OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()), new OffsetMapping.ForLocalValue.Factory(namedTypes), Advice.OffsetMapping.ForReturnValue.Factory.INSTANCE, Advice.OffsetMapping.ForThrowable.Factory.of(adviceMethod)), userFactories), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.SUPPRESS_EXIT).resolve(TypeDescription.class), (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.REPEAT_ON).resolve(TypeDescription.class), (Integer)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.REPEAT_ON_INDEX).resolve(Integer.class), delegator);
&nbsp;                        this.backupArguments = (Boolean)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.BACKUP_ARGUMENTS).resolve(Boolean.class);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Delegator delegator, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition enterType) {
&nbsp;                        TypeDescription throwable = (TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.ON_THROWABLE).resolve(TypeDescription.class);
&nbsp;                        return (Resolved.ForMethodExit)(throwable.represents(NoExceptionHandler.class) ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator) : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, throwable, delegator));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Bound resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForInstrumentedMethod argumentHandler, MethodSizeHandler.ForInstrumentedMethod methodSizeHandler, StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler, StackManipulation exceptionHandler, RelocationHandler.Relocation relocation) {
&nbsp;                        return this.doResolve(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, argumentHandler.bindExit(this.adviceMethod, this.getThrowable().represents(NoExceptionHandler.class)), methodSizeHandler.bindExit(this.adviceMethod), stackMapFrameHandler.bindExit(this.adviceMethod), this.suppressionHandler.bind(exceptionHandler), this.relocationHandler.bind(instrumentedMethod, relocation), exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    private Bound doResolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, ArgumentHandler.ForAdvice argumentHandler, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, SuppressionHandler.Bound suppressionHandler, RelocationHandler.Bound relocationHandler, StackManipulation exceptionHandler) {
&nbsp;                        List&lt;OffsetMapping.Target&gt; offsetMappings = new ArrayList(this.offsetMappings.size());
&nbsp;
&nbsp;                        for(OffsetMapping offsetMapping : this.offsetMappings.values()) {
&nbsp;                            offsetMappings.add(offsetMapping.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, Advice.OffsetMapping.Sort.EXIT));
&nbsp;                        }
&nbsp;
&nbsp;                        return new AdviceMethodWriter.ForMethodExit(this.adviceMethod, instrumentedType, instrumentedMethod, assigner, this.postProcessor, offsetMappings, methodVisitor, implementationContext, argumentHandler, methodSizeHandler, stackMapFrameHandler, suppressionHandler, relocationHandler, exceptionHandler, this.delegator);
&nbsp;                    }
&nbsp;
&nbsp;                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
&nbsp;                        return this.backupArguments ? Advice.ArgumentHandler.Factory.COPYING : Advice.ArgumentHandler.Factory.SIMPLE;
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDefinition getAdviceType() {
&nbsp;                        return this.adviceMethod.getReturnType();
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.backupArguments == ((ForMethodExit)var1).backupArguments;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.backupArguments;
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    protected static class WithExceptionHandler extends ForMethodExit {
&nbsp;                        private final TypeDescription throwable;
<b class="fc">&nbsp;</b>
&nbsp;                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition enterType, TypeDescription throwable, Delegator delegator) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);
&nbsp;                            this.throwable = throwable;
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        public TypeDescription getThrowable() {
&nbsp;                            return this.throwable;
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                            if (!super.equals(var1)) {
&nbsp;                                return false;
&nbsp;                            } else if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.throwable.equals(((WithExceptionHandler)var1).throwable);
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
&nbsp;                        public int hashCode() {
&nbsp;                            return super.hashCode() * 31 + this.throwable.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class WithoutExceptionHandler extends ForMethodExit {
&nbsp;                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, Map&lt;String, TypeDefinition&gt; namedTypes, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories, TypeDefinition enterType, Delegator delegator) {
&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public TypeDescription getThrowable() {
&nbsp;                            return Advice.NoExceptionHandler.DESCRIPTION;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Bound {
&nbsp;            void prepare();
&nbsp;
&nbsp;            void initialize();
&nbsp;
&nbsp;            void apply();
&nbsp;        }
&nbsp;
&nbsp;        public interface RelocationHandler {
&nbsp;            Bound bind(MethodDescription var1, Relocation var2);
&nbsp;
&nbsp;            public static enum Disabled implements RelocationHandler, Bound {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Disabled() {
&nbsp;                }
&nbsp;
&nbsp;                public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
&nbsp;                    return 0;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum ForValue {
&nbsp;                BOOLEAN(21, 51, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                },
&nbsp;                BYTE(21, 51, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                },
&nbsp;                SHORT(21, 53, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                },
&nbsp;                CHARACTER(21, 52, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                },
&nbsp;                INTEGER(21, 46, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                },
&nbsp;                LONG(22, 47, 154, 153, 0) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        methodVisitor.visitInsn(136);
&nbsp;                    }
&nbsp;                },
&nbsp;                FLOAT(23, 48, 154, 153, 2) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        methodVisitor.visitInsn(11);
&nbsp;                        methodVisitor.visitInsn(149);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                },</b>
&nbsp;                DOUBLE(24, 49, 154, 153, 4) {
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        methodVisitor.visitInsn(14);
&nbsp;                        methodVisitor.visitInsn(151);
&nbsp;                    }
&nbsp;                },
<b class="fc">&nbsp;                REFERENCE(25, 50, 199, 198, 0) {</b>
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private final int load;
&nbsp;                private final int arrayLoad;
<b class="nc">&nbsp;                private final int defaultJump;</b>
&nbsp;                private final int nonDefaultJump;
&nbsp;                private final int requiredSize;
&nbsp;
&nbsp;                private ForValue(int load, int arrayLoad, int defaultJump, int nonDefaultJump, int requiredSize) {
&nbsp;                    this.load = load;
&nbsp;                    this.arrayLoad = arrayLoad;
&nbsp;                    this.defaultJump = defaultJump;
&nbsp;                    this.nonDefaultJump = nonDefaultJump;
&nbsp;                    this.requiredSize = requiredSize;
&nbsp;                }
&nbsp;
&nbsp;                protected static RelocationHandler of(TypeDefinition typeDefinition, int index, boolean inverted) {
&nbsp;                    ForValue skipDispatcher;
&nbsp;                    if (typeDefinition.represents(Boolean.TYPE)) {
&nbsp;                        skipDispatcher = BOOLEAN;
&nbsp;                    } else if (typeDefinition.represents(Byte.TYPE)) {
&nbsp;                        skipDispatcher = BYTE;
&nbsp;                    } else if (typeDefinition.represents(Short.TYPE)) {
&nbsp;                        skipDispatcher = SHORT;
&nbsp;                    } else if (typeDefinition.represents(Character.TYPE)) {
&nbsp;                        skipDispatcher = CHARACTER;
&nbsp;                    } else if (typeDefinition.represents(Integer.TYPE)) {
&nbsp;                        skipDispatcher = INTEGER;
&nbsp;                    } else if (typeDefinition.represents(Long.TYPE)) {
&nbsp;                        skipDispatcher = LONG;
&nbsp;                    } else if (typeDefinition.represents(Float.TYPE)) {
&nbsp;                        skipDispatcher = FLOAT;
&nbsp;                    } else if (typeDefinition.represents(Double.TYPE)) {
&nbsp;                        skipDispatcher = DOUBLE;
&nbsp;                    } else {
&nbsp;                        if (typeDefinition.represents(Void.TYPE)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot skip on default value for void return type&quot;);
&nbsp;                        }
&nbsp;
&nbsp;                        skipDispatcher = REFERENCE;
&nbsp;                    }
&nbsp;
&nbsp;                    return (RelocationHandler)(inverted ? skipDispatcher.new OfNonDefault(index) : skipDispatcher.new OfDefault(index));
&nbsp;                }
&nbsp;
&nbsp;                protected abstract void convertValue(MethodVisitor var1);
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class OfDefault implements RelocationHandler {
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public OfDefault(int index) {
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
&nbsp;                        return ForValue.this.new Bound(instrumentedMethod, relocation, this.index, false);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((OfDefault)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return ForValue.this.equals(ForValue.this);
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return (this.getClass().hashCode() * 31 + this.index) * 31 + ForValue.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class OfNonDefault implements RelocationHandler {
&nbsp;                    private final int index;
&nbsp;
<b class="nc">&nbsp;                    protected OfNonDefault(int index) {</b>
<b class="nc">&nbsp;                        this.index = index;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {</b>
<b class="nc">&nbsp;                        return ForValue.this.new Bound(instrumentedMethod, relocation, this.index, true);</b>
&nbsp;                    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;                        if (this == var1) {</b>
&nbsp;                            return true;
<b class="nc">&nbsp;                        } else if (var1 == null) {</b>
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((OfNonDefault)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return ForValue.this.equals(ForValue.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.index) * 31 + ForValue.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class Bound implements Bound {
&nbsp;                    private final MethodDescription instrumentedMethod;
&nbsp;                    private final Relocation relocation;
&nbsp;                    private final int index;
&nbsp;                    private final boolean inverted;
&nbsp;
&nbsp;                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation, int index, boolean inverted) {
&nbsp;                        this.instrumentedMethod = instrumentedMethod;
&nbsp;                        this.relocation = relocation;
&nbsp;                        this.index = index;
&nbsp;                        this.inverted = inverted;
&nbsp;                    }
&nbsp;
&nbsp;                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
&nbsp;                        if (this.instrumentedMethod.isConstructor()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot skip code execution from constructor: &quot; + this.instrumentedMethod);
&nbsp;                        } else {
<b class="fc">&nbsp;                            Label noSkip = new Label();</b>
<b class="fc">&nbsp;                            int size;</b>
<b class="fc">&nbsp;                            if (this.index &lt; 0) {</b>
<b class="fc">&nbsp;                                size = ForValue.this.requiredSize;</b>
&nbsp;                                methodVisitor.visitVarInsn(ForValue.this.load, offset);
&nbsp;                            } else {
&nbsp;                                methodVisitor.visitVarInsn(25, offset);
&nbsp;                                methodVisitor.visitJumpInsn(198, noSkip);
&nbsp;                                methodVisitor.visitVarInsn(25, offset);
&nbsp;                                size = Math.max(ForValue.this.requiredSize, IntegerConstant.forValue(this.index).apply(methodVisitor, implementationContext).getMaximalSize() + 1);
&nbsp;                                methodVisitor.visitInsn(ForValue.this.arrayLoad);
&nbsp;                            }
<b class="nc">&nbsp;</b>
&nbsp;                            ForValue.this.convertValue(methodVisitor);
&nbsp;                            methodVisitor.visitJumpInsn(this.inverted ? ForValue.this.nonDefaultJump : ForValue.this.defaultJump, noSkip);
&nbsp;                            this.relocation.apply(methodVisitor);
&nbsp;                            methodVisitor.visitLabel(noSkip);
&nbsp;                            return size;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
<b class="nc">&nbsp;                        } else if (var1 == null) {</b>
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((Bound)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else if (this.inverted != ((Bound)var1).inverted) {
&nbsp;                            return false;
&nbsp;                        } else if (!ForValue.this.equals(ForValue.this)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.instrumentedMethod.equals(((Bound)var1).instrumentedMethod)) {
&nbsp;                            return false;
&nbsp;                        } else {
<b class="fc">&nbsp;                            return this.relocation.equals(((Bound)var1).relocation);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((((this.getClass().hashCode() * 31 + this.instrumentedMethod.hashCode()) * 31 + this.relocation.hashCode()) * 31 + this.index) * 31 + this.inverted) * 31 + ForValue.this.hashCode();
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            @Enhance
<b class="nc">&nbsp;            public static class ForType implements RelocationHandler {</b>
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForType(TypeDescription typeDescription, int index) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
<b class="nc">&nbsp;                )</b>
<b class="nc">&nbsp;                protected static RelocationHandler of(TypeDescription typeDescription, int index, TypeDefinition returnedType) {</b>
&nbsp;                    TypeDefinition targetType;
&nbsp;                    if (index &lt; 0) {
&nbsp;                        targetType = returnedType;
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        if (!returnedType.isArray()) {
&nbsp;                            throw new IllegalStateException(returnedType + &quot; is not an array type but an index for a relocation is defined&quot;);
&nbsp;                        }
&nbsp;
&nbsp;                        targetType = returnedType.getComponentType();
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    if (typeDescription.represents(Void.TYPE)) {
&nbsp;                        return Advice.Dispatcher.RelocationHandler.Disabled.INSTANCE;
&nbsp;                    } else if (typeDescription.represents(OnDefaultValue.class)) {
<b class="fc">&nbsp;                        return Advice.Dispatcher.RelocationHandler.ForValue.of(targetType, index, false);</b>
&nbsp;                    } else if (typeDescription.represents(OnNonDefaultValue.class)) {
&nbsp;                        return Advice.Dispatcher.RelocationHandler.ForValue.of(targetType, index, true);
&nbsp;                    } else if (!typeDescription.isPrimitive() &amp;&amp; !targetType.isPrimitive()) {
&nbsp;                        return new ForType(typeDescription, index);
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Cannot relocate execution by instance type for primitive type&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
&nbsp;                    return new Bound(instrumentedMethod, relocation);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((ForType)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typeDescription.equals(((ForType)var1).typeDescription);
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public int hashCode() {</b>
<b class="fc">&nbsp;                    return (this.getClass().hashCode() * 31 + this.typeDescription.hashCode()) * 31 + this.index;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                protected class Bound implements Bound {
&nbsp;                    private final MethodDescription instrumentedMethod;
<b class="fc">&nbsp;                    private final Relocation relocation;</b>
&nbsp;
&nbsp;                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation) {
&nbsp;                        this.instrumentedMethod = instrumentedMethod;
&nbsp;                        this.relocation = relocation;
&nbsp;                    }
&nbsp;
&nbsp;                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
&nbsp;                        if (this.instrumentedMethod.isConstructor()) {
<b class="pc">&nbsp;                            throw new IllegalStateException(&quot;Cannot skip code execution from constructor: &quot; + this.instrumentedMethod);</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            methodVisitor.visitVarInsn(25, offset);
<b class="fc">&nbsp;                            Label noSkip = new Label();</b>
&nbsp;                            int size;
&nbsp;                            if (ForType.this.index &lt; 0) {
&nbsp;                                size = 0;
&nbsp;                            } else {
&nbsp;                                methodVisitor.visitJumpInsn(198, noSkip);
&nbsp;                                methodVisitor.visitVarInsn(25, offset);
&nbsp;                                size = IntegerConstant.forValue(ForType.this.index).apply(methodVisitor, implementationContext).getMaximalSize() + 1;
&nbsp;                                methodVisitor.visitInsn(50);
&nbsp;                            }
&nbsp;
&nbsp;                            methodVisitor.visitTypeInsn(193, ForType.this.typeDescription.getInternalName());
&nbsp;                            methodVisitor.visitJumpInsn(153, noSkip);
&nbsp;                            this.relocation.apply(methodVisitor);
&nbsp;                            methodVisitor.visitLabel(noSkip);
&nbsp;                            return size;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.instrumentedMethod.equals(((Bound)var1).instrumentedMethod)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.relocation.equals(((Bound)var1).relocation)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return ForType.this.equals(ForType.this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.instrumentedMethod.hashCode()) * 31 + this.relocation.hashCode()) * 31 + ForType.this.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Bound {
&nbsp;                int NO_REQUIRED_SIZE = 0;
&nbsp;
&nbsp;                int apply(MethodVisitor var1, Implementation.Context var2, int var3);
&nbsp;            }
&nbsp;
&nbsp;            public interface Relocation {
&nbsp;                void apply(MethodVisitor var1);
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForLabel implements Relocation {
&nbsp;                    private final Label label;
&nbsp;
&nbsp;                    public ForLabel(Label label) {
&nbsp;                        this.label = label;
&nbsp;                    }
&nbsp;
&nbsp;                    public void apply(MethodVisitor methodVisitor) {
&nbsp;                        methodVisitor.visitJumpInsn(167, this.label);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.label.equals(((ForLabel)var1).label);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.label.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Resolved extends Dispatcher {
&nbsp;            Map&lt;String, TypeDefinition&gt; getNamedTypes();
&nbsp;
&nbsp;            Bound bind(TypeDescription var1, MethodDescription var2, MethodVisitor var3, Implementation.Context var4, Assigner var5, ArgumentHandler.ForInstrumentedMethod var6, MethodSizeHandler.ForInstrumentedMethod var7, StackMapFrameHandler.ForInstrumentedMethod var8, StackManipulation var9, RelocationHandler.Relocation var10);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class AbstractBase implements Resolved {
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;                protected final PostProcessor postProcessor;
&nbsp;                protected final Map&lt;Integer, OffsetMapping&gt; offsetMappings;
&nbsp;                protected final SuppressionHandler suppressionHandler;
&nbsp;                protected final RelocationHandler relocationHandler;
&nbsp;
&nbsp;                protected AbstractBase(MethodDescription.InDefinedShape adviceMethod, PostProcessor postProcessor, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories, TypeDescription throwableType, TypeDescription relocatableType, int relocatableIndex, OffsetMapping.Factory.AdviceType adviceType) {
&nbsp;                    this.adviceMethod = adviceMethod;
&nbsp;                    this.postProcessor = postProcessor;
&nbsp;                    Map&lt;TypeDescription, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new HashMap();
&nbsp;
&nbsp;                    for(OffsetMapping.Factory&lt;?&gt; factory : factories) {
&nbsp;                        offsetMappings.put(ForLoadedType.of(factory.getAnnotationType()), factory);
&nbsp;                    }
&nbsp;
&nbsp;                    this.offsetMappings = new LinkedHashMap();
&nbsp;
&nbsp;                    for(ParameterDescription.InDefinedShape parameterDescription : adviceMethod.getParameters()) {
&nbsp;                        OffsetMapping offsetMapping = null;
&nbsp;
&nbsp;                        for(AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {
&nbsp;                            OffsetMapping.Factory&lt;?&gt; factory = (OffsetMapping.Factory)offsetMappings.get(annotationDescription.getAnnotationType());
&nbsp;                            if (factory != null) {
&nbsp;                                OffsetMapping current = factory.make(parameterDescription, annotationDescription.prepare(factory.getAnnotationType()), adviceType);
&nbsp;                                if (offsetMapping != null) {
&nbsp;                                    throw new IllegalStateException(parameterDescription + &quot; is bound to both &quot; + current + &quot; and &quot; + offsetMapping);
&nbsp;                                }
&nbsp;
&nbsp;                                offsetMapping = current;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        this.offsetMappings.put(parameterDescription.getOffset(), offsetMapping == null ? new OffsetMapping.ForArgument.Unresolved(parameterDescription) : offsetMapping);
&nbsp;                    }
&nbsp;
&nbsp;                    this.suppressionHandler = Advice.Dispatcher.SuppressionHandler.Suppressing.of(throwableType);
&nbsp;                    this.relocationHandler = Advice.Dispatcher.RelocationHandler.ForType.of(relocatableType, relocatableIndex, adviceMethod.getReturnType());
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAlive() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.adviceMethod.equals(((AbstractBase)var1).adviceMethod)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.postProcessor.equals(((AbstractBase)var1).postProcessor)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.offsetMappings.equals(((AbstractBase)var1).offsetMappings)) {
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (!this.suppressionHandler.equals(((AbstractBase)var1).suppressionHandler)) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return this.relocationHandler.equals(((AbstractBase)var1).relocationHandler);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((this.getClass().hashCode() * 31 + this.adviceMethod.hashCode()) * 31 + this.postProcessor.hashCode()) * 31 + this.offsetMappings.hashCode()) * 31 + this.suppressionHandler.hashCode()) * 31 + this.relocationHandler.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface ForMethodEnter extends Resolved {
<b class="fc">&nbsp;                boolean isPrependLineNumber();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                TypeDefinition getActualAdviceType();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public interface ForMethodExit extends Resolved {
&nbsp;                TypeDescription getThrowable();
&nbsp;
&nbsp;                ArgumentHandler.Factory getArgumentHandlerFactory();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface SuppressionHandler {
&nbsp;            Bound bind(StackManipulation var1);
&nbsp;
<b class="nc">&nbsp;            public static enum NoOp implements SuppressionHandler, Bound {</b>
<b class="nc">&nbsp;                INSTANCE;</b>
<b class="nc">&nbsp;</b>
&nbsp;                private NoOp() {
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public Bound bind(StackManipulation exceptionHandler) {</b>
&nbsp;                    return this;
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public void onPrepare(MethodVisitor methodVisitor) {</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public void onStart(MethodVisitor methodVisitor) {</b>
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public void onEnd(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                public void onEndWithSkip(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Suppressing implements SuppressionHandler {
&nbsp;                private final TypeDescription suppressedType;
&nbsp;
<b class="fc">&nbsp;                protected Suppressing(TypeDescription suppressedType) {</b>
&nbsp;                    this.suppressedType = suppressedType;
&nbsp;                }
&nbsp;
&nbsp;                protected static SuppressionHandler of(TypeDescription suppressedType) {
<b class="fc">&nbsp;                    return (SuppressionHandler)(suppressedType.represents(NoExceptionHandler.class) ? Advice.Dispatcher.SuppressionHandler.NoOp.INSTANCE : new Suppressing(suppressedType));</b>
&nbsp;                }
&nbsp;
&nbsp;                public Bound bind(StackManipulation exceptionHandler) {
&nbsp;                    return new Bound(this.suppressedType, exceptionHandler);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.suppressedType.equals(((Suppressing)var1).suppressedType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.suppressedType.hashCode();
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected static class Bound implements Bound {</b>
<b class="fc">&nbsp;                    private final TypeDescription suppressedType;</b>
&nbsp;                    private final StackManipulation exceptionHandler;
&nbsp;                    private final Label startOfMethod;
&nbsp;                    private final Label endOfMethod;
&nbsp;
&nbsp;                    protected Bound(TypeDescription suppressedType, StackManipulation exceptionHandler) {
&nbsp;                        this.suppressedType = suppressedType;
<b class="fc">&nbsp;                        this.exceptionHandler = exceptionHandler;</b>
&nbsp;                        this.startOfMethod = new Label();
&nbsp;                        this.endOfMethod = new Label();
&nbsp;                    }
&nbsp;
&nbsp;                    public void onPrepare(MethodVisitor methodVisitor) {
&nbsp;                        methodVisitor.visitTryCatchBlock(this.startOfMethod, this.endOfMethod, this.endOfMethod, this.suppressedType.getInternalName());
&nbsp;                    }
&nbsp;
<b class="pc">&nbsp;                    public void onStart(MethodVisitor methodVisitor) {</b>
<b class="nc">&nbsp;                        methodVisitor.visitLabel(this.startOfMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public void onEnd(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
&nbsp;                        methodVisitor.visitLabel(this.endOfMethod);
&nbsp;                        stackMapFrameHandler.injectExceptionFrame(methodVisitor);
&nbsp;                        methodSizeHandler.requireStackSize(1 + this.exceptionHandler.apply(methodVisitor, implementationContext).getMaximalSize());
&nbsp;                        if (!returnType.represents(Boolean.TYPE) &amp;&amp; !returnType.represents(Byte.TYPE) &amp;&amp; !returnType.represents(Short.TYPE) &amp;&amp; !returnType.represents(Character.TYPE) &amp;&amp; !returnType.represents(Integer.TYPE)) {
&nbsp;                            if (returnType.represents(Long.TYPE)) {
&nbsp;                                methodVisitor.visitInsn(9);
&nbsp;                            } else if (returnType.represents(Float.TYPE)) {
&nbsp;                                methodVisitor.visitInsn(11);
&nbsp;                            } else if (returnType.represents(Double.TYPE)) {
&nbsp;                                methodVisitor.visitInsn(14);
&nbsp;                            } else if (!returnType.represents(Void.TYPE)) {
&nbsp;                                methodVisitor.visitInsn(1);
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitInsn(3);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    public void onEndWithSkip(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodSizeHandler.ForAdvice methodSizeHandler, StackMapFrameHandler.ForAdvice stackMapFrameHandler, TypeDefinition returnType) {
&nbsp;                        Label skipExceptionHandler = new Label();
&nbsp;                        methodVisitor.visitJumpInsn(167, skipExceptionHandler);
&nbsp;                        this.onEnd(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, returnType);
&nbsp;                        methodVisitor.visitLabel(skipExceptionHandler);
&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Bound {
&nbsp;                void onPrepare(MethodVisitor var1);
&nbsp;
&nbsp;                void onStart(MethodVisitor var1);
&nbsp;
&nbsp;                void onEnd(MethodVisitor var1, Implementation.Context var2, MethodSizeHandler.ForAdvice var3, StackMapFrameHandler.ForAdvice var4, TypeDefinition var5);
&nbsp;
&nbsp;                void onEndWithSkip(MethodVisitor var1, Implementation.Context var2, MethodSizeHandler.ForAdvice var3, StackMapFrameHandler.ForAdvice var4, TypeDefinition var5);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Unresolved extends Dispatcher {
&nbsp;            boolean isBinary();
&nbsp;
<b class="fc">&nbsp;            Map&lt;String, TypeDefinition&gt; getNamedTypes();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; var1, @MaybeNull AsmClassReader var2, Unresolved var3, PostProcessor.Factory var4);</b>
<b class="fc">&nbsp;</b>
&nbsp;            Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; var1, @MaybeNull AsmClassReader var2, Unresolved var3, PostProcessor.Factory var4);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected abstract static class AdviceVisitor extends ExceptionTableSensitiveMethodVisitor implements Dispatcher.RelocationHandler.Relocation {
&nbsp;        private static final int THIS_VARIABLE_INDEX = 0;
&nbsp;        private static final String THIS_VARIABLE_NAME = &quot;this&quot;;
&nbsp;        protected final MethodDescription instrumentedMethod;
&nbsp;        private final Label preparationStart;
&nbsp;        private final Dispatcher.Bound methodEnter;
&nbsp;        protected final Dispatcher.Bound methodExit;
&nbsp;        protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;
&nbsp;        protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
<b class="fc">&nbsp;        protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @SuppressFBWarnings(</b>
<b class="fc">&nbsp;            value = {&quot;MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR&quot;},</b>
<b class="fc">&nbsp;            justification = &quot;Self reference is not used before constructor completion.&quot;</b>
<b class="fc">&nbsp;        )</b>
&nbsp;        protected AdviceVisitor(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, List&lt;? extends TypeDescription&gt; postMethodTypes, int writerFlags, int readerFlags) {
&nbsp;            super(OpenedClassReader.ASM_API, methodVisitor);
&nbsp;            this.instrumentedMethod = instrumentedMethod;
&nbsp;            this.preparationStart = new Label();
&nbsp;            SortedMap&lt;String, TypeDefinition&gt; namedTypes = new TreeMap();
&nbsp;            namedTypes.putAll(methodEnter.getNamedTypes());
&nbsp;            namedTypes.putAll(methodExit.getNamedTypes());
&nbsp;            this.argumentHandler = methodExit.getArgumentHandlerFactory().resolve(instrumentedMethod, methodEnter.getAdviceType(), methodExit.getAdviceType(), namedTypes);
&nbsp;            List&lt;TypeDescription&gt; initialTypes = CompoundList.of(methodExit.getAdviceType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(methodExit.getAdviceType().asErasure()), this.argumentHandler.getNamedTypes());
&nbsp;            List&lt;TypeDescription&gt; latentTypes = methodEnter.getActualAdviceType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(methodEnter.getActualAdviceType().asErasure());
<b class="nc">&nbsp;            List&lt;TypeDescription&gt; preMethodTypes = methodEnter.getAdviceType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(methodEnter.getAdviceType().asErasure());</b>
<b class="nc">&nbsp;            this.methodSizeHandler = Advice.MethodSizeHandler.Default.of(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes, this.argumentHandler.isCopyingArguments(), writerFlags);</b>
&nbsp;            this.stackMapFrameHandler = Advice.StackMapFrameHandler.Default.of(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, methodExit.isAlive(), this.argumentHandler.isCopyingArguments(), implementationContext.getClassFileVersion(), writerFlags, readerFlags);
&nbsp;            this.methodEnter = methodEnter.bind(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, this.argumentHandler, this.methodSizeHandler, this.stackMapFrameHandler, exceptionHandler, this);
&nbsp;            this.methodExit = methodExit.bind(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, assigner, this.argumentHandler, this.methodSizeHandler, this.stackMapFrameHandler, exceptionHandler, new Dispatcher.RelocationHandler.Relocation.ForLabel(this.preparationStart));
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        protected void onAfterExceptionTable() {</b>
<b class="nc">&nbsp;            this.methodEnter.prepare();</b>
<b class="nc">&nbsp;            this.onUserPrepare();</b>
<b class="nc">&nbsp;            this.methodExit.prepare();</b>
&nbsp;            this.methodEnter.initialize();
<b class="nc">&nbsp;            this.methodExit.initialize();</b>
<b class="nc">&nbsp;            this.stackMapFrameHandler.injectInitializationFrame(this.mv);</b>
<b class="nc">&nbsp;            this.methodEnter.apply();</b>
&nbsp;            this.mv.visitLabel(this.preparationStart);
<b class="nc">&nbsp;            this.methodSizeHandler.requireStackSize(this.argumentHandler.prepare(this.mv));</b>
<b class="nc">&nbsp;            this.stackMapFrameHandler.injectStartFrame(this.mv);</b>
&nbsp;            this.mv.visitInsn(0);
&nbsp;            this.onUserStart();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected abstract void onUserPrepare();</b>
<b class="nc">&nbsp;</b>
&nbsp;        protected abstract void onUserStart();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected void onVisitVarInsn(int opcode, int offset) {</b>
&nbsp;            this.mv.visitVarInsn(opcode, this.argumentHandler.argument(offset));
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected void onVisitIincInsn(int offset, int increment) {</b>
&nbsp;            this.mv.visitIincInsn(this.argumentHandler.argument(offset), increment);
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public void onVisitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {</b>
<b class="nc">&nbsp;            this.stackMapFrameHandler.translateFrame(this.mv, type, localVariableLength, localVariable, stackSize, stack);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void visitMaxs(int stackSize, int localVariableLength) {</b>
&nbsp;            this.onUserEnd();
<b class="nc">&nbsp;            this.mv.visitMaxs(this.methodSizeHandler.compoundStackSize(stackSize), this.methodSizeHandler.compoundLocalVariableLength(localVariableLength));</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int offset) {
<b class="nc">&nbsp;            this.mv.visitLocalVariable(name, descriptor, signature, start, end, offset == 0 &amp;&amp; &quot;this&quot;.equals(name) ? offset : this.argumentHandler.argument(offset));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public AnnotationVisitor visitLocalVariableAnnotation(int typeReference, TypePath typePath, Label[] start, Label[] end, int[] offset, String descriptor, boolean visible) {</b>
&nbsp;            int[] translated = new int[offset.length];
<b class="nc">&nbsp;</b>
&nbsp;            for(int index = 0; index &lt; offset.length; ++index) {
<b class="nc">&nbsp;                translated[index] = this.argumentHandler.argument(offset[index]);</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            return this.mv.visitLocalVariableAnnotation(typeReference, typePath, start, end, translated, descriptor, visible);
&nbsp;        }
&nbsp;
&nbsp;        protected abstract void onUserEnd();
&nbsp;
&nbsp;        protected static class WithoutExitAdvice extends AdviceVisitor {
<b class="fc">&nbsp;            protected WithoutExitAdvice(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, int writerFlags, int readerFlags) {</b>
&nbsp;                super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, Advice.Dispatcher.Inactive.INSTANCE, Collections.emptyList(), writerFlags, readerFlags);
&nbsp;            }
&nbsp;
&nbsp;            public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {</b>
&nbsp;                    if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(9);
&nbsp;                        methodVisitor.visitInsn(173);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(11);
&nbsp;                        methodVisitor.visitInsn(174);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(14);
&nbsp;                        methodVisitor.visitInsn(175);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(177);
&nbsp;                    } else {
&nbsp;                        methodVisitor.visitInsn(1);
&nbsp;                        methodVisitor.visitInsn(176);
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    methodVisitor.visitInsn(3);
&nbsp;                    methodVisitor.visitInsn(172);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            protected void onUserPrepare() {
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            protected void onUserStart() {</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            protected void onUserEnd() {</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        protected abstract static class WithExitAdvice extends AdviceVisitor {
&nbsp;            protected final Label returnHandler = new Label();
&nbsp;
&nbsp;            protected WithExitAdvice(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, List&lt;? extends TypeDescription&gt; postMethodTypes, int writerFlags, int readerFlags) {
<b class="fc">&nbsp;                super(StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod), implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, postMethodTypes, writerFlags, readerFlags);</b>
&nbsp;            }
&nbsp;
&nbsp;            public void apply(MethodVisitor methodVisitor) {
&nbsp;                if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                    if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(9);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                        methodVisitor.visitInsn(11);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {
<b class="pc">&nbsp;                        methodVisitor.visitInsn(14);</b>
<b class="nc">&nbsp;                    } else if (!this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {</b>
<b class="pc">&nbsp;                        methodVisitor.visitInsn(1);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="pc">&nbsp;                    methodVisitor.visitInsn(3);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                methodVisitor.visitJumpInsn(167, this.returnHandler);
&nbsp;            }
&nbsp;
&nbsp;            protected void onVisitInsn(int opcode) {
&nbsp;                switch (opcode) {
&nbsp;                    case 172:
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(54, 21, StackSize.SINGLE));
&nbsp;                        break;
<b class="fc">&nbsp;                    case 173:</b>
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(55, 22, StackSize.DOUBLE));
&nbsp;                        break;
&nbsp;                    case 174:
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(56, 23, StackSize.SINGLE));
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case 175:
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(57, 24, StackSize.DOUBLE));
&nbsp;                        break;
&nbsp;                    case 176:
&nbsp;                        this.methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor)this.mv).drainStack(58, 25, StackSize.SINGLE));
&nbsp;                        break;
&nbsp;                    case 177:
&nbsp;                        ((StackAwareMethodVisitor)this.mv).drainStack();
&nbsp;                        break;
<b class="nc">&nbsp;                    default:</b>
&nbsp;                        this.mv.visitInsn(opcode);
&nbsp;                        return;
&nbsp;                }
&nbsp;
&nbsp;                this.mv.visitJumpInsn(167, this.returnHandler);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            protected void onUserEnd() {
&nbsp;                this.mv.visitLabel(this.returnHandler);
&nbsp;                this.onUserReturn();
&nbsp;                this.stackMapFrameHandler.injectCompletionFrame(this.mv);
<b class="fc">&nbsp;                this.methodExit.apply();</b>
&nbsp;                this.onExitAdviceReturn();
&nbsp;                if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {
<b class="nc">&nbsp;                    if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {</b>
&nbsp;                        this.mv.visitVarInsn(22, this.argumentHandler.returned());
&nbsp;                        this.mv.visitInsn(173);
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                        this.mv.visitVarInsn(23, this.argumentHandler.returned());
<b class="nc">&nbsp;                        this.mv.visitInsn(174);</b>
&nbsp;                    } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                        this.mv.visitVarInsn(24, this.argumentHandler.returned());
&nbsp;                        this.mv.visitInsn(175);
&nbsp;                    } else if (!this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                        this.mv.visitVarInsn(25, this.argumentHandler.returned());
&nbsp;                        this.mv.visitInsn(176);
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        this.mv.visitInsn(177);
&nbsp;                    }
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    this.mv.visitVarInsn(21, this.argumentHandler.returned());
&nbsp;                    this.mv.visitInsn(172);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                this.methodSizeHandler.requireStackSize(this.instrumentedMethod.getReturnType().getStackSize().getSize());</b>
&nbsp;            }
&nbsp;
&nbsp;            protected abstract void onUserReturn();
&nbsp;
&nbsp;            protected abstract void onExitAdviceReturn();
&nbsp;
<b class="fc">&nbsp;            protected static class WithoutExceptionHandling extends WithExitAdvice {</b>
&nbsp;                protected WithoutExceptionHandling(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags) {
&nbsp;                    super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, instrumentedMethod.getReturnType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(instrumentedMethod.getReturnType().asErasure()), writerFlags, readerFlags);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected void onUserPrepare() {
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                protected void onUserStart() {</b>
&nbsp;                }
&nbsp;
&nbsp;                protected void onUserReturn() {
&nbsp;                    if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                        if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.mv);
&nbsp;                            this.mv.visitVarInsn(55, this.argumentHandler.returned());
<b class="fc">&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {</b>
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.mv);
&nbsp;                            this.mv.visitVarInsn(56, this.argumentHandler.returned());
<b class="nc">&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {</b>
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.mv);
&nbsp;                            this.mv.visitVarInsn(57, this.argumentHandler.returned());
&nbsp;                        } else if (!this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            this.stackMapFrameHandler.injectReturnFrame(this.mv);
<b class="nc">&nbsp;                            this.mv.visitVarInsn(58, this.argumentHandler.returned());</b>
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        this.stackMapFrameHandler.injectReturnFrame(this.mv);
&nbsp;                        this.mv.visitVarInsn(54, this.argumentHandler.returned());
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected void onExitAdviceReturn() {
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithExceptionHandling extends WithExitAdvice {
&nbsp;                private final TypeDescription throwable;
<b class="nc">&nbsp;                private final Label exceptionHandler;</b>
&nbsp;                protected final Label userStart;
&nbsp;
&nbsp;                protected WithExceptionHandling(MethodVisitor methodVisitor, Implementation.Context implementationContext, Assigner assigner, StackManipulation exceptionHandler, TypeDescription instrumentedType, MethodDescription instrumentedMethod, Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit, int writerFlags, int readerFlags, TypeDescription throwable) {
&nbsp;                    super(methodVisitor, implementationContext, assigner, exceptionHandler, instrumentedType, instrumentedMethod, methodEnter, methodExit, instrumentedMethod.getReturnType().represents(Void.TYPE) ? Collections.singletonList(ForLoadedType.of(Throwable.class)) : Arrays.asList(instrumentedMethod.getReturnType().asErasure(), ForLoadedType.of(Throwable.class)), writerFlags, readerFlags);
&nbsp;                    this.throwable = throwable;
&nbsp;                    this.exceptionHandler = new Label();
&nbsp;                    this.userStart = new Label();
&nbsp;                }
&nbsp;
&nbsp;                protected void onUserPrepare() {
&nbsp;                    this.mv.visitTryCatchBlock(this.userStart, this.returnHandler, this.exceptionHandler, this.throwable.getInternalName());
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                protected void onUserStart() {
<b class="nc">&nbsp;                    this.mv.visitLabel(this.userStart);</b>
&nbsp;                }
&nbsp;
&nbsp;                protected void onUserReturn() {
&nbsp;                    this.stackMapFrameHandler.injectReturnFrame(this.mv);
&nbsp;                    if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                        if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                            this.mv.visitVarInsn(55, this.argumentHandler.returned());
&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                            this.mv.visitVarInsn(56, this.argumentHandler.returned());
&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                            this.mv.visitVarInsn(57, this.argumentHandler.returned());
&nbsp;                        } else if (!this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            this.mv.visitVarInsn(58, this.argumentHandler.returned());
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        this.mv.visitVarInsn(54, this.argumentHandler.returned());
&nbsp;                    }
&nbsp;
&nbsp;                    this.mv.visitInsn(1);
&nbsp;                    this.mv.visitVarInsn(58, this.argumentHandler.thrown());
&nbsp;                    Label endOfHandler = new Label();
&nbsp;                    this.mv.visitJumpInsn(167, endOfHandler);
&nbsp;                    this.mv.visitLabel(this.exceptionHandler);
<b class="nc">&nbsp;                    this.stackMapFrameHandler.injectExceptionFrame(this.mv);</b>
&nbsp;                    this.mv.visitVarInsn(58, this.argumentHandler.thrown());
&nbsp;                    if (!this.instrumentedMethod.getReturnType().represents(Boolean.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Byte.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Short.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Character.TYPE) &amp;&amp; !this.instrumentedMethod.getReturnType().represents(Integer.TYPE)) {
&nbsp;                        if (this.instrumentedMethod.getReturnType().represents(Long.TYPE)) {
&nbsp;                            this.mv.visitInsn(9);
&nbsp;                            this.mv.visitVarInsn(55, this.argumentHandler.returned());
&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Float.TYPE)) {
&nbsp;                            this.mv.visitInsn(11);
&nbsp;                            this.mv.visitVarInsn(56, this.argumentHandler.returned());
&nbsp;                        } else if (this.instrumentedMethod.getReturnType().represents(Double.TYPE)) {
&nbsp;                            this.mv.visitInsn(14);
&nbsp;                            this.mv.visitVarInsn(57, this.argumentHandler.returned());
&nbsp;                        } else if (!this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            this.mv.visitInsn(1);
&nbsp;                            this.mv.visitVarInsn(58, this.argumentHandler.returned());
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        this.mv.visitInsn(3);
&nbsp;                        this.mv.visitVarInsn(54, this.argumentHandler.returned());
&nbsp;                    }
&nbsp;
&nbsp;                    this.mv.visitLabel(endOfHandler);
&nbsp;                    this.methodSizeHandler.requireStackSize(StackSize.SINGLE.getSize());
&nbsp;                }
&nbsp;
&nbsp;                protected void onExitAdviceReturn() {
<b class="nc">&nbsp;                    this.mv.visitVarInsn(25, this.argumentHandler.thrown());</b>
<b class="nc">&nbsp;                    Label endOfHandler = new Label();</b>
<b class="nc">&nbsp;                    this.mv.visitJumpInsn(198, endOfHandler);</b>
<b class="nc">&nbsp;                    this.mv.visitVarInsn(25, this.argumentHandler.thrown());</b>
<b class="nc">&nbsp;                    this.mv.visitInsn(191);</b>
&nbsp;                    this.mv.visitLabel(endOfHandler);
&nbsp;                    this.stackMapFrameHandler.injectPostCompletionFrame(this.mv);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;        private final Advice advice;
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;        private final ByteCodeAppender delegate;
&nbsp;
&nbsp;        protected Appender(Advice advice, Implementation.Target implementationTarget, ByteCodeAppender delegate) {
&nbsp;            this.advice = advice;
&nbsp;            this.implementationTarget = implementationTarget;
&nbsp;            this.delegate = delegate;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;            EmulatingMethodVisitor emulatingMethodVisitor = new EmulatingMethodVisitor(methodVisitor, this.delegate);
&nbsp;            methodVisitor = this.advice.doWrap(this.implementationTarget.getInstrumentedType(), instrumentedMethod, emulatingMethodVisitor, implementationContext, 0, 0);
&nbsp;            return emulatingMethodVisitor.resolve(methodVisitor, implementationContext, instrumentedMethod);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;            if (this == var1) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.advice.equals(((Appender)var1).advice)) {
&nbsp;                return false;
&nbsp;            } else if (!this.implementationTarget.equals(((Appender)var1).implementationTarget)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.delegate.equals(((Appender)var1).delegate);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return ((this.getClass().hashCode() * 31 + this.advice.hashCode()) * 31 + this.implementationTarget.hashCode()) * 31 + this.delegate.hashCode();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        protected static class EmulatingMethodVisitor extends MethodVisitor {
<b class="nc">&nbsp;            private final ByteCodeAppender delegate;</b>
<b class="nc">&nbsp;            private int stackSize;</b>
<b class="nc">&nbsp;            private int localVariableLength;</b>
&nbsp;
<b class="nc">&nbsp;            protected EmulatingMethodVisitor(MethodVisitor methodVisitor, ByteCodeAppender delegate) {</b>
&nbsp;                super(OpenedClassReader.ASM_API, methodVisitor);
&nbsp;                this.delegate = delegate;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected ByteCodeAppender.Size resolve(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {</b>
<b class="nc">&nbsp;                methodVisitor.visitCode();</b>
<b class="nc">&nbsp;                ByteCodeAppender.Size size = this.delegate.apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;                methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
<b class="nc">&nbsp;                methodVisitor.visitEnd();</b>
<b class="nc">&nbsp;                return new ByteCodeAppender.Size(this.stackSize, this.localVariableLength);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            public void visitCode() {</b>
&nbsp;            }
&nbsp;
&nbsp;            public void visitMaxs(int stackSize, int localVariableLength) {
&nbsp;                this.stackSize = stackSize;
&nbsp;                this.localVariableLength = localVariableLength;
&nbsp;            }
&nbsp;
&nbsp;            public void visitEnd() {
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public abstract static class AssignReturned implements PostProcessor {
&nbsp;        public static final int NO_INDEX = -1;
&nbsp;        protected final TypeDescription.Generic type;
&nbsp;        protected final ExceptionHandler.Factory exceptionHandlerFactory;
&nbsp;        protected final boolean exit;
&nbsp;        protected final boolean skipOnDefaultValue;
&nbsp;
&nbsp;        protected AssignReturned(TypeDescription.Generic type, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue) {
&nbsp;            this.type = type;
&nbsp;            this.exceptionHandlerFactory = exceptionHandlerFactory;
&nbsp;            this.exit = exit;
&nbsp;            this.skipOnDefaultValue = skipOnDefaultValue;
&nbsp;        }
&nbsp;
&nbsp;        public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
&nbsp;            List&lt;StackManipulation&gt; stackManipulations = new ArrayList(this.getHandlers().size());
&nbsp;
&nbsp;            for(Handler handler : this.getHandlers()) {
&nbsp;                stackManipulations.add(handler.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, this.getType(), this.toLoadInstruction(handler, this.exit ? argumentHandler.exit() : argumentHandler.enter())));
&nbsp;            }
&nbsp;
&nbsp;            StackManipulation stackManipulation = this.exceptionHandlerFactory.wrap(new StackManipulation.Compound(stackManipulations), exceptionHandler, stackMapFrameHandler);
&nbsp;            return this.skipOnDefaultValue ? Advice.AssignReturned.DefaultValueSkip.of(stackManipulation, stackMapFrameHandler, this.exit ? argumentHandler.exit() : argumentHandler.enter(), this.type) : stackManipulation;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        protected abstract TypeDescription.Generic getType();</b>
<b class="nc">&nbsp;</b>
&nbsp;        protected abstract Collection&lt;Handler&gt; getHandlers();
&nbsp;
&nbsp;        protected abstract StackManipulation toLoadInstruction(Handler var1, int var2);
&nbsp;
<b class="nc">&nbsp;        public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;            if (this == var1) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (var1 == null) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                return false;
<b class="nc">&nbsp;            } else if (this.exit != ((AssignReturned)var1).exit) {</b>
&nbsp;                return false;
&nbsp;            } else if (this.skipOnDefaultValue != ((AssignReturned)var1).skipOnDefaultValue) {
&nbsp;                return false;
&nbsp;            } else if (!this.type.equals(((AssignReturned)var1).type)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.exceptionHandlerFactory.equals(((AssignReturned)var1).exceptionHandlerFactory);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (((this.getClass().hashCode() * 31 + this.type.hashCode()) * 31 + this.exceptionHandlerFactory.hashCode()) * 31 + this.exit) * 31 + this.skipOnDefaultValue;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ForArray extends AssignReturned {
&nbsp;            private final Map&lt;Handler, Integer&gt; handlers = new LinkedHashMap();
&nbsp;
&nbsp;            protected ForArray(TypeDescription.Generic type, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, Collection&lt;List&lt;Handler&gt;&gt; handlers) {
&nbsp;                super(type, exceptionHandlerFactory, exit, true);
&nbsp;
&nbsp;                for(List&lt;Handler&gt; collection : handlers) {
&nbsp;                    for(Handler handler : collection) {
<b class="nc">&nbsp;                        int index = handler.getIndex();</b>
<b class="nc">&nbsp;                        if (index &lt;= -1) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Handler on array requires positive index for &quot; + handler);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        this.handlers.put(handler, index);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
<b class="nc">&nbsp;            protected TypeDescription.Generic getType() {</b>
&nbsp;                return this.type.getComponentType();
&nbsp;            }
&nbsp;
&nbsp;            protected Collection&lt;Handler&gt; getHandlers() {
<b class="nc">&nbsp;                return this.handlers.keySet();</b>
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
&nbsp;                return new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.REFERENCE.loadFrom(offset), IntegerConstant.forValue((Integer)this.handlers.get(handler)), ArrayAccess.of(this.type.getComponentType()).load()});
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.handlers.equals(((ForArray)var1).handlers);
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public int hashCode() {</b>
<b class="nc">&nbsp;                return super.hashCode() * 31 + this.handlers.hashCode();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ForScalar extends AssignReturned {
&nbsp;            private final List&lt;Handler&gt; handlers = new ArrayList();
&nbsp;
&nbsp;            protected ForScalar(TypeDescription.Generic type, ExceptionHandler.Factory exceptionHandlerFactory, boolean exit, boolean skipOnDefaultValue, Collection&lt;List&lt;Handler&gt;&gt; handlers) {
&nbsp;                super(type, exceptionHandlerFactory, exit, skipOnDefaultValue);
&nbsp;
&nbsp;                for(List&lt;Handler&gt; collection : handlers) {
&nbsp;                    for(Handler handler : collection) {
&nbsp;                        int index = handler.getIndex();
&nbsp;                        if (index &gt; -1) {
&nbsp;                            throw new IllegalStateException(&quot;Handler on array requires negative index for &quot; + handler);
&nbsp;                        }
&nbsp;
&nbsp;                        this.handlers.add(handler);
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;            }
&nbsp;
&nbsp;            protected TypeDescription.Generic getType() {
&nbsp;                return this.type;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            protected Collection&lt;Handler&gt; getHandlers() {
<b class="nc">&nbsp;                return this.handlers;</b>
&nbsp;            }
&nbsp;
&nbsp;            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
&nbsp;                return MethodVariableAccess.of(this.type).loadFrom(offset);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                if (!super.equals(var1)) {
&nbsp;                    return false;
&nbsp;                } else if (this == var1) {
&nbsp;                    return true;
<b class="fc">&nbsp;                } else if (var1 == null) {</b>
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.handlers.equals(((ForScalar)var1).handlers);
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return super.hashCode() * 31 + this.handlers.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
<b class="nc">&nbsp;        protected static class DefaultValueSkip implements StackManipulation {</b>
<b class="nc">&nbsp;            private final StackManipulation stackManipulation;</b>
&nbsp;            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
<b class="nc">&nbsp;            private final int offset;</b>
<b class="nc">&nbsp;            private final Dispatcher dispatcher;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected DefaultValueSkip(StackManipulation stackManipulation, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, Dispatcher dispatcher) {</b>
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;                this.stackMapFrameHandler = stackMapFrameHandler;
&nbsp;                this.offset = offset;
&nbsp;                this.dispatcher = dispatcher;
&nbsp;            }
&nbsp;
&nbsp;            protected static StackManipulation of(StackManipulation stackManipulation, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, int offset, TypeDefinition typeDefinition) {
&nbsp;                Dispatcher dispatcher;
&nbsp;                if (typeDefinition.isPrimitive()) {
&nbsp;                    if (!typeDefinition.represents(Boolean.TYPE) &amp;&amp; !typeDefinition.represents(Byte.TYPE) &amp;&amp; !typeDefinition.represents(Short.TYPE) &amp;&amp; !typeDefinition.represents(Character.TYPE) &amp;&amp; !typeDefinition.represents(Integer.TYPE)) {
&nbsp;                        if (typeDefinition.represents(Long.TYPE)) {
&nbsp;                            dispatcher = Advice.AssignReturned.DefaultValueSkip.Dispatcher.LONG;
&nbsp;                        } else if (typeDefinition.represents(Float.TYPE)) {
&nbsp;                            dispatcher = Advice.AssignReturned.DefaultValueSkip.Dispatcher.FLOAT;
&nbsp;                        } else {
&nbsp;                            if (!typeDefinition.represents(Double.TYPE)) {
&nbsp;                                throw new IllegalArgumentException(&quot;Cannot apply skip for &quot; + typeDefinition);
&nbsp;                            }
&nbsp;
&nbsp;                            dispatcher = Advice.AssignReturned.DefaultValueSkip.Dispatcher.DOUBLE;
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        dispatcher = Advice.AssignReturned.DefaultValueSkip.Dispatcher.INTEGER;
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    dispatcher = Advice.AssignReturned.DefaultValueSkip.Dispatcher.REFERENCE;
&nbsp;                }
&nbsp;
&nbsp;                return new DefaultValueSkip(stackManipulation, stackMapFrameHandler, offset, dispatcher);
&nbsp;            }
&nbsp;
&nbsp;            public boolean isValid() {
&nbsp;                return this.stackManipulation.isValid();
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                Label label = new Label();
&nbsp;                StackManipulation.Size size = this.dispatcher.apply(methodVisitor, this.offset, label).aggregate(this.stackManipulation.apply(methodVisitor, implementationContext));
&nbsp;                methodVisitor.visitInsn(0);
&nbsp;                methodVisitor.visitLabel(label);
&nbsp;                this.stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.emptyList());
&nbsp;                methodVisitor.visitInsn(0);
&nbsp;                return size;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.offset != ((DefaultValueSkip)var1).offset) {
&nbsp;                    return false;
&nbsp;                } else if (!this.dispatcher.equals(((DefaultValueSkip)var1).dispatcher)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.stackManipulation.equals(((DefaultValueSkip)var1).stackManipulation)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.stackMapFrameHandler.equals(((DefaultValueSkip)var1).stackMapFrameHandler);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.stackManipulation.hashCode()) * 31 + this.stackMapFrameHandler.hashCode()) * 31 + this.offset) * 31 + this.dispatcher.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Dispatcher {
&nbsp;                INTEGER {
&nbsp;                    protected StackManipulation.Size apply(MethodVisitor methodVisitor, int offset, Label label) {
&nbsp;                        methodVisitor.visitVarInsn(21, offset);
&nbsp;                        methodVisitor.visitJumpInsn(153, label);
&nbsp;                        return new StackManipulation.Size(0, 1);
&nbsp;                    }
&nbsp;                },
&nbsp;                LONG {
&nbsp;                    protected StackManipulation.Size apply(MethodVisitor methodVisitor, int offset, Label label) {
&nbsp;                        methodVisitor.visitVarInsn(22, offset);
&nbsp;                        methodVisitor.visitInsn(9);
&nbsp;                        methodVisitor.visitInsn(148);
&nbsp;                        methodVisitor.visitJumpInsn(153, label);
&nbsp;                        return new StackManipulation.Size(0, 4);
&nbsp;                    }
&nbsp;                },
&nbsp;                FLOAT {
&nbsp;                    protected StackManipulation.Size apply(MethodVisitor methodVisitor, int offset, Label label) {
&nbsp;                        methodVisitor.visitVarInsn(23, offset);
&nbsp;                        methodVisitor.visitInsn(11);
&nbsp;                        methodVisitor.visitInsn(149);
&nbsp;                        methodVisitor.visitJumpInsn(153, label);
&nbsp;                        return new StackManipulation.Size(0, 2);
&nbsp;                    }
&nbsp;                },
&nbsp;                DOUBLE {
&nbsp;                    protected StackManipulation.Size apply(MethodVisitor methodVisitor, int offset, Label label) {
&nbsp;                        methodVisitor.visitVarInsn(24, offset);
&nbsp;                        methodVisitor.visitInsn(14);
&nbsp;                        methodVisitor.visitInsn(151);
&nbsp;                        methodVisitor.visitJumpInsn(153, label);
&nbsp;                        return new StackManipulation.Size(0, 4);
&nbsp;                    }
&nbsp;                },
&nbsp;                REFERENCE {
&nbsp;                    protected StackManipulation.Size apply(MethodVisitor methodVisitor, int offset, Label label) {
&nbsp;                        methodVisitor.visitVarInsn(25, offset);
&nbsp;                        methodVisitor.visitJumpInsn(198, label);
&nbsp;                        return new StackManipulation.Size(0, 2);
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private Dispatcher() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract StackManipulation.Size apply(MethodVisitor var1, int var2, Label var3);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ExceptionHandler implements StackManipulation {
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;            private final StackManipulation exceptionHandler;
&nbsp;            private final TypeDescription exceptionType;
&nbsp;            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
&nbsp;
&nbsp;            protected ExceptionHandler(StackManipulation stackManipulation, StackManipulation exceptionHandler, TypeDescription exceptionType, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;                this.exceptionHandler = exceptionHandler;
&nbsp;                this.exceptionType = exceptionType;
<b class="nc">&nbsp;                this.stackMapFrameHandler = stackMapFrameHandler;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean isValid() {
&nbsp;                return this.stackManipulation.isValid() &amp;&amp; this.exceptionHandler.isValid();
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
&nbsp;                Label start = new Label();
&nbsp;                Label handler = new Label();
&nbsp;                Label end = new Label();
&nbsp;                methodVisitor.visitTryCatchBlock(start, handler, handler, this.exceptionType.getInternalName());
<b class="nc">&nbsp;                methodVisitor.visitLabel(start);</b>
<b class="nc">&nbsp;                StackManipulation.Size size = this.stackManipulation.apply(methodVisitor, implementationContext);</b>
<b class="nc">&nbsp;                methodVisitor.visitJumpInsn(167, end);</b>
&nbsp;                methodVisitor.visitLabel(handler);
<b class="nc">&nbsp;                this.stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.singletonList(this.exceptionType));</b>
<b class="nc">&nbsp;                size = this.exceptionHandler.apply(methodVisitor, implementationContext).aggregate(size);</b>
<b class="nc">&nbsp;                methodVisitor.visitLabel(end);</b>
<b class="nc">&nbsp;                this.stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.emptyList());</b>
&nbsp;                return size;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;                if (this == var1) {</b>
&nbsp;                    return true;
<b class="nc">&nbsp;                } else if (var1 == null) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.stackManipulation.equals(((ExceptionHandler)var1).stackManipulation)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.exceptionHandler.equals(((ExceptionHandler)var1).exceptionHandler)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.exceptionType.equals(((ExceptionHandler)var1).exceptionType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.stackMapFrameHandler.equals(((ExceptionHandler)var1).stackMapFrameHandler);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.stackManipulation.hashCode()) * 31 + this.exceptionHandler.hashCode()) * 31 + this.exceptionType.hashCode()) * 31 + this.stackMapFrameHandler.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public interface Factory {
&nbsp;                StackManipulation wrap(StackManipulation var1, StackManipulation var2, StackMapFrameHandler.ForPostProcessor var3);
&nbsp;
&nbsp;                public static enum NoOp implements Factory {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private NoOp() {
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation wrap(StackManipulation stackManipulation, StackManipulation exceptionHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
&nbsp;                        return stackManipulation;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Enabled implements Factory {
&nbsp;                    private final TypeDescription exceptionType;
&nbsp;
&nbsp;                    protected Enabled(TypeDescription exceptionType) {
&nbsp;                        this.exceptionType = exceptionType;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation wrap(StackManipulation stackManipulation, StackManipulation exceptionHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
&nbsp;                        return new ExceptionHandler(stackManipulation, exceptionHandler, this.exceptionType, stackMapFrameHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.exceptionType.equals(((Enabled)var1).exceptionType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.exceptionType.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Factory implements PostProcessor.Factory {
&nbsp;            private static final MethodDescription.InDefinedShape SKIP_ON_DEFAULT_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(AsScalar.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;skipOnDefaultValue&quot;))).getOnly();
&nbsp;            private final List&lt;? extends Handler.Factory&lt;?&gt;&gt; factories;
&nbsp;            private final ExceptionHandler.Factory exceptionHandlerFactory;
&nbsp;
&nbsp;            public Factory() {
<b class="nc">&nbsp;                this(Arrays.asList(Advice.AssignReturned.ToArguments.Handler.Factory.INSTANCE, Advice.AssignReturned.ToAllArguments.Handler.Factory.INSTANCE, Advice.AssignReturned.ToThis.Handler.Factory.INSTANCE, Advice.AssignReturned.ToFields.Handler.Factory.INSTANCE, Advice.AssignReturned.ToReturned.Handler.Factory.INSTANCE, Advice.AssignReturned.ToThrown.Handler.Factory.INSTANCE), Advice.AssignReturned.ExceptionHandler.Factory.NoOp.INSTANCE);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            protected Factory(List&lt;? extends Handler.Factory&lt;?&gt;&gt; factories, ExceptionHandler.Factory exceptionHandlerFactory) {
&nbsp;                this.factories = factories;
&nbsp;                this.exceptionHandlerFactory = exceptionHandlerFactory;
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Factory with(Class&lt;? extends Annotation&gt; type, Handler... handler) {</b>
<b class="nc">&nbsp;                return this.with(type, Arrays.asList(handler));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Factory with(Class&lt;? extends Annotation&gt; type, List&lt;Handler&gt; handlers) {
<b class="nc">&nbsp;                return this.with(new Handler.Factory.Simple(type, handlers));</b>
&nbsp;            }
&nbsp;
&nbsp;            public Factory with(Handler.Factory&lt;?&gt; factory) {
&nbsp;                return new Factory(CompoundList.of(this.factories, factory), this.exceptionHandlerFactory);
&nbsp;            }
&nbsp;
&nbsp;            public PostProcessor.Factory withSuppressed(Class&lt;? extends Throwable&gt; exceptionType) {
&nbsp;                return this.withSuppressed(ForLoadedType.of(exceptionType));
&nbsp;            }
&nbsp;
&nbsp;            public PostProcessor.Factory withSuppressed(TypeDescription exceptionType) {
&nbsp;                if (!exceptionType.isAssignableTo(Throwable.class)) {
&nbsp;                    throw new IllegalArgumentException(exceptionType + &quot; is not a throwable type&quot;);
&nbsp;                } else {
&nbsp;                    return new Factory(this.factories, new ExceptionHandler.Factory.Enabled(exceptionType));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
&nbsp;                if (advice.getReturnType().represents(Void.TYPE)) {
&nbsp;                    return Advice.PostProcessor.NoOp.INSTANCE;
&nbsp;                } else {
&nbsp;                    Map&lt;String, Handler.Factory&lt;?&gt;&gt; factories = new HashMap();
<b class="nc">&nbsp;</b>
&nbsp;                    for(Handler.Factory&lt;?&gt; factory : this.factories) {
&nbsp;                        if (factories.put(factory.getAnnotationType().getName(), factory) != null) {
&nbsp;                            throw new IllegalStateException(&quot;Duplicate registration of handler for &quot; + factory.getAnnotationType());
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    Map&lt;Class&lt;?&gt;, List&lt;Handler&gt;&gt; handlers = new LinkedHashMap();
&nbsp;                    boolean scalar = false;
&nbsp;                    boolean skipOnDefaultValue = true;
&nbsp;
&nbsp;                    for(AnnotationDescription annotation : advice.getDeclaredAnnotations()) {
&nbsp;                        if (annotation.getAnnotationType().represents(AsScalar.class)) {
&nbsp;                            scalar = true;
&nbsp;                            skipOnDefaultValue = (Boolean)annotation.getValue(SKIP_ON_DEFAULT_VALUE).resolve(Boolean.class);
&nbsp;                        } else {
&nbsp;                            Handler.Factory&lt;?&gt; factory = (Handler.Factory)factories.get(annotation.getAnnotationType().getName());
&nbsp;                            if (factory != null &amp;&amp; handlers.put(factory.getAnnotationType(), factory.make(advice, exit, annotation.prepare(factory.getAnnotationType()))) != null) {
&nbsp;                                throw new IllegalStateException(&quot;Duplicate handler registration for &quot; + annotation.getAnnotationType());
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    if (handlers.isEmpty()) {
&nbsp;                        return Advice.PostProcessor.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        return (PostProcessor)(!scalar &amp;&amp; advice.getReturnType().isArray() ? new ForArray(advice.getReturnType(), this.exceptionHandlerFactory, exit, handlers.values()) : new ForScalar(advice.getReturnType(), this.exceptionHandlerFactory, exit, skipOnDefaultValue, handlers.values()));
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
<b class="nc">&nbsp;                } else if (var1 == null) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.getClass() != var1.getClass()) {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                } else if (!this.factories.equals(((Factory)var1).factories)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.exceptionHandlerFactory.equals(((Factory)var1).exceptionHandlerFactory);
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.factories.hashCode()) * 31 + this.exceptionHandlerFactory.hashCode();
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface AsScalar {
&nbsp;            boolean skipOnDefaultValue() default true;
&nbsp;        }
&nbsp;
&nbsp;        public interface Handler {
&nbsp;            int getIndex();
&nbsp;
&nbsp;            StackManipulation resolve(TypeDescription var1, MethodDescription var2, Assigner var3, ArgumentHandler var4, TypeDescription.Generic var5, StackManipulation var6);
&nbsp;
&nbsp;            public interface Factory&lt;T extends Annotation&gt; {
&nbsp;                Class&lt;T&gt; getAnnotationType();
&nbsp;
<b class="fc">&nbsp;                List&lt;Handler&gt; make(MethodDescription.InDefinedShape var1, boolean var2, AnnotationDescription.Loadable&lt;? extends T&gt; var3);</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                @Enhance</b>
&nbsp;                public static class Simple&lt;S extends Annotation&gt; implements Factory&lt;S&gt; {
&nbsp;                    private final Class&lt;S&gt; type;
&nbsp;                    private final List&lt;Handler&gt; handlers;
&nbsp;
&nbsp;                    public Simple(Class&lt;S&gt; type, List&lt;Handler&gt; handlers) {
&nbsp;                        this.type = type;
<b class="fc">&nbsp;                        this.handlers = handlers;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;S&gt; getAnnotationType() {
&nbsp;                        return this.type;
&nbsp;                    }
&nbsp;
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends S&gt; annotation) {
&nbsp;                        return this.handlers;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
<b class="nc">&nbsp;                        if (this == var1) {</b>
<b class="nc">&nbsp;                            return true;</b>
<b class="nc">&nbsp;                        } else if (var1 == null) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.type.equals(((Simple)var1).type)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.handlers.equals(((Simple)var1).handlers);
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.type.hashCode()) * 31 + this.handlers.hashCode();
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToAllArguments {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int index;
<b class="fc">&nbsp;                private final Assigner.Typing typing;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected Handler(int index, Assigner.Typing typing) {</b>
&nbsp;                    this.index = index;
&nbsp;                    this.typing = typing;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList(instrumentedMethod.getParameters().size());
&nbsp;                    if (!type.isArray()) {
<b class="nc">&nbsp;                        StackManipulation assignment = assigner.assign(type, net.bytebuddy.description.type.TypeDefinition.Sort.describe(Object[].class), this.typing);</b>
<b class="nc">&nbsp;                        if (!assignment.isValid()) {</b>
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + Object[].class);
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                        type = net.bytebuddy.description.type.TypeDefinition.Sort.describe(Object[].class);</b>
<b class="nc">&nbsp;                        value = new StackManipulation.Compound(new StackManipulation[]{value, assignment});</b>
&nbsp;                    }
&nbsp;
&nbsp;                    for(ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
&nbsp;                        StackManipulation assignment = assigner.assign(type.getComponentType(), parameterDescription.getType(), this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type.getComponentType() + &quot; to &quot; + parameterDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        stackManipulations.add(new StackManipulation.Compound(new StackManipulation[]{assignment, MethodVariableAccess.of(parameterDescription.getType()).storeAt(argumentHandler.argument(parameterDescription.getOffset()))}));
&nbsp;                    }
&nbsp;
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{value, ArrayAccess.of(type.getComponentType()).forEach(stackManipulations), Removal.SINGLE});
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typing.equals(((Handler)var1).typing);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.index) * 31 + this.typing.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static enum Factory implements Handler.Factory&lt;ToAllArguments&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_INDEX;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_TYPING;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;ToAllArguments&gt; getAnnotationType() {
&nbsp;                        return ToAllArguments.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToAllArguments&gt; annotation) {
&nbsp;                        return Collections.singletonList(new Handler((Integer)annotation.getValue(TO_ALL_ARGUMENTS_INDEX).resolve(Integer.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(TO_ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class)));
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToAllArguments.class).getDeclaredMethods();
&nbsp;                        TO_ALL_ARGUMENTS_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
&nbsp;                        TO_ALL_ARGUMENTS_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToArguments {
&nbsp;            ToArgument[] value();
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int value;
&nbsp;                private final int index;
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int value, int index, Assigner.Typing typing) {
&nbsp;                    this.value = value;
&nbsp;                    this.index = index;
&nbsp;                    this.typing = typing;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    if (instrumentedMethod.getParameters().size() &lt; this.value) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; declares less then &quot; + this.value + &quot; parameters&quot;);
&nbsp;                    } else {
&nbsp;                        StackManipulation assignment = assigner.assign(type, ((ParameterDescription)instrumentedMethod.getParameters().get(this.value)).getType(), this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + ((ParameterDescription)instrumentedMethod.getParameters().get(this.value)).getType());
&nbsp;                        } else {
&nbsp;                            return new StackManipulation.Compound(new StackManipulation[]{value, assignment, MethodVariableAccess.of(((ParameterDescription)instrumentedMethod.getParameters().get(this.value)).getType()).storeAt(argumentHandler.argument(((ParameterDescription)instrumentedMethod.getParameters().get(this.value)).getOffset()))});
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.value != ((Handler)var1).value) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typing.equals(((Handler)var1).typing);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.value) * 31 + this.index) * 31 + this.typing.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static enum Factory implements Handler.Factory&lt;ToArguments&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENTS_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(ToArguments.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_VALUE;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_INDEX;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_TYPING;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;ToArguments&gt; getAnnotationType() {
&nbsp;                        return ToArguments.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToArguments&gt; annotation) {
&nbsp;                        List&lt;Handler&gt; handlers = new ArrayList();
&nbsp;
&nbsp;                        for(AnnotationDescription argument : (AnnotationDescription[])annotation.getValue(TO_ARGUMENTS_VALUE).resolve(AnnotationDescription[].class)) {
&nbsp;                            int value = (Integer)argument.getValue(TO_ARGUMENT_VALUE).resolve(Integer.class);
&nbsp;                            if (value &lt; 0) {
&nbsp;                                throw new IllegalStateException(&quot;An argument cannot have a negative index for &quot; + advice);
&nbsp;                            }
&nbsp;
&nbsp;                            handlers.add(new Handler(value, (Integer)argument.getValue(TO_ARGUMENT_INDEX).resolve(Integer.class), (Assigner.Typing)((EnumerationDescription)argument.getValue(TO_ARGUMENT_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class)));
&nbsp;                        }
&nbsp;
&nbsp;                        return handlers;
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToArgument.class).getDeclaredMethods();
&nbsp;                        TO_ARGUMENT_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                        TO_ARGUMENT_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
&nbsp;                        TO_ARGUMENT_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @java.lang.annotation.Target({})
&nbsp;            @net.bytebuddy.build.RepeatedAnnotationPlugin.Enhance(ToArguments.class)
&nbsp;            @Repeatable(ToArguments.class)
&nbsp;            public @interface ToArgument {
&nbsp;                int value();
&nbsp;
&nbsp;                int index() default -1;
&nbsp;
&nbsp;                Assigner.Typing typing() default Typing.STATIC;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToFields {
&nbsp;            ToField[] value();
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int index;
&nbsp;                private final String name;
&nbsp;                private final TypeDescription declaringType;
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int index, String name, TypeDescription declaringType, Assigner.Typing typing) {
&nbsp;                    this.index = index;
&nbsp;                    this.name = name;
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.typing = typing;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    FieldLocator locator = (FieldLocator)(this.declaringType.represents(Void.TYPE) ? new FieldLocator.ForClassHierarchy(instrumentedType) : new FieldLocator.ForExactType(this.declaringType));
&nbsp;                    FieldLocator.Resolution resolution = this.name.equals(&quot;&quot;) ? net.bytebuddy.dynamic.scaffold.FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(this.name);
&nbsp;                    if (!resolution.isResolved()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve field &quot; + this.name + &quot; for &quot; + instrumentedType);
&nbsp;                    } else if (!resolution.getField().isVisibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(resolution.getField() + &quot; is not visible to &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        StackManipulation stackManipulation;
&nbsp;                        if (resolution.getField().isStatic()) {
&nbsp;                            stackManipulation = net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;                        } else {
&nbsp;                            if (instrumentedMethod.isStatic()) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot access member field &quot; + resolution.getField() + &quot; from static &quot; + instrumentedMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            if (!instrumentedType.isAssignableTo(resolution.getField().getDeclaringType().asErasure())) {
&nbsp;                                throw new IllegalStateException(instrumentedType + &quot; does not define &quot; + resolution.getField());
&nbsp;                            }
&nbsp;
&nbsp;                            stackManipulation = MethodVariableAccess.loadThis();
&nbsp;                        }
&nbsp;
&nbsp;                        StackManipulation assignment = assigner.assign(type, resolution.getField().getType(), this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + resolution.getField());
&nbsp;                        } else {
&nbsp;                            return new StackManipulation.Compound(new StackManipulation[]{stackManipulation, value, assignment, FieldAccess.forField(resolution.getField()).write()});
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typing.equals(((Handler)var1).typing)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.name.equals(((Handler)var1).name)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.declaringType.equals(((Handler)var1).declaringType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (((this.getClass().hashCode() * 31 + this.index) * 31 + this.name.hashCode()) * 31 + this.declaringType.hashCode()) * 31 + this.typing.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static enum Factory implements Handler.Factory&lt;ToFields&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELDS_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(ToFields.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_VALUE;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_INDEX;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_DECLARING_TYPE;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_TYPING;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;ToFields&gt; getAnnotationType() {
&nbsp;                        return ToFields.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToFields&gt; annotation) {
&nbsp;                        List&lt;Handler&gt; handlers = new ArrayList();
&nbsp;
&nbsp;                        for(AnnotationDescription field : (AnnotationDescription[])annotation.getValue(TO_FIELDS_VALUE).resolve(AnnotationDescription[].class)) {
&nbsp;                            handlers.add(new Handler((Integer)field.getValue(TO_FIELD_INDEX).resolve(Integer.class), (String)field.getValue(TO_FIELD_VALUE).resolve(String.class), (TypeDescription)field.getValue(TO_FIELD_DECLARING_TYPE).resolve(TypeDescription.class), (Assigner.Typing)((EnumerationDescription)field.getValue(TO_FIELD_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class)));
&nbsp;                        }
&nbsp;
&nbsp;                        return handlers;
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToField.class).getDeclaredMethods();
&nbsp;                        TO_FIELD_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                        TO_FIELD_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
&nbsp;                        TO_FIELD_DECLARING_TYPE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;declaringType&quot;))).getOnly();
&nbsp;                        TO_FIELD_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @java.lang.annotation.Target({})
&nbsp;            @net.bytebuddy.build.RepeatedAnnotationPlugin.Enhance(ToFields.class)
&nbsp;            @Repeatable(ToFields.class)
&nbsp;            public @interface ToField {
&nbsp;                String value() default &quot;&quot;;
&nbsp;
&nbsp;                Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;                int index() default -1;
&nbsp;
&nbsp;                Assigner.Typing typing() default Typing.STATIC;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToReturned {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int index;
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int index, Assigner.Typing typing) {
&nbsp;                    this.index = index;
&nbsp;                    this.typing = typing;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    if (instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                        return net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;                    } else {
&nbsp;                        StackManipulation assignment = assigner.assign(type, instrumentedMethod.getReturnType(), this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + instrumentedMethod.getReturnType());
&nbsp;                        } else {
&nbsp;                            return new StackManipulation.Compound(new StackManipulation[]{value, assignment, MethodVariableAccess.of(instrumentedMethod.getReturnType()).storeAt(argumentHandler.returned())});
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typing.equals(((Handler)var1).typing);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.index) * 31 + this.typing.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static enum Factory implements Handler.Factory&lt;ToReturned&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_RETURNED_INDEX;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_RETURNED_TYPING;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;ToReturned&gt; getAnnotationType() {
&nbsp;                        return ToReturned.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToReturned&gt; annotation) {
&nbsp;                        if (!exit) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write returned value from enter advice &quot; + advice);
&nbsp;                        } else {
&nbsp;                            return Collections.singletonList(new Handler((Integer)annotation.getValue(TO_RETURNED_INDEX).resolve(Integer.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(TO_RETURNED_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class)));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToReturned.class).getDeclaredMethods();
&nbsp;                        TO_RETURNED_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
&nbsp;                        TO_RETURNED_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToThis {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int index;
&nbsp;                private final Assigner.Typing typing;
&nbsp;                private final boolean exit;
&nbsp;
&nbsp;                protected Handler(int index, Assigner.Typing typing, boolean exit) {
&nbsp;                    this.index = index;
&nbsp;                    this.typing = typing;
&nbsp;                    this.exit = exit;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    if (instrumentedMethod.isStatic()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign this reference for static method &quot; + instrumentedMethod);
&nbsp;                    } else if (!this.exit &amp;&amp; instrumentedMethod.isConstructor()) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign this reference in constructor prior to initialization for &quot; + instrumentedMethod);</b>
&nbsp;                    } else {
&nbsp;                        StackManipulation assignment = assigner.assign(type, instrumentedType.asGenericType(), this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + instrumentedType);
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            return new StackManipulation.Compound(new StackManipulation[]{value, assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(0))});</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
<b class="fc">&nbsp;                    } else if (var1 == null) {</b>
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else if (this.exit != ((Handler)var1).exit) {
&nbsp;                        return false;
&nbsp;                    } else {
<b class="fc">&nbsp;                        return this.typing.equals(((Handler)var1).typing);</b>
<b class="fc">&nbsp;                    }</b>
<b class="pc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;                public int hashCode() {</b>
<b class="nc">&nbsp;                    return ((this.getClass().hashCode() * 31 + this.index) * 31 + this.typing.hashCode()) * 31 + this.exit;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public static enum Factory implements Handler.Factory&lt;ToThis&gt; {</b>
<b class="nc">&nbsp;                    INSTANCE;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    private static final MethodDescription.InDefinedShape TO_THIS_INDEX;</b>
<b class="nc">&nbsp;                    private static final MethodDescription.InDefinedShape TO_THIS_TYPING;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    private Factory() {</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
<b class="nc">&nbsp;                    public Class&lt;ToThis&gt; getAnnotationType() {</b>
<b class="nc">&nbsp;                        return ToThis.class;</b>
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToThis&gt; annotation) {
&nbsp;                        return Collections.singletonList(new Handler((Integer)annotation.getValue(TO_THIS_INDEX).resolve(Integer.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(TO_THIS_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), exit));
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToThis.class).getDeclaredMethods();
&nbsp;                        TO_THIS_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
&nbsp;                        TO_THIS_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;        public @interface ToThrown {
&nbsp;            int index() default -1;
&nbsp;
&nbsp;            Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Handler implements Handler {
&nbsp;                private final int index;
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                protected Handler(int index, Assigner.Typing typing) {
&nbsp;                    this.index = index;
&nbsp;                    this.typing = typing;
&nbsp;                }
&nbsp;
&nbsp;                public int getIndex() {
&nbsp;                    return this.index;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, TypeDescription.Generic type, StackManipulation value) {
&nbsp;                    StackManipulation assignment = assigner.assign(type, net.bytebuddy.description.type.TypeDefinition.Sort.describe(Throwable.class), this.typing);
&nbsp;                    if (!assignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + Throwable.class.getName());
&nbsp;                    } else {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{value, assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.thrown())});
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Handler)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typing.equals(((Handler)var1).typing);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.index) * 31 + this.typing.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static enum Factory implements Handler.Factory&lt;ToThrown&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THROWN_INDEX;
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THROWN_TYPING;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;ToThrown&gt; getAnnotationType() {
&nbsp;                        return ToThrown.class;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                    )
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice, boolean exit, AnnotationDescription.Loadable&lt;? extends ToThrown&gt; annotation) {
&nbsp;                        if (!exit) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign thrown value from enter advice &quot; + advice);
&nbsp;                        } else if (((TypeDescription)advice.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.ON_THROWABLE).resolve(TypeDescription.class)).represents(NoExceptionHandler.class)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign thrown value for non-catching exit advice &quot; + advice);
&nbsp;                        } else {
&nbsp;                            return Collections.singletonList(new Handler((Integer)annotation.getValue(TO_THROWN_INDEX).resolve(Integer.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(TO_THROWN_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class)));
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(ToThrown.class).getDeclaredMethods();
&nbsp;                        TO_THROWN_INDEX = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;index&quot;))).getOnly();
<b class="fc">&nbsp;                        TO_THROWN_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @Enhance</b>
<b class="fc">&nbsp;    public static class WithCustomMapping {</b>
&nbsp;        private final PostProcessor.Factory postProcessorFactory;
&nbsp;        private final Delegator.Factory delegatorFactory;
&nbsp;        private final AsmClassReader.Factory classReaderFactory;
&nbsp;        private final Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings;
&nbsp;
<b class="fc">&nbsp;        protected WithCustomMapping() {</b>
&nbsp;            this(Advice.PostProcessor.NoOp.INSTANCE, Collections.emptyMap(), Advice.Delegator.ForRegularInvocation.Factory.INSTANCE, net.bytebuddy.utility.AsmClassReader.Factory.Default.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        protected WithCustomMapping(PostProcessor.Factory postProcessorFactory, Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings, Delegator.Factory delegatorFactory, AsmClassReader.Factory classReaderFactory) {
&nbsp;            this.postProcessorFactory = postProcessorFactory;
&nbsp;            this.offsetMappings = offsetMappings;
&nbsp;            this.delegatorFactory = delegatorFactory;
&nbsp;            this.classReaderFactory = classReaderFactory;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, @MaybeNull Object value) {
<b class="nc">&nbsp;            return this.bind(Advice.OffsetMapping.ForStackManipulation.Factory.of(type, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Field field) {
&nbsp;            return this.bind(type, (FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, FieldDescription fieldDescription) {
&nbsp;            return this.bind(new OffsetMapping.ForField.Resolved.Factory(type, fieldDescription));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Method method, int index) {
&nbsp;            if (index &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;A parameter cannot be negative: &quot; + index);
&nbsp;            } else if (method.getParameterTypes().length &lt;= index) {
&nbsp;                throw new IllegalArgumentException(method + &quot; does not declare a parameter with index &quot; + index);
&nbsp;            } else {
&nbsp;                return this.bind(type, (ParameterDescription)(new MethodDescription.ForLoadedMethod(method)).getParameters().get(index));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, int index) {
&nbsp;            if (index &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;A parameter cannot be negative: &quot; + index);
&nbsp;            } else if (constructor.getParameterTypes().length &lt;= index) {
&nbsp;                throw new IllegalArgumentException(constructor + &quot; does not declare a parameter with index &quot; + index);
&nbsp;            } else {
&nbsp;                return this.bind(type, (ParameterDescription)(new MethodDescription.ForLoadedConstructor(constructor)).getParameters().get(index));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, ParameterDescription parameterDescription) {
&nbsp;            return this.bind(new OffsetMapping.ForArgument.Resolved.Factory(type, parameterDescription));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Class&lt;?&gt; value) {
&nbsp;            return this.bind(type, ForLoadedType.of(value));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, TypeDescription value) {
&nbsp;            return this.bind(new OffsetMapping.ForStackManipulation.Factory(type, value));
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Enum&lt;?&gt; value) {
&nbsp;            return this.bind(type, (EnumerationDescription)(new EnumerationDescription.ForLoadedEnumeration(value)));
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, EnumerationDescription value) {
&nbsp;            return this.bind(new OffsetMapping.ForStackManipulation.Factory(type, value));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, Serializable value) {
<b class="fc">&nbsp;            return this.bindSerialized(type, value, value.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation, S extends Serializable&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, S value, Class&lt;? super S&gt; targetType) {
&nbsp;            return this.bind(Advice.OffsetMapping.ForSerializedValue.Factory.of(type, value, targetType));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindProperty(Class&lt;T&gt; type, String property) {
&nbsp;            return this.bind(Advice.OffsetMapping.ForStackManipulation.OfAnnotationProperty.of(type, property));
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, JavaConstant constant) {
&nbsp;            return this.bind(type, (ConstantValue)constant);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, ConstantValue constant) {
&nbsp;            return this.bind(new OffsetMapping.ForStackManipulation.Factory(type, constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, Type targetType) {
&nbsp;            return this.bind(type, stackManipulation, net.bytebuddy.description.type.TypeDefinition.Sort.describe(targetType));
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, TypeDescription.Generic targetType) {</b>
&nbsp;            return this.bind(new OffsetMapping.ForStackManipulation.Factory(type, stackManipulation, targetType));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, Class&lt;?&gt; functionalInterface) {
&nbsp;            return this.bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), ForLoadedType.of(functionalInterface));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, Class&lt;?&gt; functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;            return this.bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), ForLoadedType.of(functionalInterface), methodGraphCompiler);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Method method, Class&lt;?&gt; functionalInterface) {
&nbsp;            return this.bindLambda(type, new MethodDescription.ForLoadedMethod(method), ForLoadedType.of(functionalInterface));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Method method, Class&lt;?&gt; functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;            return this.bindLambda(type, new MethodDescription.ForLoadedMethod(method), ForLoadedType.of(functionalInterface), methodGraphCompiler);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface) {
&nbsp;            return this.bindLambda(type, methodDescription, functionalInterface, Compiler.DEFAULT);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
&nbsp;            if (!functionalInterface.isInterface()) {
&nbsp;                throw new IllegalArgumentException(functionalInterface + &quot; is not an interface type&quot;);
&nbsp;            } else {
<b class="nc">&nbsp;                MethodList&lt;?&gt; methods = (MethodList)methodGraphCompiler.compile(functionalInterface).listNodes().asMethodList().filter(ElementMatchers.isAbstract());</b>
<b class="nc">&nbsp;                if (methods.size() != 1) {</b>
&nbsp;                    throw new IllegalArgumentException(functionalInterface + &quot; does not define exactly one abstract method: &quot; + methods);
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    return this.bindDynamic(type, (MethodDescription.InDefinedShape)(new MethodDescription.Latent(new TypeDescription.Latent(&quot;java.lang.invoke.LambdaMetafactory&quot;, 1, net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), new TypeDescription.Generic[0]), &quot;metafactory&quot;, 9, Collections.emptyList(), JavaType.CALL_SITE.getTypeStub().asGenericType(), Arrays.asList(new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()), new ParameterDescription.Token(ForLoadedType.of(String.class).asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()), new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())), Collections.emptyList(), Collections.emptyList(), AnnotationValue.UNDEFINED, Generic.UNDEFINED)), MethodType.ofSignature((MethodDescription)methods.asDefined().getOnly()), MethodHandle.of(methodDescription), MethodType.ofSignature((MethodDescription)methods.asDefined().getOnly()));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, Object... constant) {
&nbsp;            return this.bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, List&lt;?&gt; constants) {
&nbsp;            return this.bindDynamic(type, (MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(bootstrapMethod)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, Object... constant) {
&nbsp;            return this.bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, List&lt;?&gt; constants) {
&nbsp;            return this.bindDynamic(type, (MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedConstructor(bootstrapMethod)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
&nbsp;            return this.bindDynamic(type, bootstrapMethod, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, List&lt;?&gt; constants) {
&nbsp;            List&lt;JavaConstant&gt; arguments = net.bytebuddy.utility.JavaConstant.Simple.wrap(constants);
&nbsp;            if (!bootstrapMethod.isInvokeBootstrap(Explicit.of(arguments))) {
&nbsp;                throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrapMethod + &quot; for &quot; + arguments);
&nbsp;            } else {
&nbsp;                return this.bind(new OffsetMapping.ForStackManipulation.OfDynamicInvocation(type, bootstrapMethod, arguments));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, OffsetMapping offsetMapping) {
&nbsp;            return this.bind(new OffsetMapping.Factory.Simple(type, offsetMapping));
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public WithCustomMapping bind(OffsetMapping.Factory&lt;?&gt; offsetMapping) {</b>
&nbsp;            Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new LinkedHashMap(this.offsetMappings);
<b class="fc">&nbsp;            if (!offsetMapping.getAnnotationType().isAnnotation()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + offsetMapping.getAnnotationType());</b>
&nbsp;            } else if (offsetMappings.put(offsetMapping.getAnnotationType(), offsetMapping) != null) {
&nbsp;                throw new IllegalArgumentException(&quot;Annotation type already mapped: &quot; + offsetMapping.getAnnotationType());
&nbsp;            } else {
&nbsp;                return new WithCustomMapping(this.postProcessorFactory, offsetMappings, this.delegatorFactory, this.classReaderFactory);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor) {
&nbsp;            return this.bootstrap(new MethodDescription.ForLoadedConstructor(constructor));
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor, BootstrapArgumentResolver.Factory resolverFactory) {</b>
<b class="fc">&nbsp;            return this.bootstrap(new MethodDescription.ForLoadedConstructor(constructor), resolverFactory);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public WithCustomMapping bootstrap(Method method) {
&nbsp;            return this.bootstrap(new MethodDescription.ForLoadedMethod(method));
&nbsp;        }
&nbsp;
&nbsp;        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolver) {
&nbsp;            return this.bootstrap(new MethodDescription.ForLoadedMethod(method), resolver);
&nbsp;        }
&nbsp;
&nbsp;        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap) {
&nbsp;            return this.bootstrap(bootstrap, Advice.BootstrapArgumentResolver.ForDefaultValues.Factory.INSTANCE);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory) {</b>
<b class="nc">&nbsp;            return new WithCustomMapping(this.postProcessorFactory, this.offsetMappings, Advice.Delegator.ForDynamicInvocation.of(bootstrap, resolverFactory), this.classReaderFactory);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public WithCustomMapping with(PostProcessor.Factory postProcessorFactory) {</b>
<b class="nc">&nbsp;            return new WithCustomMapping(new PostProcessor.Factory.Compound(new PostProcessor.Factory[]{this.postProcessorFactory, postProcessorFactory}), this.offsetMappings, this.delegatorFactory, this.classReaderFactory);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public WithCustomMapping with(AsmClassReader.Factory classReaderFactory) {</b>
&nbsp;            return new WithCustomMapping(this.postProcessorFactory, this.offsetMappings, this.delegatorFactory, classReaderFactory);
&nbsp;        }
&nbsp;
&nbsp;        public Advice to(Class&lt;?&gt; advice) {
&nbsp;            return this.to(advice, ForClassLoader.of(advice.getClassLoader()));
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Advice to(Class&lt;?&gt; advice, ClassFileLocator classFileLocator) {</b>
&nbsp;            return this.to(ForLoadedType.of(advice), classFileLocator);
&nbsp;        }
&nbsp;
&nbsp;        public Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
&nbsp;            return Advice.to(advice, this.postProcessorFactory, classFileLocator, new ArrayList(this.offsetMappings.values()), this.delegatorFactory, this.classReaderFactory);
&nbsp;        }
&nbsp;
&nbsp;        public Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice) {
&nbsp;            ClassLoader enterLoader = enterAdvice.getClassLoader();
&nbsp;            ClassLoader exitLoader = exitAdvice.getClassLoader();
&nbsp;            return this.to(enterAdvice, exitAdvice, (ClassFileLocator)(enterLoader == exitLoader ? ForClassLoader.of(enterLoader) : new ClassFileLocator.Compound(new ClassFileLocator[]{ForClassLoader.of(enterLoader), ForClassLoader.of(exitLoader)})));
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice, ClassFileLocator classFileLocator) {</b>
<b class="fc">&nbsp;            return this.to(ForLoadedType.of(enterAdvice), ForLoadedType.of(exitAdvice), classFileLocator);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
&nbsp;            return this.to(enterAdvice, exitAdvice, net.bytebuddy.dynamic.ClassFileLocator.NoOp.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
&nbsp;            return Advice.to(enterAdvice, exitAdvice, this.postProcessorFactory, classFileLocator, new ArrayList(this.offsetMappings.values()), this.delegatorFactory, this.classReaderFactory);
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (var1 == null) {</b>
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.postProcessorFactory.equals(((WithCustomMapping)var1).postProcessorFactory)) {
&nbsp;                return false;
&nbsp;            } else if (!this.delegatorFactory.equals(((WithCustomMapping)var1).delegatorFactory)) {
&nbsp;                return false;
&nbsp;            } else if (!this.classReaderFactory.equals(((WithCustomMapping)var1).classReaderFactory)) {
&nbsp;                return false;
<b class="pc">&nbsp;            } else {</b>
&nbsp;                return this.offsetMappings.equals(((WithCustomMapping)var1).offsetMappings);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (((this.getClass().hashCode() * 31 + this.postProcessorFactory.hashCode()) * 31 + this.delegatorFactory.hashCode()) * 31 + this.classReaderFactory.hashCode()) * 31 + this.offsetMappings.hashCode();
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    private static class NoExceptionHandler extends Throwable {
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;        private static final TypeDescription DESCRIPTION = ForLoadedType.of(NoExceptionHandler.class);
&nbsp;
&nbsp;        private NoExceptionHandler() {
&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);
&nbsp;        }
&nbsp;    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;    public static final class OnDefaultValue {</b>
&nbsp;        private OnDefaultValue() {
<b class="fc">&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static final class OnNonDefaultValue {
&nbsp;        private OnNonDefaultValue() {
&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface AllArguments {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;        boolean includeSelf() default false;
&nbsp;
&nbsp;        boolean nullIfEmpty() default false;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface Argument {
&nbsp;        int value();
&nbsp;
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    public interface ArgumentHandler {
&nbsp;        int THIS_REFERENCE = 0;
&nbsp;
&nbsp;        int argument(int var1);
&nbsp;
&nbsp;        int exit();
&nbsp;
&nbsp;        int enter();
&nbsp;
&nbsp;        int named(String var1);
&nbsp;
&nbsp;        int returned();
&nbsp;
&nbsp;        int thrown();
&nbsp;
&nbsp;        public static enum Factory {
&nbsp;            SIMPLE {
&nbsp;                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod, TypeDefinition enterType, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
&nbsp;                    return new ForInstrumentedMethod.Default.Simple(instrumentedMethod, exitType, namedTypes, enterType);
&nbsp;                }
&nbsp;            },
&nbsp;            COPYING {
&nbsp;                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod, TypeDefinition enterType, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
&nbsp;                    return new ForInstrumentedMethod.Default.Copying(instrumentedMethod, exitType, namedTypes, enterType);
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private Factory() {
&nbsp;            }
&nbsp;
&nbsp;            protected abstract ForInstrumentedMethod resolve(MethodDescription var1, TypeDefinition var2, TypeDefinition var3, SortedMap&lt;String, TypeDefinition&gt; var4);
&nbsp;        }
&nbsp;
&nbsp;        public interface ForAdvice extends ArgumentHandler {
&nbsp;            int mapped(int var1);
&nbsp;
&nbsp;            public abstract static class Default implements ForAdvice {
&nbsp;                protected final MethodDescription instrumentedMethod;
&nbsp;                protected final MethodDescription adviceMethod;
&nbsp;                protected final TypeDefinition exitType;
&nbsp;                protected final SortedMap&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                protected Default(MethodDescription instrumentedMethod, MethodDescription adviceMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
&nbsp;                    this.instrumentedMethod = instrumentedMethod;
&nbsp;                    this.adviceMethod = adviceMethod;
&nbsp;                    this.exitType = exitType;
&nbsp;                    this.namedTypes = namedTypes;
&nbsp;                }
&nbsp;
&nbsp;                public int argument(int offset) {
&nbsp;                    return offset;
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public int exit() {
&nbsp;                    return this.instrumentedMethod.getStackSize();
&nbsp;                }
&nbsp;
&nbsp;                public int named(String name) {
&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.headMap(name).values());
&nbsp;                }
&nbsp;
&nbsp;                public int enter() {
&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values());
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class ForMethodEnter extends Default {
<b class="fc">&nbsp;                    protected ForMethodEnter(MethodDescription instrumentedMethod, MethodDescription adviceMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes) {</b>
<b class="fc">&nbsp;                        super(instrumentedMethod, adviceMethod, exitType, namedTypes);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public int returned() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve the return value offset during enter advice&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public int thrown() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve the thrown value offset during enter advice&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public int mapped(int offset) {
&nbsp;                        return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) - this.adviceMethod.getStackSize() + offset;
&nbsp;                    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.getClass() == var1.getClass();
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="pc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return this.getClass().hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class ForMethodExit extends Default {
&nbsp;                    private final TypeDefinition enterType;
&nbsp;                    private final StackSize throwableSize;
<b class="nc">&nbsp;</b>
&nbsp;                    protected ForMethodExit(MethodDescription instrumentedMethod, MethodDescription adviceMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes, TypeDefinition enterType, StackSize throwableSize) {
&nbsp;                        super(instrumentedMethod, adviceMethod, exitType, namedTypes);
&nbsp;                        this.enterType = enterType;
&nbsp;                        this.throwableSize = throwableSize;
&nbsp;                    }
&nbsp;
&nbsp;                    public int returned() {
&nbsp;                        return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize();
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public int thrown() {
<b class="nc">&nbsp;                        return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize() + this.instrumentedMethod.getReturnType().getStackSize().getSize();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public int mapped(int offset) {
&nbsp;                        return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize() + this.instrumentedMethod.getReturnType().getStackSize().getSize() + this.throwableSize.getSize() - this.adviceMethod.getStackSize() + offset;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.throwableSize.equals(((ForMethodExit)var1).throwableSize)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.enterType.equals(((ForMethodExit)var1).enterType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.enterType.hashCode()) * 31 + this.throwableSize.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface ForInstrumentedMethod extends ArgumentHandler {
&nbsp;            int prepare(MethodVisitor var1);
&nbsp;
&nbsp;            ForAdvice bindEnter(MethodDescription var1);
&nbsp;
&nbsp;            ForAdvice bindExit(MethodDescription var1, boolean var2);
&nbsp;
&nbsp;            boolean isCopyingArguments();
&nbsp;
&nbsp;            List&lt;TypeDescription&gt; getNamedTypes();
&nbsp;
&nbsp;            public abstract static class Default implements ForInstrumentedMethod {
&nbsp;                protected final MethodDescription instrumentedMethod;
&nbsp;                protected final TypeDefinition exitType;
&nbsp;                protected final SortedMap&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;                protected final TypeDefinition enterType;
&nbsp;
&nbsp;                protected Default(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes, TypeDefinition enterType) {
&nbsp;                    this.instrumentedMethod = instrumentedMethod;
&nbsp;                    this.namedTypes = namedTypes;
&nbsp;                    this.exitType = exitType;
&nbsp;                    this.enterType = enterType;
&nbsp;                }
&nbsp;
&nbsp;                public int exit() {
&nbsp;                    return this.instrumentedMethod.getStackSize();
&nbsp;                }
&nbsp;
&nbsp;                public int named(String name) {
&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.headMap(name).values());
&nbsp;                }
&nbsp;
&nbsp;                public int enter() {
&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values());
&nbsp;                }
&nbsp;
&nbsp;                public int returned() {
&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize();
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public int thrown() {</b>
<b class="fc">&nbsp;                    return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize() + this.instrumentedMethod.getReturnType().getStackSize().getSize();</b>
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindEnter(MethodDescription adviceMethod) {
&nbsp;                    return new ForAdvice.ForMethodEnter(this.instrumentedMethod, adviceMethod, this.exitType, this.namedTypes);
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindExit(MethodDescription adviceMethod, boolean skipThrowable) {
&nbsp;                    return new ForAdvice.ForMethodExit(this.instrumentedMethod, adviceMethod, this.exitType, this.namedTypes, this.enterType, skipThrowable ? StackSize.ZERO : StackSize.SINGLE);
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;TypeDescription&gt; getNamedTypes() {
<b class="fc">&nbsp;                    List&lt;TypeDescription&gt; namedTypes = new ArrayList(this.namedTypes.size());</b>
<b class="fc">&nbsp;</b>
&nbsp;                    for(TypeDefinition typeDefinition : this.namedTypes.values()) {
&nbsp;                        namedTypes.add(typeDefinition.asErasure());
&nbsp;                    }
&nbsp;
&nbsp;                    return namedTypes;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @Enhance
&nbsp;                protected static class Simple extends Default {
&nbsp;                    protected Simple(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes, TypeDefinition enterType) {
&nbsp;                        super(instrumentedMethod, exitType, namedTypes, enterType);
&nbsp;                    }
&nbsp;
&nbsp;                    public int argument(int offset) {
&nbsp;                        return offset &lt; this.instrumentedMethod.getStackSize() ? offset : offset + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize();
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public boolean isCopyingArguments() {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public int prepare(MethodVisitor methodVisitor) {
&nbsp;                        return 0;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.getClass() == var1.getClass();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class Copying extends Default {
&nbsp;                    protected Copying(MethodDescription instrumentedMethod, TypeDefinition exitType, SortedMap&lt;String, TypeDefinition&gt; namedTypes, TypeDefinition enterType) {
&nbsp;                        super(instrumentedMethod, exitType, namedTypes, enterType);
&nbsp;                    }
&nbsp;
&nbsp;                    public int argument(int offset) {
&nbsp;                        return this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize() + offset;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isCopyingArguments() {
&nbsp;                        return true;
&nbsp;                    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int prepare(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                        StackSize stackSize;</b>
&nbsp;                        if (!this.instrumentedMethod.isStatic()) {
&nbsp;                            methodVisitor.visitVarInsn(25, 0);
&nbsp;                            methodVisitor.visitVarInsn(58, this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize());
&nbsp;                            stackSize = StackSize.SINGLE;
&nbsp;                        } else {
&nbsp;                            stackSize = StackSize.ZERO;
&nbsp;                        }
&nbsp;
&nbsp;                        for(ParameterDescription parameterDescription : this.instrumentedMethod.getParameters()) {
<b class="fc">&nbsp;                            net.bytebuddy.jar.asm.Type type = net.bytebuddy.jar.asm.Type.getType(parameterDescription.getType().asErasure().getDescriptor());</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(type.getOpcode(21), parameterDescription.getOffset());</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(type.getOpcode(54), this.instrumentedMethod.getStackSize() + this.exitType.getStackSize().getSize() + StackSize.of(this.namedTypes.values()) + this.enterType.getStackSize().getSize() + parameterDescription.getOffset());</b>
<b class="fc">&nbsp;                            stackSize = stackSize.maximum(parameterDescription.getType().getStackSize());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        return stackSize.getSize();
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            return this.getClass() == var1.getClass();</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public int hashCode() {
<b class="nc">&nbsp;                        return this.getClass().hashCode();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public interface BootstrapArgumentResolver {
<b class="nc">&nbsp;        List&lt;JavaConstant&gt; resolve(TypeDescription var1, MethodDescription var2);</b>
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForDefaultValues implements BootstrapArgumentResolver {
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;            private final boolean exit;
&nbsp;
<b class="fc">&nbsp;            protected ForDefaultValues(MethodDescription.InDefinedShape adviceMethod, boolean exit) {</b>
&nbsp;                this.adviceMethod = adviceMethod;
&nbsp;                this.exit = exit;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public List&lt;JavaConstant&gt; resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {</b>
&nbsp;                return instrumentedMethod.isTypeInitializer() ? Arrays.asList(net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(this.adviceMethod.getDeclaringType().getName()), net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(this.exit ? 1 : 0), net.bytebuddy.utility.JavaConstant.Simple.of(instrumentedType), net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName())) : Arrays.asList(net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(this.adviceMethod.getDeclaringType().getName()), net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(this.exit ? 1 : 0), net.bytebuddy.utility.JavaConstant.Simple.of(instrumentedType), net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()), MethodHandle.of((MethodDescription.InDefinedShape)instrumentedMethod.asDefined()));
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.exit != ((ForDefaultValues)var1).exit) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.adviceMethod.equals(((ForDefaultValues)var1).adviceMethod);
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public int hashCode() {</b>
&nbsp;                return (this.getClass().hashCode() * 31 + this.adviceMethod.hashCode()) * 31 + this.exit;
&nbsp;            }
&nbsp;
&nbsp;            public static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
<b class="fc">&nbsp;                private Factory() {</b>
&nbsp;                }
&nbsp;
&nbsp;                public BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
&nbsp;                    return new ForDefaultValues(adviceMethod, exit);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public interface Factory {</b>
<b class="nc">&nbsp;            BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape var1, boolean var2);</b>
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected interface Delegator {
&nbsp;        StackManipulation apply(TypeDescription var1, MethodDescription var2);
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForRegularInvocation implements Delegator {
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            protected ForRegularInvocation(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                this.adviceMethod = adviceMethod;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                return MethodInvocation.invoke(this.adviceMethod);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.adviceMethod.equals(((ForRegularInvocation)var1).adviceMethod);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.adviceMethod.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
&nbsp;                    return new ForRegularInvocation(adviceMethod);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForDynamicInvocation implements Delegator {
&nbsp;            private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;            private final BootstrapArgumentResolver resolver;
&nbsp;
&nbsp;            protected ForDynamicInvocation(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.InDefinedShape adviceMethod, BootstrapArgumentResolver resolver) {
&nbsp;                this.bootstrapMethod = bootstrapMethod;
&nbsp;                this.adviceMethod = adviceMethod;
&nbsp;                this.resolver = resolver;
&nbsp;            }
&nbsp;
&nbsp;            protected static Factory of(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {
&nbsp;                if (!bootstrapMethod.isInvokeBootstrap()) {
&nbsp;                    throw new IllegalArgumentException(&quot;Not a suitable bootstrap target: &quot; + bootstrapMethod);
&nbsp;                } else {
&nbsp;                    return new Factory(bootstrapMethod, resolverFactory);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                List&lt;JavaConstant&gt; constants = this.resolver.resolve(instrumentedType, instrumentedMethod);
&nbsp;                if (!this.bootstrapMethod.isInvokeBootstrap(Explicit.of(constants))) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + this.bootstrapMethod + &quot; with arguments: &quot; + constants);
&nbsp;                } else {
&nbsp;                    return MethodInvocation.invoke(this.bootstrapMethod).dynamic(this.adviceMethod.getInternalName(), this.adviceMethod.getReturnType().asErasure(), this.adviceMethod.getParameters().asTypeList().asErasures(), constants);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
<b class="fc">&nbsp;                } else if (var1 == null) {</b>
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.bootstrapMethod.equals(((ForDynamicInvocation)var1).bootstrapMethod)) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (!this.adviceMethod.equals(((ForDynamicInvocation)var1).adviceMethod)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.resolver.equals(((ForDynamicInvocation)var1).resolver);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.bootstrapMethod.hashCode()) * 31 + this.adviceMethod.hashCode()) * 31 + this.resolver.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory {
&nbsp;                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;                private final BootstrapArgumentResolver.Factory resolverFactory;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected Factory(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {</b>
<b class="fc">&nbsp;                    this.bootstrapMethod = bootstrapMethod;</b>
&nbsp;                    this.resolverFactory = resolverFactory;
&nbsp;                }
&nbsp;
&nbsp;                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
&nbsp;                    return new ForDynamicInvocation(this.bootstrapMethod, adviceMethod, this.resolverFactory.resolve(adviceMethod, exit));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (this.getClass() != var1.getClass()) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (!this.bootstrapMethod.equals(((Factory)var1).bootstrapMethod)) {</b>
<b class="pc">&nbsp;                        return false;</b>
&nbsp;                    } else {
&nbsp;                        return this.resolverFactory.equals(((Factory)var1).resolverFactory);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    return (this.getClass().hashCode() * 31 + this.bootstrapMethod.hashCode()) * 31 + this.resolverFactory.hashCode();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            Delegator make(MethodDescription.InDefinedShape var1, boolean var2);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Documented</b>
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
<b class="nc">&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})</b>
&nbsp;    public @interface Enter {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    public interface ExceptionHandler {
&nbsp;        StackManipulation resolve(MethodDescription var1, TypeDescription var2);
&nbsp;
&nbsp;        public static enum Default implements ExceptionHandler {
&nbsp;            SUPPRESSING {
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
&nbsp;                    return Removal.SINGLE;
&nbsp;                }
&nbsp;            },
&nbsp;            PRINTING {
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
&nbsp;                    try {
&nbsp;                        return MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(Throwable.class.getMethod(&quot;printStackTrace&quot;)));
&nbsp;                    } catch (NoSuchMethodException var4) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot locate Throwable::printStackTrace&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            },
&nbsp;            RETHROWING {
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
&nbsp;                    return Throw.INSTANCE;
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private Default() {
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Simple implements ExceptionHandler {
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            public Simple(StackManipulation stackManipulation) {
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                return this.stackManipulation;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.stackManipulation.equals(((Simple)var1).stackManipulation);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public int hashCode() {</b>
<b class="nc">&nbsp;                return this.getClass().hashCode() * 31 + this.stackManipulation.hashCode();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface Exit {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface FieldGetterHandle {
&nbsp;        String value() default &quot;&quot;;
&nbsp;
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface FieldSetterHandle {
&nbsp;        String value() default &quot;&quot;;
&nbsp;
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
<b class="nc">&nbsp;    public @interface FieldValue {</b>
&nbsp;        String value() default &quot;&quot;;
&nbsp;
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Documented</b>
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface Local {
&nbsp;        String value();
&nbsp;    }
&nbsp;
&nbsp;    protected interface MethodSizeHandler {
&nbsp;        int UNDEFINED_SIZE = 32767;
&nbsp;
<b class="fc">&nbsp;        void requireStackSize(int var1);</b>
&nbsp;
&nbsp;        void requireLocalVariableLength(int var1);
&nbsp;
&nbsp;        public static enum NoOp implements ForInstrumentedMethod, ForAdvice {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() {
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {</b>
<b class="fc">&nbsp;                return this;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public int compoundStackSize(int stackSize) {
&nbsp;                return 32767;
&nbsp;            }
&nbsp;
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) {
&nbsp;                return 32767;
&nbsp;            }
<b class="pc">&nbsp;</b>
&nbsp;            public void requireStackSize(int stackSize) {
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public void requireLocalVariableLength(int localVariableLength) {
&nbsp;            }
&nbsp;
&nbsp;            public void requireStackSizePadding(int stackSizePadding) {
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
&nbsp;            }
&nbsp;
&nbsp;            public void recordMaxima(int stackSize, int localVariableLength) {
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class Default implements ForInstrumentedMethod {
<b class="fc">&nbsp;            protected final MethodDescription instrumentedMethod;</b>
&nbsp;            protected final List&lt;? extends TypeDescription&gt; initialTypes;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; preMethodTypes;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; postMethodTypes;
&nbsp;            protected int stackSize;
&nbsp;            protected int localVariableLength;
&nbsp;
&nbsp;            protected Default(MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes) {
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;                this.initialTypes = initialTypes;
&nbsp;                this.preMethodTypes = preMethodTypes;
&nbsp;                this.postMethodTypes = postMethodTypes;
&nbsp;            }
&nbsp;
&nbsp;            protected static ForInstrumentedMethod of(MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean copyArguments, int writerFlags) {
&nbsp;                if ((writerFlags &amp; 3) != 0) {
&nbsp;                    return Advice.MethodSizeHandler.NoOp.INSTANCE;
&nbsp;                } else {
&nbsp;                    return (ForInstrumentedMethod)(copyArguments ? new WithCopiedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes) : new WithRetainedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                return new ForAdvice(adviceMethod, this.instrumentedMethod.getStackSize() + StackSize.of(this.initialTypes));
&nbsp;            }
&nbsp;
&nbsp;            public void requireStackSize(int stackSize) {
&nbsp;                this.stackSize = Math.max(this.stackSize, stackSize);
&nbsp;            }
&nbsp;
&nbsp;            public void requireLocalVariableLength(int localVariableLength) {
&nbsp;                this.localVariableLength = Math.max(this.localVariableLength, localVariableLength);
&nbsp;            }
&nbsp;
&nbsp;            public int compoundStackSize(int stackSize) {
&nbsp;                return Math.max(this.stackSize, stackSize);
&nbsp;            }
&nbsp;
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) {
&nbsp;                return Math.max(this.localVariableLength, localVariableLength + StackSize.of(this.postMethodTypes) + StackSize.of(this.initialTypes) + StackSize.of(this.preMethodTypes));
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithRetainedArguments extends Default {
&nbsp;                protected WithRetainedArguments(MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes) {
&nbsp;                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                    return new ForAdvice(adviceMethod, this.instrumentedMethod.getStackSize() + StackSize.of(this.postMethodTypes) + StackSize.of(this.initialTypes) + StackSize.of(this.preMethodTypes));
&nbsp;                }
&nbsp;
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) {
&nbsp;                    return Math.max(this.localVariableLength, localVariableLength + StackSize.of(this.postMethodTypes) + StackSize.of(this.initialTypes) + StackSize.of(this.preMethodTypes));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class WithCopiedArguments extends Default {
&nbsp;                protected WithCopiedArguments(MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes) {
&nbsp;                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                    return new ForAdvice(adviceMethod, 2 * this.instrumentedMethod.getStackSize() + StackSize.of(this.initialTypes) + StackSize.of(this.preMethodTypes) + StackSize.of(this.postMethodTypes));
&nbsp;                }
&nbsp;
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) {
&nbsp;                    return Math.max(this.localVariableLength, localVariableLength + this.instrumentedMethod.getStackSize() + StackSize.of(this.postMethodTypes) + StackSize.of(this.initialTypes) + StackSize.of(this.preMethodTypes));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class ForAdvice implements ForAdvice {
&nbsp;                private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;                private final int baseLocalVariableLength;
&nbsp;                private int stackSizePadding;
&nbsp;                private int localVariableLengthPadding;
&nbsp;
&nbsp;                protected ForAdvice(MethodDescription.InDefinedShape adviceMethod, int baseLocalVariableLength) {
&nbsp;                    this.adviceMethod = adviceMethod;
&nbsp;                    this.baseLocalVariableLength = baseLocalVariableLength;
&nbsp;                }
&nbsp;
&nbsp;                public void requireStackSize(int stackSize) {
&nbsp;                    Default.this.requireStackSize(stackSize);
&nbsp;                }
&nbsp;
&nbsp;                public void requireLocalVariableLength(int localVariableLength) {
&nbsp;                    Default.this.requireLocalVariableLength(localVariableLength);
&nbsp;                }
&nbsp;
&nbsp;                public void requireStackSizePadding(int stackSizePadding) {
&nbsp;                    this.stackSizePadding = Math.max(this.stackSizePadding, stackSizePadding);
&nbsp;                }
&nbsp;
&nbsp;                public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
&nbsp;                    this.localVariableLengthPadding = Math.max(this.localVariableLengthPadding, localVariableLengthPadding);
&nbsp;                }
&nbsp;
&nbsp;                public void recordMaxima(int stackSize, int localVariableLength) {
&nbsp;                    Default.this.requireStackSize(stackSize + this.stackSizePadding);
&nbsp;                    Default.this.requireLocalVariableLength(localVariableLength - this.adviceMethod.getStackSize() + this.baseLocalVariableLength + this.localVariableLengthPadding);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface ForAdvice extends MethodSizeHandler {
&nbsp;            void requireStackSizePadding(int var1);
&nbsp;
&nbsp;            void requireLocalVariableLengthPadding(int var1);
&nbsp;
&nbsp;            void recordMaxima(int var1, int var2);
&nbsp;        }
&nbsp;
&nbsp;        public interface ForInstrumentedMethod extends MethodSizeHandler {
&nbsp;            ForAdvice bindEnter(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;            ForAdvice bindExit(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;            int compoundStackSize(int var1);
&nbsp;
&nbsp;            int compoundLocalVariableLength(int var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface OffsetMapping {
&nbsp;        Target resolve(TypeDescription var1, MethodDescription var2, Assigner var3, ArgumentHandler var4, Sort var5);
&nbsp;
&nbsp;        public static enum Sort {
&nbsp;            ENTER {
&nbsp;                public boolean isPremature(MethodDescription methodDescription) {
&nbsp;                    return methodDescription.isConstructor();
&nbsp;                }
&nbsp;            },
&nbsp;            EXIT {
&nbsp;                public boolean isPremature(MethodDescription methodDescription) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private Sort() {
&nbsp;            }
&nbsp;
&nbsp;            public abstract boolean isPremature(MethodDescription var1);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class ForArgument implements OffsetMapping {
&nbsp;            protected final TypeDescription.Generic target;
&nbsp;            protected final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForArgument(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                ParameterDescription parameterDescription = this.resolve(instrumentedMethod);
&nbsp;                StackManipulation readAssignment = assigner.assign(parameterDescription.getType(), this.target, this.typing);
&nbsp;                if (!readAssignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + this.target);
&nbsp;                } else if (this.readOnly) {
&nbsp;                    return new Target.ForVariable.ReadOnly(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment);
&nbsp;                } else {
&nbsp;                    StackManipulation writeAssignment = assigner.assign(this.target, parameterDescription.getType(), this.typing);
&nbsp;                    if (!writeAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + this.target);
&nbsp;                    } else {
&nbsp;                        return new Target.ForVariable.ReadWrite(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment, writeAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract ParameterDescription resolve(MethodDescription var1);
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForArgument)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForArgument)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForArgument)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Unresolved extends ForArgument {
&nbsp;                private final int index;
&nbsp;                private final boolean optional;
&nbsp;
&nbsp;                protected Unresolved(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Argument&gt; annotation) {
&nbsp;                    this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForArgument.Unresolved.Factory.ARGUMENT_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForArgument.Unresolved.Factory.ARGUMENT_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), (Integer)annotation.getValue(Advice.OffsetMapping.ForArgument.Unresolved.Factory.ARGUMENT_VALUE).resolve(Integer.class), (Boolean)annotation.getValue(Advice.OffsetMapping.ForArgument.Unresolved.Factory.ARGUMENT_OPTIONAL).resolve(Boolean.class));
&nbsp;                }
&nbsp;
&nbsp;                protected Unresolved(ParameterDescription parameterDescription) {
&nbsp;                    this(parameterDescription.getType(), true, Typing.STATIC, parameterDescription.getIndex());
&nbsp;                }
&nbsp;
&nbsp;                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index) {
&nbsp;                    this(target, readOnly, typing, index, false);
&nbsp;                }
&nbsp;
&nbsp;                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index, boolean optional) {
&nbsp;                    super(target, readOnly, typing);
&nbsp;                    this.index = index;
&nbsp;                    this.optional = optional;
&nbsp;                }
&nbsp;
&nbsp;                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
&nbsp;                    ParameterList&lt;?&gt; parameters = instrumentedMethod.getParameters();
&nbsp;                    if (parameters.size() &lt;= this.index) {
&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not define an index &quot; + this.index);
&nbsp;                    } else {
&nbsp;                        return (ParameterDescription)parameters.get(this.index);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                    if (this.optional &amp;&amp; instrumentedMethod.getParameters().size() &lt;= this.index) {
&nbsp;                        return (Target)(this.readOnly ? new Target.ForDefaultValue.ReadOnly(this.target) : new Target.ForDefaultValue.ReadWrite(this.target));
&nbsp;                    } else {
&nbsp;                        return super.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, sort);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.index != ((Unresolved)var1).index) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.optional == ((Unresolved)var1).optional;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (super.hashCode() * 31 + this.index) * 31 + this.optional;
&nbsp;                }
&nbsp;
&nbsp;                protected static enum Factory implements Factory&lt;Argument&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_VALUE;
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_READ_ONLY;
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_TYPING;
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;Argument&gt; getAnnotationType() {
&nbsp;                        return Argument.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Argument&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(ARGUMENT_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot define writable field access for &quot; + target + &quot; when using delegation&quot;);
&nbsp;                        } else {
&nbsp;                            return new Unresolved(target.getType(), annotation);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(Argument.class).getDeclaredMethods();
&nbsp;                        ARGUMENT_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                        ARGUMENT_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                        ARGUMENT_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                        ARGUMENT_OPTIONAL = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;optional&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Resolved extends ForArgument {
&nbsp;                private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, ParameterDescription parameterDescription) {
&nbsp;                    super(target, readOnly, typing);
&nbsp;                    this.parameterDescription = parameterDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
&nbsp;                    if (!this.parameterDescription.getDeclaringMethod().equals(instrumentedMethod)) {
&nbsp;                        throw new IllegalStateException(this.parameterDescription + &quot; is not a parameter of &quot; + instrumentedMethod);
&nbsp;                    } else {
&nbsp;                        return this.parameterDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.parameterDescription.equals(((Resolved)var1).parameterDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.parameterDescription.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;                    private final ParameterDescription parameterDescription;
&nbsp;                    private final boolean readOnly;
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, ParameterDescription parameterDescription) {
&nbsp;                        this(annotationType, parameterDescription, true, Typing.STATIC);
&nbsp;                    }
&nbsp;
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, ParameterDescription parameterDescription, boolean readOnly, Assigner.Typing typing) {
&nbsp;                        this.annotationType = annotationType;
&nbsp;                        this.parameterDescription = parameterDescription;
&nbsp;                        this.readOnly = readOnly;
&nbsp;                        this.typing = typing;
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
&nbsp;                        return this.annotationType;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        return new Resolved(target.getType(), this.readOnly, this.typing, this.parameterDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.readOnly != ((Factory)var1).readOnly) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.typing.equals(((Factory)var1).typing)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.annotationType.equals(((Factory)var1).annotationType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.parameterDescription.equals(((Factory)var1).parameterDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.parameterDescription.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForThisReference implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;            private final boolean optional;
&nbsp;
&nbsp;            protected ForThisReference(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;This&gt; annotation) {
&nbsp;                this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForThisReference.Factory.THIS_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForThisReference.Factory.THIS_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), (Boolean)annotation.getValue(Advice.OffsetMapping.ForThisReference.Factory.THIS_OPTIONAL).resolve(Boolean.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForThisReference(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean optional) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;                this.optional = optional;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                if (!instrumentedMethod.isStatic() &amp;&amp; !sort.isPremature(instrumentedMethod)) {
&nbsp;                    StackManipulation readAssignment = assigner.assign(instrumentedType.asGenericType(), this.target, this.typing);
&nbsp;                    if (!readAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedType + &quot; to &quot; + this.target);
&nbsp;                    } else if (this.readOnly) {
&nbsp;                        return new Target.ForVariable.ReadOnly(instrumentedType.asGenericType(), argumentHandler.argument(0), readAssignment);
&nbsp;                    } else {
&nbsp;                        StackManipulation writeAssignment = assigner.assign(this.target, instrumentedType.asGenericType(), this.typing);
&nbsp;                        if (!writeAssignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + instrumentedType);
&nbsp;                        } else {
&nbsp;                            return new Target.ForVariable.ReadWrite(instrumentedType.asGenericType(), argumentHandler.argument(0), readAssignment, writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else if (this.optional) {
&nbsp;                    return (Target)(this.readOnly ? new Target.ForDefaultValue.ReadOnly(instrumentedType) : new Target.ForDefaultValue.ReadWrite(instrumentedType));
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Cannot map this reference for static method or constructor start: &quot; + instrumentedMethod);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForThisReference)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (this.optional != ((ForThisReference)var1).optional) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForThisReference)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForThisReference)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode()) * 31 + this.optional;
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;This&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape THIS_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape THIS_TYPING;
&nbsp;                private static final MethodDescription.InDefinedShape THIS_OPTIONAL;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;This&gt; getAnnotationType() {
&nbsp;                    return This.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;This&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(THIS_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to this reference for &quot; + target + &quot; in read-only context&quot;);
&nbsp;                    } else {
&nbsp;                        return new ForThisReference(target.getType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(This.class).getDeclaredMethods();
&nbsp;                    THIS_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    THIS_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    THIS_OPTIONAL = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;optional&quot;))).getOnly();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForAllArguments implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;            private final boolean includeSelf;
&nbsp;            private final boolean nullIfEmpty;
&nbsp;
&nbsp;            protected ForAllArguments(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;AllArguments&gt; annotation) {
&nbsp;                this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForAllArguments.Factory.ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForAllArguments.Factory.ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), (Boolean)annotation.getValue(Advice.OffsetMapping.ForAllArguments.Factory.ALL_ARGUMENTS_INCLUDE_SELF).resolve(Boolean.class), (Boolean)annotation.getValue(Advice.OffsetMapping.ForAllArguments.Factory.ALL_ARGUMENTS_NULL_IF_EMPTY).resolve(Boolean.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForAllArguments(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean includeSelf, boolean nullIfEmpty) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;                this.includeSelf = includeSelf;
&nbsp;                this.nullIfEmpty = nullIfEmpty;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                if (!this.nullIfEmpty || !instrumentedMethod.getParameters().isEmpty() || this.includeSelf &amp;&amp; !instrumentedMethod.isStatic()) {
&nbsp;                    List&lt;StackManipulation&gt; reads = new ArrayList((this.includeSelf &amp;&amp; !instrumentedMethod.isStatic() ? 1 : 0) + instrumentedMethod.getParameters().size());
&nbsp;                    if (this.includeSelf &amp;&amp; !instrumentedMethod.isStatic()) {
&nbsp;                        if (sort.isPremature(instrumentedMethod) &amp;&amp; instrumentedMethod.isConstructor()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot include self in all arguments array from &quot; + instrumentedMethod);
&nbsp;                        }
&nbsp;
&nbsp;                        StackManipulation assignment = assigner.assign(instrumentedMethod.getDeclaringType().asGenericType(), this.target, this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedMethod.getDeclaringType() + &quot; to &quot; + this.target);
&nbsp;                        }
&nbsp;
&nbsp;                        reads.add(new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(0)), assignment}));
&nbsp;                    }
&nbsp;
&nbsp;                    for(ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
&nbsp;                        StackManipulation assignment = assigner.assign(parameterDescription.getType(), this.target, this.typing);
&nbsp;                        if (!assignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + this.target);
&nbsp;                        }
&nbsp;
&nbsp;                        reads.add(new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.of(parameterDescription.getType()).loadFrom(argumentHandler.argument(parameterDescription.getOffset())), assignment}));
&nbsp;                    }
&nbsp;
&nbsp;                    if (this.readOnly) {
&nbsp;                        return new Target.ForArray.ReadOnly(this.target, reads);
&nbsp;                    } else {
&nbsp;                        List&lt;StackManipulation&gt; writes = new ArrayList(2 * ((this.includeSelf &amp;&amp; !instrumentedMethod.isStatic() ? 1 : 0) + instrumentedMethod.getParameters().size()));
&nbsp;                        if (this.includeSelf &amp;&amp; !instrumentedMethod.isStatic()) {
&nbsp;                            StackManipulation assignment = assigner.assign(this.target, instrumentedMethod.getDeclaringType().asGenericType(), this.typing);
&nbsp;                            if (!assignment.isValid()) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + instrumentedMethod.getDeclaringType());
&nbsp;                            }
&nbsp;
&nbsp;                            writes.add(new StackManipulation.Compound(new StackManipulation[]{assignment, MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(0))}));
&nbsp;                        }
&nbsp;
&nbsp;                        for(ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {
&nbsp;                            StackManipulation assignment = assigner.assign(this.target, parameterDescription.getType(), this.typing);
&nbsp;                            if (!assignment.isValid()) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + parameterDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            writes.add(new StackManipulation.Compound(new StackManipulation[]{assignment, MethodVariableAccess.of(parameterDescription.getType()).storeAt(argumentHandler.argument(parameterDescription.getOffset()))}));
&nbsp;                        }
&nbsp;
&nbsp;                        return new Target.ForArray.ReadWrite(this.target, reads, writes);
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return (Target)(this.readOnly ? new Target.ForStackManipulation(NullConstant.INSTANCE) : new Target.ForStackManipulation.Writable(NullConstant.INSTANCE, Removal.SINGLE));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForAllArguments)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (this.includeSelf != ((ForAllArguments)var1).includeSelf) {
&nbsp;                    return false;
&nbsp;                } else if (this.nullIfEmpty != ((ForAllArguments)var1).nullIfEmpty) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForAllArguments)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForAllArguments)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode()) * 31 + this.includeSelf) * 31 + this.nullIfEmpty;
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;AllArguments&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;AllArguments&gt; getAnnotationType() {
&nbsp;                    return AllArguments.class;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;AllArguments&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (!target.getType().represents(Object.class) &amp;&amp; !target.getType().isArray()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot use AllArguments annotation on a non-array type&quot;);
&nbsp;                    } else if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot define writable field access for &quot; + target);
&nbsp;                    } else {
&nbsp;                        return new ForAllArguments(target.getType().represents(Object.class) ? net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class) : target.getType().getComponentType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(AllArguments.class).getDeclaredMethods();
&nbsp;                    ALL_ARGUMENTS_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    ALL_ARGUMENTS_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                    ALL_ARGUMENTS_INCLUDE_SELF = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;includeSelf&quot;))).getOnly();
&nbsp;                    ALL_ARGUMENTS_NULL_IF_EMPTY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;nullIfEmpty&quot;))).getOnly();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForInstrumentedType implements OffsetMapping {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForInstrumentedType() {
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                return Advice.OffsetMapping.Target.ForStackManipulation.of(instrumentedType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForInstrumentedMethod implements OffsetMapping {
&nbsp;            METHOD {
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
&nbsp;                    return instrumentedMethod.isMethod();
&nbsp;                }
&nbsp;
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return Advice.OffsetMapping.Target.ForStackManipulation.of(methodDescription);
&nbsp;                }
&nbsp;            },
&nbsp;            CONSTRUCTOR {
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
&nbsp;                    return instrumentedMethod.isConstructor();
&nbsp;                }
&nbsp;
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return Advice.OffsetMapping.Target.ForStackManipulation.of(methodDescription);
&nbsp;                }
&nbsp;            },
&nbsp;            EXECUTABLE {
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return Advice.OffsetMapping.Target.ForStackManipulation.of(methodDescription);
&nbsp;                }
&nbsp;            },
&nbsp;            METHOD_HANDLE {
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return new Target.ForStackManipulation(MethodHandle.of(methodDescription).toStackManipulation());
&nbsp;                }
&nbsp;            },
&nbsp;            METHOD_TYPE {
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return new Target.ForStackManipulation(MethodType.of(methodDescription).toStackManipulation());
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private ForInstrumentedMethod() {
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                if (!this.isRepresentable(instrumentedMethod)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot represent &quot; + instrumentedMethod + &quot; as the specified constant&quot;);
&nbsp;                } else {
&nbsp;                    return this.resolve((MethodDescription.InDefinedShape)instrumentedMethod.asDefined());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract boolean isRepresentable(MethodDescription var1);
&nbsp;
&nbsp;            protected abstract Target resolve(MethodDescription.InDefinedShape var1);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class ForField implements OffsetMapping {
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_VALUE;
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_DECLARING_TYPE;
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_READ_ONLY;
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_TYPING;
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForField(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                FieldDescription fieldDescription = this.resolve(instrumentedType, instrumentedMethod);
&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);
&nbsp;                } else if (sort.isPremature(instrumentedMethod) &amp;&amp; !fieldDescription.isStatic()) {
&nbsp;                    if (this.readOnly) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot read &quot; + fieldDescription + &quot; before super constructor call&quot;);
&nbsp;                    } else {
&nbsp;                        StackManipulation writeAssignment = assigner.assign(this.target, fieldDescription.getType(), this.typing);
&nbsp;                        if (!writeAssignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + fieldDescription);
&nbsp;                        } else {
&nbsp;                            return new Target.ForField.WriteOnly((FieldDescription)fieldDescription.asDefined(), writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    StackManipulation readAssignment = assigner.assign(fieldDescription.getType(), this.target, this.typing);
&nbsp;                    if (!readAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + this.target);
&nbsp;                    } else if (this.readOnly) {
&nbsp;                        return new Target.ForField.ReadOnly(fieldDescription, readAssignment);
&nbsp;                    } else {
&nbsp;                        StackManipulation writeAssignment = assigner.assign(this.target, fieldDescription.getType(), this.typing);
&nbsp;                        if (!writeAssignment.isValid()) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + fieldDescription);
&nbsp;                        } else {
&nbsp;                            return new Target.ForField.ReadWrite((FieldDescription)fieldDescription.asDefined(), readAssignment, writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract FieldDescription resolve(TypeDescription var1, MethodDescription var2);
&nbsp;
&nbsp;            static {
&nbsp;                MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(FieldValue.class).getDeclaredMethods();
&nbsp;                FIELD_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                FIELD_DECLARING_TYPE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;declaringType&quot;))).getOnly();
&nbsp;                FIELD_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                FIELD_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForField)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForField)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForField)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class Unresolved extends ForField {
&nbsp;                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
&nbsp;                    super(target, readOnly, typing);
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                    FieldLocator locator = this.fieldLocator(instrumentedType);
&nbsp;                    FieldLocator.Resolution resolution = this.name.equals(&quot;&quot;) ? net.bytebuddy.dynamic.scaffold.FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(this.name);
&nbsp;                    if (!resolution.isResolved()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + this.name + &quot; for &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return resolution.getField();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected abstract FieldLocator fieldLocator(TypeDescription var1);
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.name.equals(((Unresolved)var1).name);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.name.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class WithImplicitType extends Unresolved {
&nbsp;                    protected WithImplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation) {
&nbsp;                        this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), (String)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_VALUE).resolve(String.class));
&nbsp;                    }
&nbsp;
&nbsp;                    public WithImplicitType(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
&nbsp;                        super(target, readOnly, typing, name);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
&nbsp;                        return new FieldLocator.ForClassHierarchy(instrumentedType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithExplicitType extends Unresolved {
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    protected WithExplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation, TypeDescription declaringType) {
&nbsp;                        this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class), (String)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_VALUE).resolve(String.class), declaringType);
&nbsp;                    }
&nbsp;
&nbsp;                    public WithExplicitType(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name, TypeDescription declaringType) {
&nbsp;                        super(target, readOnly, typing, name);
&nbsp;                        this.declaringType = declaringType;
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
&nbsp;                        if (!this.declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(this.declaringType)) {
&nbsp;                            throw new IllegalStateException(this.declaringType + &quot; is no super type of &quot; + instrumentedType);
&nbsp;                        } else {
&nbsp;                            return new FieldLocator.ForExactType(TargetType.resolve(this.declaringType, instrumentedType));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.declaringType.equals(((WithExplicitType)var1).declaringType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.declaringType.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static enum Factory implements Factory&lt;FieldValue&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private Factory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;FieldValue&gt; getAnnotationType() {
&nbsp;                        return FieldValue.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot write to field for &quot; + target + &quot; in read-only context&quot;);
&nbsp;                        } else {
&nbsp;                            TypeDescription declaringType = (TypeDescription)annotation.getValue(Advice.OffsetMapping.ForField.FIELD_DECLARING_TYPE).resolve(TypeDescription.class);
&nbsp;                            return (OffsetMapping)(declaringType.represents(Void.TYPE) ? new WithImplicitType(target.getType(), annotation) : new WithExplicitType(target.getType(), annotation, declaringType));
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Resolved extends ForField {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, FieldDescription fieldDescription) {
&nbsp;                    super(target, readOnly, typing);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                )
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                    if (!this.fieldDescription.isStatic() &amp;&amp; !this.fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(this.fieldDescription + &quot; is no member of &quot; + instrumentedType);
&nbsp;                    } else if (!this.fieldDescription.isVisibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + this.fieldDescription + &quot; from &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((Resolved)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;                    private final boolean readOnly;
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription) {
&nbsp;                        this(annotationType, fieldDescription, true, Typing.STATIC);
&nbsp;                    }
&nbsp;
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, boolean readOnly, Assigner.Typing typing) {
&nbsp;                        this.annotationType = annotationType;
&nbsp;                        this.fieldDescription = fieldDescription;
&nbsp;                        this.readOnly = readOnly;
&nbsp;                        this.typing = typing;
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
&nbsp;                        return this.annotationType;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        return new Resolved(target.getType(), this.readOnly, this.typing, this.fieldDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.readOnly != ((Factory)var1).readOnly) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.typing.equals(((Factory)var1).typing)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.annotationType.equals(((Factory)var1).annotationType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.fieldDescription.equals(((Factory)var1).fieldDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.fieldDescription.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class ForFieldHandle implements OffsetMapping {
&nbsp;            private final Access access;
&nbsp;
&nbsp;            protected ForFieldHandle(Access access) {
&nbsp;                this.access = access;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                FieldDescription fieldDescription = this.resolve(instrumentedType, instrumentedMethod);
&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);
&nbsp;                } else if (sort.isPremature(instrumentedMethod) &amp;&amp; !fieldDescription.isStatic()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; before super constructor call&quot;);
&nbsp;                } else {
&nbsp;                    return fieldDescription.isStatic() ? new Target.ForStackManipulation(this.access.resolve((FieldDescription.InDefinedShape)fieldDescription.asDefined()).toStackManipulation()) : new Target.ForStackManipulation(new StackManipulation.Compound(new StackManipulation[]{this.access.resolve((FieldDescription.InDefinedShape)fieldDescription.asDefined()).toStackManipulation(), MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(0)), MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;, 1, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(new TypeDefinition[]{net.bytebuddy.description.type.TypeDefinition.Sort.describe(Object.class)}))))}));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract FieldDescription resolve(TypeDescription var1, MethodDescription var2);
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.access.equals(((ForFieldHandle)var1).access);
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.access.hashCode();
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static enum Access {
&nbsp;                GETTER {
&nbsp;                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;                        return MethodHandle.ofGetter(fieldDescription);
&nbsp;                    }
&nbsp;                },
&nbsp;                SETTER {
&nbsp;                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;                        return MethodHandle.ofSetter(fieldDescription);
<b class="nc">&nbsp;                    }</b>
&nbsp;                };
&nbsp;
&nbsp;                private Access() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape var1);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class Unresolved extends ForFieldHandle {
&nbsp;                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;                private final String name;
&nbsp;
&nbsp;                public Unresolved(Access access, String name) {
&nbsp;                    super(access);
&nbsp;                    this.name = name;
&nbsp;                }
&nbsp;
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                    FieldLocator locator = this.fieldLocator(instrumentedType);
&nbsp;                    FieldLocator.Resolution resolution = this.name.equals(&quot;&quot;) ? net.bytebuddy.dynamic.scaffold.FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod) : locator.locate(this.name);
&nbsp;                    if (!resolution.isResolved()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + this.name + &quot; for &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return resolution.getField();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected abstract FieldLocator fieldLocator(TypeDescription var1);
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.name.equals(((Unresolved)var1).name);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.name.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class WithImplicitType extends Unresolved {
&nbsp;                    public WithImplicitType(Access access, String name) {
&nbsp;                        super(access, name);
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
&nbsp;                        return new FieldLocator.ForClassHierarchy(instrumentedType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithExplicitType extends Unresolved {
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    public WithExplicitType(Access access, String name, TypeDescription declaringType) {
&nbsp;                        super(access, name);
&nbsp;                        this.declaringType = declaringType;
&nbsp;                    }
&nbsp;
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
&nbsp;                        if (!this.declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(this.declaringType)) {
&nbsp;                            throw new IllegalStateException(this.declaringType + &quot; is no super type of &quot; + instrumentedType);
&nbsp;                        } else {
&nbsp;                            return new FieldLocator.ForExactType(TargetType.resolve(this.declaringType, instrumentedType));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.declaringType.equals(((WithExplicitType)var1).declaringType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.declaringType.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static enum ReaderFactory implements Factory&lt;FieldGetterHandle&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    private ReaderFactory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;FieldGetterHandle&gt; getAnnotationType() {
&nbsp;                        return FieldGetterHandle.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldGetterHandle&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);
&nbsp;                        } else {
&nbsp;                            TypeDescription declaringType = (TypeDescription)annotation.getValue(FIELD_GETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
&nbsp;                            return (OffsetMapping)(declaringType.represents(Void.TYPE) ? new WithImplicitType(Advice.OffsetMapping.ForFieldHandle.Access.GETTER, (String)annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class)) : new WithExplicitType(Advice.OffsetMapping.ForFieldHandle.Access.GETTER, (String)annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class), declaringType));
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(FieldGetterHandle.class).getDeclaredMethods();
<b class="fc">&nbsp;                        FIELD_GETTER_HANDLE_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();</b>
&nbsp;                        FIELD_GETTER_HANDLE_DECLARING_TYPE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;declaringType&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static enum WriterFactory implements Factory&lt;FieldSetterHandle&gt; {
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    private WriterFactory() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;FieldSetterHandle&gt; getAnnotationType() {
&nbsp;                        return FieldSetterHandle.class;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldSetterHandle&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);
&nbsp;                        } else {
&nbsp;                            TypeDescription declaringType = (TypeDescription)annotation.getValue(FIELD_SETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);
&nbsp;                            return (OffsetMapping)(declaringType.represents(Void.TYPE) ? new WithImplicitType(Advice.OffsetMapping.ForFieldHandle.Access.SETTER, (String)annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class)) : new WithExplicitType(Advice.OffsetMapping.ForFieldHandle.Access.SETTER, (String)annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class), declaringType));
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    static {
&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(FieldSetterHandle.class).getDeclaredMethods();
&nbsp;                        FIELD_SETTER_HANDLE_VALUE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                        FIELD_SETTER_HANDLE_DECLARING_TYPE = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;declaringType&quot;))).getOnly();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Resolved extends ForFieldHandle {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                public Resolved(Access access, FieldDescription fieldDescription) {
&nbsp;                    super(access);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;                )
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                    if (!this.fieldDescription.isStatic() &amp;&amp; !this.fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(this.fieldDescription + &quot; is no member of &quot; + instrumentedType);
&nbsp;                    } else if (!this.fieldDescription.isVisibleTo(instrumentedType)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + this.fieldDescription + &quot; from &quot; + instrumentedType);
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((Resolved)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;                    private final Access access;
&nbsp;
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, Access access) {
&nbsp;                        this.annotationType = annotationType;
&nbsp;                        this.fieldDescription = fieldDescription;
&nbsp;                        this.access = access;
&nbsp;                    }
&nbsp;
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
&nbsp;                        return this.annotationType;
&nbsp;                    }
&nbsp;
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);
&nbsp;                        } else {
&nbsp;                            return new Resolved(this.access, this.fieldDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.access.equals(((Factory)var1).access)) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.annotationType.equals(((Factory)var1).annotationType)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.fieldDescription.equals(((Factory)var1).fieldDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return ((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.fieldDescription.hashCode()) * 31 + this.access.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForOrigin implements OffsetMapping {
&nbsp;            private static final char DELIMITER = &#39;#&#39;;
&nbsp;            private static final char ESCAPE = &#39;\\&#39;;
&nbsp;            private final List&lt;Renderer&gt; renderers;
&nbsp;
&nbsp;            public ForOrigin(List&lt;Renderer&gt; renderers) {
&nbsp;                this.renderers = renderers;
&nbsp;            }
&nbsp;
&nbsp;            public static OffsetMapping parse(String pattern) {
&nbsp;                if (pattern.equals(&quot;&quot;)) {
&nbsp;                    return new ForOrigin(Collections.singletonList(Advice.OffsetMapping.ForOrigin.Renderer.ForStringRepresentation.INSTANCE));
&nbsp;                } else {
&nbsp;                    List&lt;Renderer&gt; renderers = new ArrayList(pattern.length());
&nbsp;                    int from = 0;
&nbsp;
&nbsp;                    for(int to = pattern.indexOf(35); to != -1; to = pattern.indexOf(35, from)) {
&nbsp;                        if (to == 0 || pattern.charAt(to - 1) != &#39;\\&#39; || to != 1 &amp;&amp; pattern.charAt(to - 2) == &#39;\\&#39;) {
&nbsp;                            if (pattern.length() == to + 1) {
&nbsp;                                throw new IllegalStateException(&quot;Missing sort descriptor for &quot; + pattern + &quot; at index &quot; + to);
&nbsp;                            }
&nbsp;
&nbsp;                            renderers.add(new Renderer.ForConstantValue(pattern.substring(from, to).replace(&quot;\\\\&quot;, &quot;\\&quot;)));
&nbsp;                            switch (pattern.charAt(to + 1)) {
&nbsp;                                case &#39;d&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForDescriptor.INSTANCE);
&nbsp;                                    break;
&nbsp;                                case &#39;e&#39;:
&nbsp;                                case &#39;f&#39;:
&nbsp;                                case &#39;g&#39;:
&nbsp;                                case &#39;h&#39;:
&nbsp;                                case &#39;i&#39;:
&nbsp;                                case &#39;j&#39;:
&nbsp;                                case &#39;k&#39;:
&nbsp;                                case &#39;l&#39;:
&nbsp;                                case &#39;n&#39;:
&nbsp;                                case &#39;o&#39;:
&nbsp;                                case &#39;q&#39;:
&nbsp;                                default:
&nbsp;                                    throw new IllegalStateException(&quot;Illegal sort descriptor &quot; + pattern.charAt(to + 1) + &quot; for &quot; + pattern);
&nbsp;                                case &#39;m&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForMethodName.INSTANCE);
&nbsp;                                    break;
&nbsp;                                case &#39;p&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForPropertyName.INSTANCE);
&nbsp;                                    break;
&nbsp;                                case &#39;r&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForReturnTypeName.INSTANCE);
&nbsp;                                    break;
&nbsp;                                case &#39;s&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForJavaSignature.INSTANCE);
&nbsp;                                    break;
&nbsp;                                case &#39;t&#39;:
&nbsp;                                    renderers.add(Advice.OffsetMapping.ForOrigin.Renderer.ForTypeName.INSTANCE);
&nbsp;                            }
&nbsp;
&nbsp;                            from = to + 2;
&nbsp;                        } else {
&nbsp;                            renderers.add(new Renderer.ForConstantValue(pattern.substring(from, Math.max(0, to - 1)) + &#39;#&#39;));
&nbsp;                            from = to + 1;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    renderers.add(new Renderer.ForConstantValue(pattern.substring(from)));
&nbsp;                    return new ForOrigin(renderers);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StringBuilder stringBuilder = new StringBuilder();
&nbsp;
&nbsp;                for(Renderer renderer : this.renderers) {
&nbsp;                    stringBuilder.append(renderer.apply(instrumentedType, instrumentedMethod));
&nbsp;                }
&nbsp;
&nbsp;                return Advice.OffsetMapping.Target.ForStackManipulation.of((Object)stringBuilder.toString());
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.renderers.equals(((ForOrigin)var1).renderers);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.renderers.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;Origin&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape ORIGIN_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(Origin.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Origin&gt; getAnnotationType() {
&nbsp;                    return Origin.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Origin&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (target.getType().asErasure().represents(Class.class)) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedType.INSTANCE;
&nbsp;                    } else if (target.getType().asErasure().represents(Method.class)) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedMethod.METHOD;
&nbsp;                    } else if (target.getType().asErasure().represents(Constructor.class)) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedMethod.CONSTRUCTOR;
&nbsp;                    } else if (JavaType.EXECUTABLE.getTypeStub().equals(target.getType().asErasure())) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedMethod.EXECUTABLE;
&nbsp;                    } else if (JavaType.METHOD_HANDLE.getTypeStub().equals(target.getType().asErasure())) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedMethod.METHOD_HANDLE;
&nbsp;                    } else if (JavaType.METHOD_TYPE.getTypeStub().equals(target.getType().asErasure())) {
&nbsp;                        return Advice.OffsetMapping.ForInstrumentedMethod.METHOD_TYPE;
&nbsp;                    } else if (JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().equals(target.getType().asErasure())) {
&nbsp;                        return new ForStackManipulation(MethodInvocation.lookup(), JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType(), target.getType(), Typing.STATIC);
&nbsp;                    } else if (target.getType().asErasure().isAssignableFrom(String.class)) {
&nbsp;                        return Advice.OffsetMapping.ForOrigin.parse((String)annotation.getValue(ORIGIN_VALUE).resolve(String.class));
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Non-supported type &quot; + target.getType() + &quot; for @Origin annotation&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Renderer {
&nbsp;                String apply(TypeDescription var1, MethodDescription var2);
&nbsp;
&nbsp;                public static enum ForMethodName implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;m&#39;;
&nbsp;
&nbsp;                    private ForMethodName() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return instrumentedMethod.getInternalName();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForTypeName implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;t&#39;;
&nbsp;
&nbsp;                    private ForTypeName() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return instrumentedType.getName();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForDescriptor implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;d&#39;;
&nbsp;
&nbsp;                    private ForDescriptor() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return instrumentedMethod.getDescriptor();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForJavaSignature implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;s&#39;;
&nbsp;
&nbsp;                    private ForJavaSignature() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        StringBuilder stringBuilder = new StringBuilder(&quot;(&quot;);
&nbsp;                        boolean comma = false;
&nbsp;
&nbsp;                        for(TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                            if (comma) {
&nbsp;                                stringBuilder.append(&#39;,&#39;);
&nbsp;                            } else {
&nbsp;                                comma = true;
&nbsp;                            }
&nbsp;
&nbsp;                            stringBuilder.append(typeDescription.getName());
&nbsp;                        }
&nbsp;
&nbsp;                        return stringBuilder.append(&#39;)&#39;).toString();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForReturnTypeName implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;r&#39;;
&nbsp;
&nbsp;                    private ForReturnTypeName() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return instrumentedMethod.getReturnType().asErasure().getName();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForStringRepresentation implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForStringRepresentation() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return instrumentedMethod.toString();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForConstantValue implements Renderer {
&nbsp;                    private final String value;
&nbsp;
&nbsp;                    public ForConstantValue(String value) {
&nbsp;                        this.value = value;
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return this.value;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.value.equals(((ForConstantValue)var1).value);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.value.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForPropertyName implements Renderer {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    public static final char SYMBOL = &#39;p&#39;;
&nbsp;
&nbsp;                    private ForPropertyName() {
&nbsp;                    }
&nbsp;
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
&nbsp;                        return ForBeanProperty.INSTANCE.resolve(instrumentedMethod);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForSelfCallHandle implements OffsetMapping {
&nbsp;            BOUND {
&nbsp;                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
&nbsp;                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList(1 + (methodDescription.isStatic() ? 0 : 2) + methodDescription.getParameters().size() * 3);
&nbsp;                    stackManipulations.add(stackManipulation);
&nbsp;                    if (!methodDescription.isStatic()) {
&nbsp;                        stackManipulations.add(MethodVariableAccess.loadThis());
&nbsp;                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;, 1, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(new TypeDefinition[]{net.bytebuddy.description.type.TypeDefinition.Sort.describe(Object.class)})))));
&nbsp;                    }
&nbsp;
&nbsp;                    if (!methodDescription.getParameters().isEmpty()) {
&nbsp;                        List&lt;StackManipulation&gt; values = new ArrayList(methodDescription.getParameters().size());
&nbsp;
&nbsp;                        for(ParameterDescription parameterDescription : methodDescription.getParameters()) {
&nbsp;                            values.add(parameterDescription.getType().isPrimitive() ? new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.load(parameterDescription), Assigner.DEFAULT.assign(parameterDescription.getType(), parameterDescription.getType().asErasure().asBoxed().asGenericType(), Typing.STATIC)}) : MethodVariableAccess.load(parameterDescription));
&nbsp;                        }
&nbsp;
&nbsp;                        stackManipulations.add(IntegerConstant.forValue(0));
&nbsp;                        stackManipulations.add(ArrayFactory.forType(ForLoadedType.of(Object.class).asGenericType()).withValues(values));
&nbsp;                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLES.getTypeStub(), new MethodDescription.Token(&quot;insertArguments&quot;, 9, JavaType.METHOD_HANDLE.getTypeStub().asGenericType(), new TypeList.Generic.Explicit(new TypeDefinition[]{JavaType.METHOD_HANDLE.getTypeStub(), net.bytebuddy.description.type.TypeDefinition.Sort.describe(Integer.TYPE), net.bytebuddy.description.type.TypeDefinition.Sort.describe(Object[].class)})))));
&nbsp;                    }
&nbsp;
&nbsp;                    return new StackManipulation.Compound(stackManipulations);
&nbsp;                }
&nbsp;            },
&nbsp;            UNBOUND {
&nbsp;                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
&nbsp;                    return stackManipulation;
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private ForSelfCallHandle() {
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                if (!instrumentedMethod.isMethod()) {
&nbsp;                    throw new IllegalStateException();
&nbsp;                } else {
&nbsp;                    StackManipulation stackManipulation = (instrumentedMethod.isStatic() ? MethodHandle.of((MethodDescription.InDefinedShape)instrumentedMethod.asDefined()) : MethodHandle.ofSpecial((MethodDescription.InDefinedShape)instrumentedMethod.asDefined(), instrumentedType)).toStackManipulation();
&nbsp;                    return new Target.ForStackManipulation(this.decorate(instrumentedMethod, stackManipulation));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract StackManipulation decorate(MethodDescription var1, StackManipulation var2);
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;SelfCallHandle&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape SELF_CALL_HANDLE_BOUND = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(SelfCallHandle.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;bound&quot;))).getOnly();
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;SelfCallHandle&gt; getAnnotationType() {
&nbsp;                    return SelfCallHandle.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;SelfCallHandle&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign a MethodHandle to &quot; + target);
&nbsp;                    } else {
&nbsp;                        return (Boolean)annotation.getValue(SELF_CALL_HANDLE_BOUND).resolve(Boolean.class) ? Advice.OffsetMapping.ForSelfCallHandle.BOUND : Advice.OffsetMapping.ForSelfCallHandle.UNBOUND;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForUnusedValue implements OffsetMapping {
&nbsp;            private final TypeDefinition target;
&nbsp;
&nbsp;            public ForUnusedValue(TypeDefinition target) {
&nbsp;                this.target = target;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                return new Target.ForDefaultValue.ReadWrite(this.target);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForUnusedValue)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.target.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;Unused&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Unused&gt; getAnnotationType() {
&nbsp;                    return Unused.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Unused&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    return new ForUnusedValue(target.getType());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForStubValue implements OffsetMapping, Factory&lt;StubValue&gt; {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForStubValue() {
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                return new Target.ForDefaultValue.ReadOnly(instrumentedMethod.getReturnType(), assigner.assign(instrumentedMethod.getReturnType(), net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Typing.DYNAMIC));
&nbsp;            }
&nbsp;
&nbsp;            public Class&lt;StubValue&gt; getAnnotationType() {
&nbsp;                return StubValue.class;
&nbsp;            }
&nbsp;
&nbsp;            public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;StubValue&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                if (!target.getType().represents(Object.class)) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot use StubValue on non-Object parameter type &quot; + target);
&nbsp;                } else {
&nbsp;                    return this;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForEnterValue implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final TypeDescription.Generic enterType;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, AnnotationDescription.Loadable&lt;Enter&gt; annotation) {
&nbsp;                this(target, enterType, (Boolean)annotation.getValue(Advice.OffsetMapping.ForEnterValue.Factory.ENTER_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForEnterValue.Factory.ENTER_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.enterType = enterType;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation readAssignment = assigner.assign(this.enterType, this.target, this.typing);
&nbsp;                if (!readAssignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.enterType + &quot; to &quot; + this.target);
&nbsp;                } else if (this.readOnly) {
&nbsp;                    return new Target.ForVariable.ReadOnly(this.target, argumentHandler.enter(), readAssignment);
&nbsp;                } else {
&nbsp;                    StackManipulation writeAssignment = assigner.assign(this.target, this.enterType, this.typing);
&nbsp;                    if (!writeAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + this.enterType);
&nbsp;                    } else {
&nbsp;                        return new Target.ForVariable.ReadWrite(this.target, argumentHandler.enter(), readAssignment, writeAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForEnterValue)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForEnterValue)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.target.equals(((ForEnterValue)var1).target)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.enterType.equals(((ForEnterValue)var1).enterType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.enterType.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory&lt;Enter&gt; {
&nbsp;                private static final MethodDescription.InDefinedShape ENTER_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape ENTER_TYPING;
&nbsp;                private final TypeDefinition enterType;
&nbsp;
&nbsp;                protected Factory(TypeDefinition enterType) {
&nbsp;                    this.enterType = enterType;
&nbsp;                }
&nbsp;
&nbsp;                protected static Factory&lt;Enter&gt; of(TypeDefinition typeDefinition) {
&nbsp;                    return (Factory&lt;Enter&gt;)(typeDefinition.represents(Void.TYPE) ? new Factory.Illegal(Enter.class) : new Factory(typeDefinition));
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Enter&gt; getAnnotationType() {
&nbsp;                    return Enter.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Enter&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(ENTER_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);
&nbsp;                    } else {
&nbsp;                        return new ForEnterValue(target.getType(), this.enterType.asGenericType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(Enter.class).getDeclaredMethods();
&nbsp;                    ENTER_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    ENTER_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.enterType.equals(((Factory)var1).enterType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.enterType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForExitValue implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final TypeDescription.Generic exitType;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, AnnotationDescription.Loadable&lt;Exit&gt; annotation) {
&nbsp;                this(target, exitType, (Boolean)annotation.getValue(Advice.OffsetMapping.ForExitValue.Factory.EXIT_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForExitValue.Factory.EXIT_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.exitType = exitType;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation readAssignment = assigner.assign(this.exitType, this.target, this.typing);
&nbsp;                if (!readAssignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.exitType + &quot; to &quot; + this.target);
&nbsp;                } else if (this.readOnly) {
&nbsp;                    return new Target.ForVariable.ReadOnly(this.target, argumentHandler.exit(), readAssignment);
&nbsp;                } else {
&nbsp;                    StackManipulation writeAssignment = assigner.assign(this.target, this.exitType, this.typing);
&nbsp;                    if (!writeAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + this.exitType);
&nbsp;                    } else {
&nbsp;                        return new Target.ForVariable.ReadWrite(this.target, argumentHandler.exit(), readAssignment, writeAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForExitValue)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForExitValue)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.target.equals(((ForExitValue)var1).target)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.exitType.equals(((ForExitValue)var1).exitType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.exitType.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory&lt;Exit&gt; {
&nbsp;                private static final MethodDescription.InDefinedShape EXIT_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape EXIT_TYPING;
&nbsp;                private final TypeDefinition exitType;
&nbsp;
&nbsp;                protected Factory(TypeDefinition exitType) {
&nbsp;                    this.exitType = exitType;
&nbsp;                }
&nbsp;
&nbsp;                protected static Factory&lt;Exit&gt; of(TypeDefinition typeDefinition) {
&nbsp;                    return (Factory&lt;Exit&gt;)(typeDefinition.represents(Void.TYPE) ? new Factory.Illegal(Exit.class) : new Factory(typeDefinition));
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Exit&gt; getAnnotationType() {
&nbsp;                    return Exit.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Exit&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(EXIT_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);
&nbsp;                    } else {
&nbsp;                        return new ForExitValue(target.getType(), this.exitType.asGenericType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(Exit.class).getDeclaredMethods();
&nbsp;                    EXIT_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    EXIT_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.exitType.equals(((Factory)var1).exitType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.exitType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForLocalValue implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final TypeDescription.Generic localType;
&nbsp;            private final String name;
&nbsp;
&nbsp;            public ForLocalValue(TypeDescription.Generic target, TypeDescription.Generic localType, String name) {
&nbsp;                this.target = target;
&nbsp;                this.localType = localType;
&nbsp;                this.name = name;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation readAssignment = assigner.assign(this.localType, this.target, Typing.STATIC);
&nbsp;                StackManipulation writeAssignment = assigner.assign(this.target, this.localType, Typing.STATIC);
&nbsp;                if (readAssignment.isValid() &amp;&amp; writeAssignment.isValid()) {
&nbsp;                    return new Target.ForVariable.ReadWrite(this.target, argumentHandler.named(this.name), readAssignment, writeAssignment);
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.localType + &quot; to &quot; + this.target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.name.equals(((ForLocalValue)var1).name)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.target.equals(((ForLocalValue)var1).target)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.localType.equals(((ForLocalValue)var1).localType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.localType.hashCode()) * 31 + this.name.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class Factory implements Factory&lt;Local&gt; {
&nbsp;                protected static final MethodDescription.InDefinedShape LOCAL_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(Local.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;                private final Map&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                protected Factory(Map&lt;String, TypeDefinition&gt; namedTypes) {
&nbsp;                    this.namedTypes = namedTypes;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Local&gt; getAnnotationType() {
&nbsp;                    return Local.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Local&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    String name = (String)annotation.getValue(LOCAL_VALUE).resolve(String.class);
&nbsp;                    TypeDefinition namedType = (TypeDefinition)this.namedTypes.get(name);
&nbsp;                    if (namedType == null) {
&nbsp;                        throw new IllegalStateException(&quot;Named local variable is unknown: &quot; + name);
&nbsp;                    } else {
&nbsp;                        return new ForLocalValue(target.getType(), namedType.asGenericType(), name);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.namedTypes.equals(((Factory)var1).namedTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.namedTypes.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForReturnValue implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForReturnValue(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Return&gt; annotation) {
&nbsp;                this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForReturnValue.Factory.RETURN_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForReturnValue.Factory.RETURN_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForReturnValue(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation readAssignment = assigner.assign(instrumentedMethod.getReturnType(), this.target, this.typing);
&nbsp;                if (!readAssignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedMethod.getReturnType() + &quot; to &quot; + this.target);
&nbsp;                } else if (this.readOnly) {
&nbsp;                    return (Target)(instrumentedMethod.getReturnType().represents(Void.TYPE) ? new Target.ForDefaultValue.ReadOnly(this.target) : new Target.ForVariable.ReadOnly(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment));
&nbsp;                } else {
&nbsp;                    StackManipulation writeAssignment = assigner.assign(this.target, instrumentedMethod.getReturnType(), this.typing);
&nbsp;                    if (!writeAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to &quot; + instrumentedMethod.getReturnType());
&nbsp;                    } else {
&nbsp;                        return (Target)(instrumentedMethod.getReturnType().represents(Void.TYPE) ? new Target.ForDefaultValue.ReadWrite(this.target) : new Target.ForVariable.ReadWrite(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment, writeAssignment));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForReturnValue)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForReturnValue)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForReturnValue)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;Return&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape RETURN_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape RETURN_TYPING;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Return&gt; getAnnotationType() {
&nbsp;                    return Return.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Return&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(RETURN_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write return value for &quot; + target + &quot; in read-only context&quot;);
&nbsp;                    } else {
&nbsp;                        return new ForReturnValue(target.getType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(Return.class).getDeclaredMethods();
&nbsp;                    RETURN_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    RETURN_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForThrowable implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final boolean readOnly;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            protected ForThrowable(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Thrown&gt; annotation) {
&nbsp;                this(target, (Boolean)annotation.getValue(Advice.OffsetMapping.ForThrowable.Factory.THROWN_READ_ONLY).resolve(Boolean.class), (Assigner.Typing)((EnumerationDescription)annotation.getValue(Advice.OffsetMapping.ForThrowable.Factory.THROWN_TYPING).resolve(EnumerationDescription.class)).load(Assigner.Typing.class));
&nbsp;            }
&nbsp;
&nbsp;            public ForThrowable(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {
&nbsp;                this.target = target;
&nbsp;                this.readOnly = readOnly;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation readAssignment = assigner.assign(ForLoadedType.of(Throwable.class).asGenericType(), this.target, this.typing);
&nbsp;                if (!readAssignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign Throwable to &quot; + this.target);
&nbsp;                } else if (this.readOnly) {
&nbsp;                    return new Target.ForVariable.ReadOnly(ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment);
&nbsp;                } else {
&nbsp;                    StackManipulation writeAssignment = assigner.assign(this.target, ForLoadedType.of(Throwable.class).asGenericType(), this.typing);
&nbsp;                    if (!writeAssignment.isValid()) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + this.target + &quot; to Throwable&quot;);
&nbsp;                    } else {
&nbsp;                        return new Target.ForVariable.ReadWrite(ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment, writeAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (this.readOnly != ((ForThrowable)var1).readOnly) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForThrowable)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.target.equals(((ForThrowable)var1).target);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.readOnly) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Factory implements Factory&lt;Thrown&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private static final MethodDescription.InDefinedShape THROWN_READ_ONLY;
&nbsp;                private static final MethodDescription.InDefinedShape THROWN_TYPING;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming annotation for exit advice.&quot;
&nbsp;                )
&nbsp;                protected static Factory&lt;?&gt; of(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                    return (Factory&lt;?&gt;)(((TypeDescription)adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(Advice.ON_THROWABLE).resolve(TypeDescription.class)).represents(NoExceptionHandler.class) ? new Factory.Illegal(Thrown.class) : INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;Thrown&gt; getAnnotationType() {
&nbsp;                    return Thrown.class;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Thrown&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !(Boolean)annotation.getValue(THROWN_READ_ONLY).resolve(Boolean.class)) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);
&nbsp;                    } else {
&nbsp;                        return new ForThrowable(target.getType(), annotation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = ForLoadedType.of(Thrown.class).getDeclaredMethods();
&nbsp;                    THROWN_READ_ONLY = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;readOnly&quot;))).getOnly();
&nbsp;                    THROWN_TYPING = (MethodDescription.InDefinedShape)((MethodList)methods.filter(ElementMatchers.named(&quot;typing&quot;))).getOnly();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForStackManipulation implements OffsetMapping {
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;            private final TypeDescription.Generic typeDescription;
&nbsp;            private final TypeDescription.Generic targetType;
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, TypeDescription.Generic targetType, Assigner.Typing typing) {
&nbsp;                this.stackManipulation = stackManipulation;
&nbsp;                this.typeDescription = typeDescription;
&nbsp;                this.targetType = targetType;
&nbsp;                this.typing = typing;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation assignment = assigner.assign(this.typeDescription, this.targetType, this.typing);
&nbsp;                if (!assignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.typeDescription + &quot; to &quot; + this.targetType);
&nbsp;                } else {
&nbsp;                    return new Target.ForStackManipulation(new StackManipulation.Compound(new StackManipulation[]{this.stackManipulation, assignment}));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typing.equals(((ForStackManipulation)var1).typing)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.stackManipulation.equals(((ForStackManipulation)var1).stackManipulation)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typeDescription.equals(((ForStackManipulation)var1).typeDescription)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.targetType.equals(((ForStackManipulation)var1).targetType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return (((this.getClass().hashCode() * 31 + this.stackManipulation.hashCode()) * 31 + this.typeDescription.hashCode()) * 31 + this.targetType.hashCode()) * 31 + this.typing.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Factory&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;                private final StackManipulation stackManipulation;
&nbsp;                private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                public Factory(Class&lt;T&gt; annotationType, TypeDescription typeDescription) {
&nbsp;                    this(annotationType, ClassConstant.of(typeDescription), ForLoadedType.of(Class.class).asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                public Factory(Class&lt;T&gt; annotationType, EnumerationDescription enumerationDescription) {
&nbsp;                    this(annotationType, FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType().asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                public Factory(Class&lt;T&gt; annotationType, ConstantValue constant) {
&nbsp;                    this(annotationType, constant.toStackManipulation(), constant.getTypeDescription().asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                public Factory(Class&lt;T&gt; annotationType, StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.stackManipulation = stackManipulation;
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                public static &lt;S extends Annotation&gt; Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, @MaybeNull Object value) {
&nbsp;                    return (Factory&lt;S&gt;)(value == null ? new OfDefaultValue(annotationType) : new Factory(annotationType, net.bytebuddy.utility.ConstantValue.Simple.wrap(value)));
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    return new ForStackManipulation(this.stackManipulation, this.typeDescription, target.getType(), Typing.STATIC);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationType.equals(((Factory)var1).annotationType)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.stackManipulation.equals(((Factory)var1).stackManipulation)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typeDescription.equals(((Factory)var1).typeDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.stackManipulation.hashCode()) * 31 + this.typeDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class OfDefaultValue&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                public OfDefaultValue(Class&lt;T&gt; annotationType) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    return new ForStackManipulation(DefaultValue.of(target.getType()), target.getType(), target.getType(), Typing.STATIC);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.annotationType.equals(((OfDefaultValue)var1).annotationType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.annotationType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class OfAnnotationProperty&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;                private final MethodDescription.InDefinedShape property;
&nbsp;
&nbsp;                protected OfAnnotationProperty(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape property) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.property = property;
&nbsp;                }
&nbsp;
&nbsp;                public static &lt;S extends Annotation&gt; Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, String property) {
&nbsp;                    if (!annotationType.isAnnotation()) {
&nbsp;                        throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return new OfAnnotationProperty&lt;S&gt;(annotationType, new MethodDescription.ForLoadedMethod(annotationType.getMethod(property)));
&nbsp;                        } catch (NoSuchMethodException exception) {
&nbsp;                            throw new IllegalArgumentException(&quot;Cannot find a property &quot; + property + &quot; on &quot; + annotationType, exception);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    ConstantValue value = net.bytebuddy.utility.ConstantValue.Simple.wrapOrNull(annotation.getValue(this.property).resolve());
&nbsp;                    if (value == null) {
&nbsp;                        throw new IllegalStateException(&quot;Property does not represent a constant value: &quot; + this.property);
&nbsp;                    } else {
&nbsp;                        return new ForStackManipulation(value.toStackManipulation(), value.getTypeDescription().asGenericType(), target.getType(), Typing.STATIC);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationType.equals(((OfAnnotationProperty)var1).annotationType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.property.equals(((OfAnnotationProperty)var1).property);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.property.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class OfDynamicInvocation&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;                private final List&lt;? extends JavaConstant&gt; arguments;
&nbsp;
&nbsp;                public OfDynamicInvocation(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape bootstrapMethod, List&lt;? extends JavaConstant&gt; arguments) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.bootstrapMethod = bootstrapMethod;
&nbsp;                    this.arguments = arguments;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    if (!target.getType().isInterface()) {
&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; is not an interface&quot;);
&nbsp;                    } else if (!target.getType().getInterfaces().isEmpty()) {
&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; must not extend other interfaces&quot;);
&nbsp;                    } else if (!target.getType().isPublic()) {
&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; is mot public&quot;);
&nbsp;                    } else {
&nbsp;                        MethodList&lt;?&gt; methodCandidates = (MethodList)target.getType().getDeclaredMethods().filter(ElementMatchers.isAbstract());
&nbsp;                        if (methodCandidates.size() != 1) {
&nbsp;                            throw new IllegalArgumentException(target.getType() + &quot; must declare exactly one abstract method&quot;);
&nbsp;                        } else {
&nbsp;                            return new ForStackManipulation(MethodInvocation.invoke(this.bootstrapMethod).dynamic(((MethodDescription)methodCandidates.getOnly()).getInternalName(), target.getType().asErasure(), Collections.emptyList(), this.arguments), target.getType(), target.getType(), Typing.STATIC);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationType.equals(((OfDynamicInvocation)var1).annotationType)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.bootstrapMethod.equals(((OfDynamicInvocation)var1).bootstrapMethod)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.arguments.equals(((OfDynamicInvocation)var1).arguments);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.bootstrapMethod.hashCode()) * 31 + this.arguments.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class ForSerializedValue implements OffsetMapping {
&nbsp;            private final TypeDescription.Generic target;
&nbsp;            private final TypeDescription typeDescription;
&nbsp;            private final StackManipulation deserialization;
&nbsp;
&nbsp;            public ForSerializedValue(TypeDescription.Generic target, TypeDescription typeDescription, StackManipulation deserialization) {
&nbsp;                this.target = target;
&nbsp;                this.typeDescription = typeDescription;
&nbsp;                this.deserialization = deserialization;
&nbsp;            }
&nbsp;
&nbsp;            public Target resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, Sort sort) {
&nbsp;                StackManipulation assignment = assigner.assign(this.typeDescription.asGenericType(), this.target, Typing.DYNAMIC);
&nbsp;                if (!assignment.isValid()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + this.typeDescription + &quot; to &quot; + this.target);
&nbsp;                } else {
&nbsp;                    return new Target.ForStackManipulation(new StackManipulation.Compound(new StackManipulation[]{this.deserialization, assignment}));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.target.equals(((ForSerializedValue)var1).target)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typeDescription.equals(((ForSerializedValue)var1).typeDescription)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.deserialization.equals(((ForSerializedValue)var1).deserialization);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.typeDescription.hashCode()) * 31 + this.deserialization.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Factory&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                private final StackManipulation deserialization;
&nbsp;
&nbsp;                protected Factory(Class&lt;T&gt; annotationType, TypeDescription typeDescription, StackManipulation deserialization) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.deserialization = deserialization;
&nbsp;                }
&nbsp;
&nbsp;                public static &lt;S extends Annotation, U extends Serializable&gt; Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, U target, Class&lt;? super U&gt; targetType) {
&nbsp;                    if (!targetType.isInstance(target)) {
&nbsp;                        throw new IllegalArgumentException(target + &quot; is no instance of &quot; + targetType);
&nbsp;                    } else {
&nbsp;                        return new Factory&lt;S&gt;(annotationType, ForLoadedType.of(targetType), SerializedConstant.of(target));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, Factory.AdviceType adviceType) {
&nbsp;                    return new ForSerializedValue(target.getType(), this.typeDescription, this.deserialization);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationType.equals(((Factory)var1).annotationType)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeDescription.equals(((Factory)var1).typeDescription)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.deserialization.equals(((Factory)var1).deserialization);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.typeDescription.hashCode()) * 31 + this.deserialization.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory&lt;T extends Annotation&gt; {
&nbsp;            Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;            OffsetMapping make(ParameterDescription.InDefinedShape var1, AnnotationDescription.Loadable&lt;T&gt; var2, AdviceType var3);
&nbsp;
&nbsp;            public static enum AdviceType {
&nbsp;                DELEGATION(true),
&nbsp;                INLINING(false);
&nbsp;
&nbsp;                private final boolean delegation;
&nbsp;
&nbsp;                private AdviceType(boolean delegation) {
&nbsp;                    this.delegation = delegation;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isDelegation() {
&nbsp;                    return this.delegation;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Simple&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;                private final OffsetMapping offsetMapping;
&nbsp;
&nbsp;                public Simple(Class&lt;T&gt; annotationType, OffsetMapping offsetMapping) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                    this.offsetMapping = offsetMapping;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
&nbsp;                    return this.offsetMapping;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.annotationType.equals(((Simple)var1).annotationType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.offsetMapping.equals(((Simple)var1).offsetMapping);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.offsetMapping.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Illegal&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                public Illegal(Class&lt;T&gt; annotationType) {
&nbsp;                    this.annotationType = annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
&nbsp;                    return this.annotationType;
&nbsp;                }
&nbsp;
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
&nbsp;                    throw new IllegalStateException(&quot;Usage of &quot; + this.annotationType + &quot; is not allowed on &quot; + target);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.annotationType.equals(((Illegal)var1).annotationType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.annotationType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Target {
&nbsp;            StackManipulation resolveRead();
&nbsp;
&nbsp;            StackManipulation resolveWrite();
&nbsp;
&nbsp;            StackManipulation resolveIncrement(int var1);
&nbsp;
&nbsp;            public abstract static class AbstractReadOnlyAdapter implements Target {
&nbsp;                public AbstractReadOnlyAdapter() {
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveWrite() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot write to read-only value&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveIncrement(int value) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot write to read-only value&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class ForDefaultValue implements Target {
&nbsp;                protected final TypeDefinition typeDefinition;
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForDefaultValue(TypeDefinition typeDefinition, StackManipulation readAssignment) {
&nbsp;                    this.typeDefinition = typeDefinition;
&nbsp;                    this.readAssignment = readAssignment;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveRead() {
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{DefaultValue.of(this.typeDefinition), this.readAssignment});
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeDefinition.equals(((ForDefaultValue)var1).typeDefinition)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.readAssignment.equals(((ForDefaultValue)var1).readAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.typeDefinition.hashCode()) * 31 + this.readAssignment.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends ForDefaultValue {
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition) {
&nbsp;                        this(typeDefinition, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, StackManipulation readAssignment) {
&nbsp;                        super(typeDefinition, readAssignment);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only default value&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only default value&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadWrite extends ForDefaultValue {
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition) {
&nbsp;                        this(typeDefinition, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, StackManipulation readAssignment) {
&nbsp;                        super(typeDefinition, readAssignment);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        return Removal.of(this.typeDefinition);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        return net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class ForVariable implements Target {
&nbsp;                protected final TypeDefinition typeDefinition;
&nbsp;                protected final int offset;
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForVariable(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {
&nbsp;                    this.typeDefinition = typeDefinition;
&nbsp;                    this.offset = offset;
&nbsp;                    this.readAssignment = readAssignment;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveRead() {
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.of(this.typeDefinition).loadFrom(this.offset), this.readAssignment});
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (this.offset != ((ForVariable)var1).offset) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeDefinition.equals(((ForVariable)var1).typeDefinition)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.readAssignment.equals(((ForVariable)var1).readAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.typeDefinition.hashCode()) * 31 + this.offset) * 31 + this.readAssignment.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends ForVariable {
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, int offset) {
&nbsp;                        this(typeDefinition, offset, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {
&nbsp;                        super(typeDefinition, offset, readAssignment);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only parameter &quot; + this.typeDefinition + &quot; at &quot; + this.offset);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only variable &quot; + this.typeDefinition + &quot; at &quot; + this.offset);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ReadWrite extends ForVariable {
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, int offset) {
&nbsp;                        this(typeDefinition, offset, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment, StackManipulation writeAssignment) {
&nbsp;                        super(typeDefinition, offset, readAssignment);
&nbsp;                        this.writeAssignment = writeAssignment;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{this.writeAssignment, MethodVariableAccess.of(this.typeDefinition).storeAt(this.offset)});
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        return (StackManipulation)(this.typeDefinition.represents(Integer.TYPE) ? MethodVariableAccess.of(this.typeDefinition).increment(this.offset, value) : new StackManipulation.Compound(new StackManipulation[]{this.resolveRead(), IntegerConstant.forValue(1), Addition.INTEGER, this.resolveWrite()}));
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.writeAssignment.equals(((ReadWrite)var1).writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.writeAssignment.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class ForArray implements Target {
&nbsp;                protected final TypeDescription.Generic target;
&nbsp;                protected final List&lt;? extends StackManipulation&gt; valueReads;
&nbsp;
&nbsp;                protected ForArray(TypeDescription.Generic target, List&lt;? extends StackManipulation&gt; valueReads) {
&nbsp;                    this.target = target;
&nbsp;                    this.valueReads = valueReads;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveRead() {
&nbsp;                    return ArrayFactory.forType(this.target).withValues(this.valueReads);
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveIncrement(int value) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot increment read-only array value&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.target.equals(((ForArray)var1).target)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.valueReads.equals(((ForArray)var1).valueReads);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.target.hashCode()) * 31 + this.valueReads.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends ForArray {
&nbsp;                    public ReadOnly(TypeDescription.Generic target, List&lt;? extends StackManipulation&gt; valueReads) {
&nbsp;                        super(target, valueReads);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only array value&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ReadWrite extends ForArray {
&nbsp;                    private final List&lt;? extends StackManipulation&gt; valueWrites;
&nbsp;
&nbsp;                    public ReadWrite(TypeDescription.Generic target, List&lt;? extends StackManipulation&gt; valueReads, List&lt;? extends StackManipulation&gt; valueWrites) {
&nbsp;                        super(target, valueReads);
&nbsp;                        this.valueWrites = valueWrites;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{ArrayAccess.of(this.target).forEach(this.valueWrites), Removal.SINGLE});
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.valueWrites.equals(((ReadWrite)var1).valueWrites);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.valueWrites.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class ForField implements Target {
&nbsp;                protected final FieldDescription fieldDescription;
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                protected ForField(FieldDescription fieldDescription, StackManipulation readAssignment) {
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                    this.readAssignment = readAssignment;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveRead() {
&nbsp;                    return new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(this.fieldDescription.isStatic() ? net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE : MethodVariableAccess.loadThis()), FieldAccess.forField(this.fieldDescription).read(), this.readAssignment});
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.fieldDescription.equals(((ForField)var1).fieldDescription)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.readAssignment.equals(((ForField)var1).readAssignment);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.fieldDescription.hashCode()) * 31 + this.readAssignment.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                public static class ReadOnly extends ForField {
&nbsp;                    public ReadOnly(FieldDescription fieldDescription) {
&nbsp;                        this(fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadOnly(FieldDescription fieldDescription, StackManipulation readAssignment) {
&nbsp;                        super(fieldDescription, readAssignment);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only field value&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only field value&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WriteOnly implements Target {
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    protected WriteOnly(FieldDescription fieldDescription, StackManipulation writeAssignment) {
&nbsp;                        this.fieldDescription = fieldDescription;
&nbsp;                        this.writeAssignment = writeAssignment;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveRead() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot read write-only field value&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        StackManipulation preparation;
&nbsp;                        if (this.fieldDescription.isStatic()) {
&nbsp;                            preparation = net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;                        } else {
&nbsp;                            preparation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.loadThis(), Duplication.SINGLE.flipOver(this.fieldDescription.getType()), Removal.SINGLE});
&nbsp;                        }
&nbsp;
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{this.writeAssignment, preparation, FieldAccess.forField(this.fieldDescription).write()});
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot increment write-only field value&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.fieldDescription.equals(((WriteOnly)var1).fieldDescription)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.writeAssignment.equals(((WriteOnly)var1).writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.fieldDescription.hashCode()) * 31 + this.writeAssignment.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ReadWrite extends ForField {
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    public ReadWrite(FieldDescription fieldDescription) {
&nbsp;                        this(fieldDescription, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE, net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public ReadWrite(FieldDescription fieldDescription, StackManipulation readAssignment, StackManipulation writeAssignment) {
&nbsp;                        super(fieldDescription, readAssignment);
&nbsp;                        this.writeAssignment = writeAssignment;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        StackManipulation preparation;
&nbsp;                        if (this.fieldDescription.isStatic()) {
&nbsp;                            preparation = net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;                        } else {
&nbsp;                            preparation = new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.loadThis(), Duplication.SINGLE.flipOver(this.fieldDescription.getType()), Removal.SINGLE});
&nbsp;                        }
&nbsp;
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{this.writeAssignment, preparation, FieldAccess.forField(this.fieldDescription).write()});
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        return new StackManipulation.Compound(new StackManipulation[]{this.resolveRead(), IntegerConstant.forValue(value), Addition.INTEGER, this.resolveWrite()});
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.writeAssignment.equals(((ReadWrite)var1).writeAssignment);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.writeAssignment.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForStackManipulation implements Target {
&nbsp;                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                public ForStackManipulation(StackManipulation stackManipulation) {
&nbsp;                    this.stackManipulation = stackManipulation;
&nbsp;                }
&nbsp;
&nbsp;                public static Target of(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                    return new ForStackManipulation(MethodConstant.of(methodDescription));
&nbsp;                }
&nbsp;
&nbsp;                public static Target of(TypeDescription typeDescription) {
&nbsp;                    return new ForStackManipulation(ClassConstant.of(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                public static Target of(@MaybeNull Object value) {
&nbsp;                    return new ForStackManipulation((StackManipulation)(value == null ? NullConstant.INSTANCE : net.bytebuddy.utility.ConstantValue.Simple.wrap(value).toStackManipulation()));
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveRead() {
&nbsp;                    return this.stackManipulation;
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveWrite() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot write to constant value: &quot; + this.stackManipulation);
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation resolveIncrement(int value) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot write to constant value: &quot; + this.stackManipulation);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.stackManipulation.equals(((ForStackManipulation)var1).stackManipulation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.stackManipulation.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Writable implements Target {
&nbsp;                    private final StackManipulation read;
&nbsp;                    private final StackManipulation write;
&nbsp;
&nbsp;                    public Writable(StackManipulation read, StackManipulation write) {
&nbsp;                        this.read = read;
&nbsp;                        this.write = write;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveRead() {
&nbsp;                        return this.read;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        return this.write;
&nbsp;                    }
&nbsp;
&nbsp;                    public StackManipulation resolveIncrement(int value) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot increment mutable constant value: &quot; + this.write);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.read.equals(((Writable)var1).read)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.write.equals(((Writable)var1).write);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.read.hashCode()) * 31 + this.write.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;    public @interface OnMethodEnter {
&nbsp;        Class&lt;?&gt; skipOn() default void.class;
&nbsp;
&nbsp;        int skipOnIndex() default -1;
&nbsp;
&nbsp;        boolean prependLineNumber() default true;
&nbsp;
&nbsp;        boolean inline() default true;
&nbsp;
&nbsp;        Class&lt;? extends Throwable&gt; suppress() default NoExceptionHandler.class;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.METHOD})
&nbsp;    public @interface OnMethodExit {
&nbsp;        Class&lt;?&gt; repeatOn() default void.class;
&nbsp;
&nbsp;        int repeatOnIndex() default -1;
&nbsp;
&nbsp;        Class&lt;? extends Throwable&gt; onThrowable() default NoExceptionHandler.class;
&nbsp;
&nbsp;        boolean backupArguments() default true;
&nbsp;
<b class="fc">&nbsp;        boolean inline() default true;</b>
&nbsp;
&nbsp;        Class&lt;? extends Throwable&gt; suppress() default NoExceptionHandler.class;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @Documented</b>
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
<b class="nc">&nbsp;    public @interface Origin {</b>
&nbsp;        String DEFAULT = &quot;&quot;;
&nbsp;
&nbsp;        String value() default &quot;&quot;;
&nbsp;    }
&nbsp;
&nbsp;    public interface PostProcessor {
<b class="fc">&nbsp;        StackManipulation resolve(TypeDescription var1, MethodDescription var2, Assigner var3, ArgumentHandler var4, StackMapFrameHandler.ForPostProcessor var5, StackManipulation var6);</b>
&nbsp;
&nbsp;        public static enum NoOp implements PostProcessor, Factory {
&nbsp;            INSTANCE;
<b class="nc">&nbsp;</b>
&nbsp;            private NoOp() {
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
&nbsp;                return net.bytebuddy.implementation.bytecode.StackManipulation.Trivial.INSTANCE;
&nbsp;            }
&nbsp;
&nbsp;            public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
&nbsp;                return this;
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Enhance
&nbsp;        public static class Compound implements PostProcessor {
<b class="nc">&nbsp;            private final List&lt;PostProcessor&gt; postProcessors;</b>
&nbsp;
&nbsp;            protected Compound(List&lt;PostProcessor&gt; postProcessors) {
&nbsp;                this.postProcessors = postProcessors;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, ArgumentHandler argumentHandler, StackMapFrameHandler.ForPostProcessor stackMapFrameHandler, StackManipulation exceptionHandler) {
&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList(this.postProcessors.size());
&nbsp;
&nbsp;                for(PostProcessor postProcessor : this.postProcessors) {
&nbsp;                    stackManipulations.add(postProcessor.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler));
&nbsp;                }
&nbsp;
&nbsp;                return new StackManipulation.Compound(stackManipulations);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.postProcessors.equals(((Compound)var1).postProcessors);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.postProcessors.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            PostProcessor make(MethodDescription.InDefinedShape var1, boolean var2);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Compound implements Factory {
&nbsp;                private final List&lt;Factory&gt; factories;
&nbsp;
&nbsp;                public Compound(Factory... factory) {
&nbsp;                    this(Arrays.asList(factory));
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public Compound(List&lt;? extends Factory&gt; factories) {
&nbsp;                    this.factories = new ArrayList();
&nbsp;
&nbsp;                    for(Factory factory : factories) {
&nbsp;                        if (factory instanceof Compound) {
<b class="nc">&nbsp;                            this.factories.addAll(((Compound)factory).factories);</b>
&nbsp;                        } else if (!(factory instanceof NoOp)) {
&nbsp;                            this.factories.add(factory);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
&nbsp;                    List&lt;PostProcessor&gt; postProcessors = new ArrayList(this.factories.size());
&nbsp;
&nbsp;                    for(Factory factory : this.factories) {
&nbsp;                        postProcessors.add(factory.make(advice, exit));
&nbsp;                    }
&nbsp;
&nbsp;                    return new Compound(postProcessors);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.factories.equals(((Compound)var1).factories);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.factories.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface Return {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface SelfCallHandle {
&nbsp;        boolean bound() default true;
&nbsp;    }
&nbsp;
&nbsp;    public interface StackMapFrameHandler {
&nbsp;        void translateFrame(MethodVisitor var1, int var2, int var3, @MaybeNull Object[] var4, int var5, @MaybeNull Object[] var6);
&nbsp;
&nbsp;        void injectReturnFrame(MethodVisitor var1);
&nbsp;
&nbsp;        void injectExceptionFrame(MethodVisitor var1);
&nbsp;
&nbsp;        void injectCompletionFrame(MethodVisitor var1);
&nbsp;
&nbsp;        public static enum NoOp implements ForInstrumentedMethod, ForAdvice {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() {
&nbsp;            }
&nbsp;
&nbsp;            public ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public int getReaderHint() {
&nbsp;                return 4;
&nbsp;            }
&nbsp;
&nbsp;            public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectReturnFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectExceptionFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectInitializationFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;            }
&nbsp;
&nbsp;            public void injectIntermediateFrame(MethodVisitor methodVisitor, List&lt;? extends TypeDescription&gt; stack) {
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class Default implements ForInstrumentedMethod {
&nbsp;            protected static final Object[] EMPTY = new Object[0];
&nbsp;            protected final TypeDescription instrumentedType;
&nbsp;            protected final MethodDescription instrumentedMethod;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; initialTypes;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; latentTypes;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; preMethodTypes;
&nbsp;            protected final List&lt;? extends TypeDescription&gt; postMethodTypes;
&nbsp;            protected final boolean expandFrames;
&nbsp;            protected int currentFrameDivergence;
&nbsp;
&nbsp;            protected Default(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; latentTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean expandFrames) {
&nbsp;                this.instrumentedType = instrumentedType;
&nbsp;                this.instrumentedMethod = instrumentedMethod;
&nbsp;                this.initialTypes = initialTypes;
&nbsp;                this.latentTypes = latentTypes;
&nbsp;                this.preMethodTypes = preMethodTypes;
&nbsp;                this.postMethodTypes = postMethodTypes;
&nbsp;                this.expandFrames = expandFrames;
&nbsp;            }
&nbsp;
&nbsp;            protected static ForInstrumentedMethod of(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; latentTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean exitAdvice, boolean copyArguments, ClassFileVersion classFileVersion, int writerFlags, int readerFlags) {
&nbsp;                if ((writerFlags &amp; 2) == 0 &amp;&amp; !classFileVersion.isLessThan(ClassFileVersion.JAVA_V6)) {
&nbsp;                    if (!exitAdvice &amp;&amp; initialTypes.isEmpty()) {
&nbsp;                        return new Trivial(instrumentedType, instrumentedMethod, latentTypes, (readerFlags &amp; 8) != 0);
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return (ForInstrumentedMethod)(copyArguments ? new WithPreservedArguments.WithArgumentCopy(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, (readerFlags &amp; 8) != 0) : new WithPreservedArguments.WithoutArgumentCopy(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, (readerFlags &amp; 8) != 0, !instrumentedMethod.isConstructor()));
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return Advice.StackMapFrameHandler.NoOp.INSTANCE;
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                return new ForAdvice(adviceMethod, this.initialTypes, this.latentTypes, this.preMethodTypes, Advice.StackMapFrameHandler.Default.TranslationMode.ENTER, this.instrumentedMethod.isConstructor() ? Advice.StackMapFrameHandler.Default.Initialization.UNITIALIZED : Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED);
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public int getReaderHint() {
&nbsp;                return this.expandFrames ? 8 : 0;
&nbsp;            }
&nbsp;
&nbsp;            protected void translateFrame(MethodVisitor methodVisitor, TranslationMode translationMode, MethodDescription methodDescription, List&lt;? extends TypeDescription&gt; additionalTypes, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                switch (type) {
&nbsp;                    case -1:
<b class="nc">&nbsp;                    case 0:</b>
&nbsp;                        if (methodDescription.getParameters().size() + (methodDescription.isStatic() ? 0 : 1) &gt; localVariableLength) {
&nbsp;                            throw new IllegalStateException(&quot;Inconsistent frame length for &quot; + methodDescription + &quot;: &quot; + localVariableLength);
&nbsp;                        }
&nbsp;
&nbsp;                        int offset;
&nbsp;                        if (methodDescription.isStatic()) {
<b class="nc">&nbsp;                            offset = 0;</b>
&nbsp;                        } else {
&nbsp;                            if (!translationMode.isPossibleThisFrameValue(this.instrumentedType, this.instrumentedMethod, localVariable[0])) {
&nbsp;                                throw new IllegalStateException(methodDescription + &quot; is inconsistent for &#39;this&#39; reference: &quot; + localVariable[0]);
&nbsp;                            }
&nbsp;
&nbsp;                            offset = 1;
&nbsp;                        }
&nbsp;
&nbsp;                        for(int index = 0; index &lt; methodDescription.getParameters().size(); ++index) {
&nbsp;                            if (!Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(((ParameterDescription)methodDescription.getParameters().get(index)).getType().asErasure()).equals(localVariable[index + offset])) {
<b class="nc">&nbsp;                                throw new IllegalStateException(methodDescription + &quot; is inconsistent at &quot; + index + &quot;: &quot; + localVariable[index + offset]);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        Object[] translated = new Object[localVariableLength - (methodDescription.isStatic() ? 0 : 1) - methodDescription.getParameters().size() + (this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size() + additionalTypes.size()];
&nbsp;                        int index = translationMode.copy(this.instrumentedType, this.instrumentedMethod, methodDescription, localVariable, translated);
&nbsp;
&nbsp;                        for(TypeDescription typeDescription : additionalTypes) {
&nbsp;                            translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (translated.length != index) {</b>
&nbsp;                            System.arraycopy(localVariable, methodDescription.getParameters().size() + (methodDescription.isStatic() ? 0 : 1), translated, index, translated.length - index);
&nbsp;                        }
&nbsp;
&nbsp;                        localVariableLength = translated.length;
&nbsp;                        localVariable = translated;
&nbsp;                        this.currentFrameDivergence = translated.length - index;
&nbsp;                        break;
&nbsp;                    case 1:
&nbsp;                        this.currentFrameDivergence += localVariableLength;
&nbsp;                        break;
&nbsp;                    case 2:
&nbsp;                        this.currentFrameDivergence -= localVariableLength;
&nbsp;                        if (this.currentFrameDivergence &lt; 0) {
&nbsp;                            throw new IllegalStateException(methodDescription + &quot; dropped &quot; + Math.abs(this.currentFrameDivergence) + &quot; implicit frames&quot;);
&nbsp;                        }
&nbsp;                    case 3:
&nbsp;                    case 4:
&nbsp;                        break;
<b class="nc">&nbsp;                    default:</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Unexpected frame type: &quot; + type);</b>
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
&nbsp;            }
&nbsp;
&nbsp;            protected void injectFullFrame(MethodVisitor methodVisitor, Initialization initialization, List&lt;? extends TypeDescription&gt; typesInArray, List&lt;? extends TypeDescription&gt; typesOnStack) {
&nbsp;                Object[] localVariable = new Object[this.instrumentedMethod.getParameters().size() + (this.instrumentedMethod.isStatic() ? 0 : 1) + typesInArray.size()];
&nbsp;                int index = 0;
&nbsp;                if (!this.instrumentedMethod.isStatic()) {
<b class="pc">&nbsp;                    localVariable[index++] = initialization.toFrame(this.instrumentedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                for(TypeDescription typeDescription : typesInArray) {
&nbsp;                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                index = 0;
&nbsp;                Object[] stackType = new Object[typesOnStack.size()];
&nbsp;
&nbsp;                for(TypeDescription typeDescription : typesOnStack) {
&nbsp;                    stackType[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                methodVisitor.visitFrame(this.expandFrames ? -1 : 0, localVariable.length, localVariable, stackType.length, stackType);
&nbsp;                this.currentFrameDivergence = 0;
&nbsp;            }
&nbsp;
&nbsp;            protected static enum TranslationMode {
&nbsp;                COPY {
&nbsp;                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription methodDescription, Object[] localVariable, Object[] translated) {
&nbsp;                        int length = instrumentedMethod.getParameters().size() + (instrumentedMethod.isStatic() ? 0 : 1);
&nbsp;                        System.arraycopy(localVariable, 0, translated, 0, length);
&nbsp;                        return length;
&nbsp;                    }
&nbsp;
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
&nbsp;                        return instrumentedMethod.isConstructor() &amp;&amp; Opcodes.UNINITIALIZED_THIS.equals(frame) || Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
&nbsp;                    }
&nbsp;                },
&nbsp;                ENTER {
&nbsp;                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription methodDescription, Object[] localVariable, Object[] translated) {
&nbsp;                        int index = 0;
&nbsp;                        if (!instrumentedMethod.isStatic()) {
&nbsp;                            translated[index++] = instrumentedMethod.isConstructor() ? Opcodes.UNINITIALIZED_THIS : Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(instrumentedType);
&nbsp;                        }
&nbsp;
&nbsp;                        for(TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                            translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        return index;
&nbsp;                    }
&nbsp;
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
&nbsp;                        return instrumentedMethod.isConstructor() ? Opcodes.UNINITIALIZED_THIS.equals(frame) : Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
&nbsp;                    }
&nbsp;                },
&nbsp;                EXIT {
&nbsp;                    protected int copy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, MethodDescription methodDescription, Object[] localVariable, Object[] translated) {
&nbsp;                        int index = 0;
&nbsp;                        if (!instrumentedMethod.isStatic()) {
&nbsp;                            translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(instrumentedType);
&nbsp;                        }
&nbsp;
&nbsp;                        for(TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                            translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                        }
&nbsp;
&nbsp;                        return index;
&nbsp;                    }
&nbsp;
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
&nbsp;                        return Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private TranslationMode() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract int copy(TypeDescription var1, MethodDescription var2, MethodDescription var3, Object[] var4, Object[] var5);
&nbsp;
&nbsp;                protected abstract boolean isPossibleThisFrameValue(TypeDescription var1, MethodDescription var2, Object var3);
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Initialization {
&nbsp;                UNITIALIZED {
&nbsp;                    protected Object toFrame(TypeDescription typeDescription) {
&nbsp;                        if (typeDescription.isPrimitive()) {
&nbsp;                            throw new IllegalArgumentException(&quot;Cannot assume primitive uninitialized value: &quot; + typeDescription);
&nbsp;                        } else {
&nbsp;                            return Opcodes.UNINITIALIZED_THIS;
&nbsp;                        }
&nbsp;                    }
&nbsp;                },
&nbsp;                INITIALIZED {
&nbsp;                    protected Object toFrame(TypeDescription typeDescription) {
&nbsp;                        if (!typeDescription.represents(Boolean.TYPE) &amp;&amp; !typeDescription.represents(Byte.TYPE) &amp;&amp; !typeDescription.represents(Short.TYPE) &amp;&amp; !typeDescription.represents(Character.TYPE) &amp;&amp; !typeDescription.represents(Integer.TYPE)) {
&nbsp;                            if (typeDescription.represents(Long.TYPE)) {
&nbsp;                                return Opcodes.LONG;
&nbsp;                            } else if (typeDescription.represents(Float.TYPE)) {
&nbsp;                                return Opcodes.FLOAT;
&nbsp;                            } else {
&nbsp;                                return typeDescription.represents(Double.TYPE) ? Opcodes.DOUBLE : typeDescription.getInternalName();
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            return Opcodes.INTEGER;
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                private Initialization() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Object toFrame(TypeDescription var1);
&nbsp;            }
&nbsp;
&nbsp;            protected static class Trivial extends Default {
&nbsp;                protected Trivial(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; latentTypes, boolean expandFrames) {
&nbsp;                    super(instrumentedType, instrumentedMethod, Collections.emptyList(), latentTypes, Collections.emptyList(), Collections.emptyList(), expandFrames);
&nbsp;                }
&nbsp;
&nbsp;                public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                    methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect exit advice &quot; + adviceMethod + &quot; for &quot; + this.instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect return frame for &quot; + this.instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect exception frame for &quot; + this.instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect completion frame for &quot; + this.instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect post completion frame for &quot; + this.instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                public void injectInitializationFrame(MethodVisitor methodVisitor) {
&nbsp;                }
&nbsp;
&nbsp;                public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class WithPreservedArguments extends Default {
&nbsp;                protected boolean allowCompactCompletionFrame;
&nbsp;
&nbsp;                protected WithPreservedArguments(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; latentTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) {
&nbsp;                    super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames);
&nbsp;                    this.allowCompactCompletionFrame = allowCompactCompletionFrame;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;},
&nbsp;                    justification = &quot;ASM models frames by reference identity.&quot;
&nbsp;                )
&nbsp;                protected void translateFrame(MethodVisitor methodVisitor, TranslationMode translationMode, MethodDescription methodDescription, List&lt;? extends TypeDescription&gt; additionalTypes, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                    if (type == 0 &amp;&amp; localVariableLength &gt; 0 &amp;&amp; localVariable[0] != Opcodes.UNINITIALIZED_THIS) {
&nbsp;                        this.allowCompactCompletionFrame = true;
&nbsp;                    }
&nbsp;
&nbsp;                    super.translateFrame(methodVisitor, translationMode, methodDescription, additionalTypes, type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                }
&nbsp;
&nbsp;                public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
&nbsp;                    return new ForAdvice(adviceMethod, CompoundList.of(this.initialTypes, this.preMethodTypes, this.postMethodTypes), Collections.emptyList(), Collections.emptyList(), Advice.StackMapFrameHandler.Default.TranslationMode.EXIT, Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED);
&nbsp;                }
&nbsp;
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
&nbsp;                    if (!this.expandFrames &amp;&amp; this.currentFrameDivergence == 0) {
&nbsp;                        if (this.instrumentedMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            methodVisitor.visitFrame(3, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitFrame(4, EMPTY.length, EMPTY, 1, new Object[]{Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedMethod.getReturnType().asErasure())});
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        this.injectFullFrame(methodVisitor, Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED, CompoundList.of(this.initialTypes, this.preMethodTypes), this.instrumentedMethod.getReturnType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(this.instrumentedMethod.getReturnType().asErasure()));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
&nbsp;                    if (!this.expandFrames &amp;&amp; this.currentFrameDivergence == 0) {
&nbsp;                        methodVisitor.visitFrame(4, EMPTY.length, EMPTY, 1, new Object[]{net.bytebuddy.jar.asm.Type.getInternalName(Throwable.class)});
&nbsp;                    } else {
&nbsp;                        this.injectFullFrame(methodVisitor, Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED, CompoundList.of(this.initialTypes, this.preMethodTypes), Collections.singletonList(ForLoadedType.of(Throwable.class)));
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (this.allowCompactCompletionFrame &amp;&amp; !this.expandFrames &amp;&amp; this.currentFrameDivergence == 0 &amp;&amp; this.postMethodTypes.size() &lt; 4) {</b>
&nbsp;                        if (this.postMethodTypes.isEmpty()) {
&nbsp;                            methodVisitor.visitFrame(3, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                        } else {
&nbsp;                            Object[] local = new Object[this.postMethodTypes.size()];
&nbsp;                            int index = 0;
<b class="nc">&nbsp;</b>
&nbsp;                            for(TypeDescription typeDescription : this.postMethodTypes) {
&nbsp;                                local[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            methodVisitor.visitFrame(1, local.length, local, EMPTY.length, EMPTY);
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        this.injectFullFrame(methodVisitor, Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED, CompoundList.of(this.initialTypes, this.preMethodTypes, this.postMethodTypes), Collections.emptyList());
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!this.expandFrames &amp;&amp; this.currentFrameDivergence == 0) {</b>
&nbsp;                        methodVisitor.visitFrame(3, EMPTY.length, EMPTY, EMPTY.length, EMPTY);
&nbsp;                    } else {
&nbsp;                        this.injectFullFrame(methodVisitor, Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED, CompoundList.of(this.initialTypes, this.preMethodTypes, this.postMethodTypes), Collections.emptyList());
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                }
&nbsp;
&nbsp;                public void injectInitializationFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    if (!this.initialTypes.isEmpty()) {</b>
&nbsp;                        if (!this.expandFrames &amp;&amp; this.initialTypes.size() &lt; 4) {
&nbsp;                            Object[] localVariable = new Object[this.initialTypes.size()];
&nbsp;                            int index = 0;
&nbsp;
&nbsp;                            for(TypeDescription typeDescription : this.initialTypes) {
<b class="fc">&nbsp;                                localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            methodVisitor.visitFrame(1, localVariable.length, localVariable, EMPTY.length, EMPTY);
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            Object[] localVariable = new Object[(this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size() + this.initialTypes.size()];
&nbsp;                            int index = 0;
&nbsp;                            if (this.instrumentedMethod.isConstructor()) {
&nbsp;                                localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
&nbsp;                            } else if (!this.instrumentedMethod.isStatic()) {
<b class="fc">&nbsp;                                localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
<b class="nc">&nbsp;                                localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            for(TypeDescription typeDescription : this.initialTypes) {
&nbsp;                                localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                            }
<b class="fc">&nbsp;</b>
&nbsp;                            methodVisitor.visitFrame(this.expandFrames ? -1 : 0, localVariable.length, localVariable, EMPTY.length, EMPTY);
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                }
&nbsp;
&nbsp;                protected static class WithoutArgumentCopy extends WithPreservedArguments {
&nbsp;                    protected WithoutArgumentCopy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; latentTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean expandFrames, boolean allowCompactCompletionFrame) {
&nbsp;                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, allowCompactCompletionFrame);
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                        this.translateFrame(methodVisitor, Advice.StackMapFrameHandler.Default.TranslationMode.COPY, this.instrumentedMethod, CompoundList.of(this.initialTypes, this.preMethodTypes), type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected static class WithArgumentCopy extends WithPreservedArguments {</b>
&nbsp;                    protected WithArgumentCopy(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; initialTypes, List&lt;? extends TypeDescription&gt; latentTypes, List&lt;? extends TypeDescription&gt; preMethodTypes, List&lt;? extends TypeDescription&gt; postMethodTypes, boolean expandFrames) {
&nbsp;                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, true);
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                        if (!this.instrumentedMethod.isStatic() || !this.instrumentedMethod.getParameters().isEmpty()) {
&nbsp;                            if (!this.expandFrames &amp;&amp; (this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size() &lt; 4) {
&nbsp;                                Object[] localVariable = new Object[(this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size()];
&nbsp;                                int index = 0;
<b class="fc">&nbsp;                                if (this.instrumentedMethod.isConstructor()) {</b>
&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
&nbsp;                                } else if (!this.instrumentedMethod.isStatic()) {
<b class="nc">&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedType);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                methodVisitor.visitFrame(1, localVariable.length, localVariable, EMPTY.length, EMPTY);
<b class="fc">&nbsp;                            } else {</b>
&nbsp;                                Object[] localVariable = new Object[(this.instrumentedMethod.isStatic() ? 0 : 2) + this.instrumentedMethod.getParameters().size() * 2 + this.initialTypes.size() + this.preMethodTypes.size()];
&nbsp;                                int index = 0;
<b class="nc">&nbsp;                                if (this.instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;</b>
&nbsp;                                } else if (!this.instrumentedMethod.isStatic()) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedType);
&nbsp;                                }
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
<b class="fc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.initialTypes) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
<b class="nc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.preMethodTypes) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                if (this.instrumentedMethod.isConstructor()) {
&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;
&nbsp;                                } else if (!this.instrumentedMethod.isStatic()) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedType);
&nbsp;                                }
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                                    localVariable[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                methodVisitor.visitFrame(this.expandFrames ? -1 : 0, localVariable.length, localVariable, EMPTY.length, EMPTY);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        this.currentFrameDivergence = (this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size();
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;},
&nbsp;                        justification = &quot;ASM models frames by reference identity.&quot;
&nbsp;                    )
&nbsp;                    public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                        switch (type) {
&nbsp;                            case -1:
&nbsp;                            case 0:
&nbsp;                                Object[] translated = new Object[localVariableLength + (this.instrumentedMethod.isStatic() ? 0 : 1) + this.instrumentedMethod.getParameters().size() + this.initialTypes.size() + this.preMethodTypes.size()];
&nbsp;                                int index = 0;
&nbsp;                                if (!this.instrumentedMethod.isConstructor()) {
&nbsp;                                    if (!this.instrumentedMethod.isStatic()) {
&nbsp;                                        translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.instrumentedType);
&nbsp;                                    }
<b class="fc">&nbsp;                                } else {</b>
<b class="fc">&nbsp;                                    Initialization initialization = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                                    for(int variableIndex = 0; variableIndex &lt; localVariableLength; ++variableIndex) {</b>
<b class="fc">&nbsp;                                        if (localVariable[variableIndex] == Opcodes.UNINITIALIZED_THIS) {</b>
<b class="fc">&nbsp;                                            initialization = Advice.StackMapFrameHandler.Default.Initialization.UNITIALIZED;</b>
&nbsp;                                            break;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    translated[index++] = initialization.toFrame(this.instrumentedType);
&nbsp;                                }
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.instrumentedMethod.getParameters().asTypeList().asErasures()) {
&nbsp;                                    translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                for(TypeDescription typeDescription : this.initialTypes) {
<b class="fc">&nbsp;                                    translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                                for(TypeDescription typeDescription : this.preMethodTypes) {</b>
<b class="pc">&nbsp;                                    translated[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="nc">&nbsp;                                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                                if (localVariableLength &gt; 0) {</b>
<b class="pc">&nbsp;                                    System.arraycopy(localVariable, 0, translated, index, localVariableLength);</b>
<b class="nc">&nbsp;                                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                                localVariableLength = translated.length;</b>
<b class="pc">&nbsp;                                localVariable = translated;</b>
<b class="nc">&nbsp;                                this.currentFrameDivergence = localVariableLength;</b>
<b class="pc">&nbsp;                                break;</b>
<b class="nc">&nbsp;                            case 1:</b>
<b class="pc">&nbsp;                                this.currentFrameDivergence += localVariableLength;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case 2:
<b class="fc">&nbsp;                                this.currentFrameDivergence -= localVariableLength;</b>
&nbsp;                            case 3:
<b class="pc">&nbsp;                            case 4:</b>
&nbsp;                                break;
&nbsp;                            default:
&nbsp;                                throw new IllegalArgumentException(&quot;Unexpected frame type: &quot; + type);
&nbsp;                        }
&nbsp;
&nbsp;                        if (this.instrumentedMethod.isConstructor() &amp;&amp; this.currentFrameDivergence &lt; this.instrumentedMethod.getStackSize()) {
&nbsp;                            throw new IllegalStateException(this.instrumentedMethod + &quot; dropped implicit &#39;this&#39; frame&quot;);
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected class ForAdvice implements ForAdvice {
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;                protected final List&lt;? extends TypeDescription&gt; startTypes;
&nbsp;                private final List&lt;? extends TypeDescription&gt; intermediateTypes;
&nbsp;                protected final List&lt;? extends TypeDescription&gt; endTypes;
&nbsp;                protected final TranslationMode translationMode;
&nbsp;                private final Initialization initialization;
&nbsp;                private boolean intermedate;
&nbsp;
&nbsp;                protected ForAdvice(MethodDescription.InDefinedShape adviceMethod, List&lt;? extends TypeDescription&gt; startTypes, List&lt;? extends TypeDescription&gt; intermediateTypes, List&lt;? extends TypeDescription&gt; endTypes, TranslationMode translationMode, Initialization initialization) {
&nbsp;                    this.adviceMethod = adviceMethod;
&nbsp;                    this.startTypes = startTypes;
&nbsp;                    this.intermediateTypes = intermediateTypes;
&nbsp;                    this.endTypes = endTypes;
&nbsp;                    this.translationMode = translationMode;
&nbsp;                    this.initialization = initialization;
&nbsp;                    this.intermedate = false;
&nbsp;                }
&nbsp;
&nbsp;                public void translateFrame(MethodVisitor methodVisitor, int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
&nbsp;                    Default.this.translateFrame(methodVisitor, this.translationMode, this.adviceMethod, this.startTypes, type, localVariableLength, localVariable, stackSize, stack);
&nbsp;                }
&nbsp;
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
&nbsp;                    if (!Default.this.expandFrames &amp;&amp; Default.this.currentFrameDivergence == 0) {
&nbsp;                        if (this.adviceMethod.getReturnType().represents(Void.TYPE)) {
&nbsp;                            methodVisitor.visitFrame(3, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitFrame(4, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, 1, new Object[]{Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(this.adviceMethod.getReturnType().asErasure())});
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, this.startTypes, this.adviceMethod.getReturnType().represents(Void.TYPE) ? Collections.emptyList() : Collections.singletonList(this.adviceMethod.getReturnType().asErasure()));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
&nbsp;                    if (!Default.this.expandFrames &amp;&amp; Default.this.currentFrameDivergence == 0) {
&nbsp;                        methodVisitor.visitFrame(4, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, 1, new Object[]{net.bytebuddy.jar.asm.Type.getInternalName(Throwable.class)});
&nbsp;                    } else {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, this.startTypes, Collections.singletonList(ForLoadedType.of(Throwable.class)));
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                }
&nbsp;
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;                    if (Default.this.expandFrames) {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, CompoundList.of(this.startTypes, this.endTypes), Collections.emptyList());
&nbsp;                    } else if (Default.this.currentFrameDivergence == 0 &amp;&amp; (this.intermedate || this.endTypes.size() &lt; 4)) {
<b class="nc">&nbsp;                        if (!this.intermedate &amp;&amp; !this.endTypes.isEmpty()) {</b>
&nbsp;                            Object[] local = new Object[this.endTypes.size()];
&nbsp;                            int index = 0;
&nbsp;
&nbsp;                            for(TypeDescription typeDescription : this.endTypes) {
&nbsp;                                local[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            methodVisitor.visitFrame(1, local.length, local, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitFrame(3, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        }
&nbsp;                    } else if (Default.this.currentFrameDivergence &lt; 3 &amp;&amp; this.endTypes.isEmpty()) {
&nbsp;                        methodVisitor.visitFrame(2, Default.this.currentFrameDivergence, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        Default.this.currentFrameDivergence = 0;
&nbsp;                    } else {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, CompoundList.of(this.startTypes, this.endTypes), Collections.emptyList());
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public void injectIntermediateFrame(MethodVisitor methodVisitor, List&lt;? extends TypeDescription&gt; stack) {
&nbsp;                    if (Default.this.expandFrames) {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, CompoundList.of(this.startTypes, this.intermediateTypes), stack);
&nbsp;                    } else if (this.intermedate &amp;&amp; stack.size() &lt; 2) {
&nbsp;                        if (stack.isEmpty()) {
&nbsp;                            methodVisitor.visitFrame(3, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        } else {
&nbsp;                            methodVisitor.visitFrame(4, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, 1, new Object[]{Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame((TypeDescription)stack.get(0))});
&nbsp;                        }
&nbsp;                    } else if (Default.this.currentFrameDivergence == 0 &amp;&amp; this.intermediateTypes.size() &lt; 4 &amp;&amp; (stack.isEmpty() || stack.size() &lt; 2 &amp;&amp; this.intermediateTypes.isEmpty())) {
&nbsp;                        if (this.intermediateTypes.isEmpty()) {
&nbsp;                            if (stack.isEmpty()) {
&nbsp;                                methodVisitor.visitFrame(3, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                            } else {
&nbsp;                                methodVisitor.visitFrame(4, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY, 1, new Object[]{Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame((TypeDescription)stack.get(0))});
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            Object[] local = new Object[this.intermediateTypes.size()];
&nbsp;                            int index = 0;
&nbsp;
&nbsp;                            for(TypeDescription typeDescription : this.intermediateTypes) {
&nbsp;                                local[index++] = Advice.StackMapFrameHandler.Default.Initialization.INITIALIZED.toFrame(typeDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            methodVisitor.visitFrame(1, local.length, local, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                        }
&nbsp;                    } else if (Default.this.currentFrameDivergence &lt; 3 &amp;&amp; this.intermediateTypes.isEmpty() &amp;&amp; stack.isEmpty()) {
&nbsp;                        methodVisitor.visitFrame(2, Default.this.currentFrameDivergence, Advice.StackMapFrameHandler.Default.EMPTY, Advice.StackMapFrameHandler.Default.EMPTY.length, Advice.StackMapFrameHandler.Default.EMPTY);
&nbsp;                    } else {
&nbsp;                        Default.this.injectFullFrame(methodVisitor, this.initialization, CompoundList.of(this.startTypes, this.intermediateTypes), stack);
&nbsp;                    }
&nbsp;
&nbsp;                    Default.this.currentFrameDivergence = this.intermediateTypes.size() - this.endTypes.size();
&nbsp;                    this.intermedate = true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface ForAdvice extends StackMapFrameHandler, ForPostProcessor {
&nbsp;        }
&nbsp;
&nbsp;        public interface ForInstrumentedMethod extends StackMapFrameHandler {
&nbsp;            ForAdvice bindEnter(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;            ForAdvice bindExit(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;            int getReaderHint();
&nbsp;
&nbsp;            void injectInitializationFrame(MethodVisitor var1);
&nbsp;
&nbsp;            void injectStartFrame(MethodVisitor var1);
&nbsp;
&nbsp;            void injectPostCompletionFrame(MethodVisitor var1);
&nbsp;        }
&nbsp;
&nbsp;        public interface ForPostProcessor {
&nbsp;            void injectIntermediateFrame(MethodVisitor var1, List&lt;? extends TypeDescription&gt; var2);
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Documented</b>
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface StubValue {
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface This {
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.STATIC;
&nbsp;
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
<b class="nc">&nbsp;    @Retention(RetentionPolicy.RUNTIME)</b>
<b class="nc">&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})</b>
<b class="nc">&nbsp;    public @interface Thrown {</b>
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        Assigner.Typing typing() default Typing.DYNAMIC;
&nbsp;    }
&nbsp;
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER})
&nbsp;    public @interface Unused {
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
