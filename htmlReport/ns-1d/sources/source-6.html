


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TypeList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: TypeList (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeList$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Empty</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$ForLoadedTypes</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$Empty</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForDetachedTypes</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForDetachedTypes$OfTypeVariables</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForDetachedTypes$OfTypeVariables$AttachedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForDetachedTypes$WithResolvedErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForLoadedTypes</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$ForLoadedTypes$OfTypeVariables</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$OfConstructorExceptionTypes</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$OfLoadedInterfaceTypes</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$OfLoadedInterfaceTypes$TypeProjection</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$OfMethodExceptionTypes</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeList$Generic$OfMethodExceptionTypes$TypeProjection</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    82.1%
  </span>
  <span class="absValue">
    (69/84)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (16/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.1%
  </span>
  <span class="absValue">
    (118/142)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.GenericDeclaration;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.Visitor.Substitutor.ForAttachment;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.FilterableList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public interface TypeList extends FilterableList&lt;TypeDescription, TypeList&gt; {
&nbsp;    @AlwaysNull
&nbsp;    TypeList UNDEFINED = null;
&nbsp;    @AlwaysNull
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;MS_MUTABLE_ARRAY&quot;, &quot;MS_OOI_PKGPROTECT&quot;},
&nbsp;        justification = &quot;Null reference cannot be mutated.&quot;
&nbsp;    )
&nbsp;    String[] NO_INTERFACES = null;
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    String[] toInternalNames();
&nbsp;
&nbsp;    int getStackSize();
&nbsp;
&nbsp;    public abstract static class AbstractBase extends FilterableList.AbstractBase&lt;TypeDescription, TypeList&gt; implements TypeList {
&nbsp;        public AbstractBase() {
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        protected TypeList wrap(List&lt;TypeDescription&gt; values) {
&nbsp;            return new Explicit(values);
&nbsp;        }
&nbsp;
&nbsp;        public int getStackSize() {
<b class="fc">&nbsp;            return StackSize.of(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public String[] toInternalNames() {
&nbsp;            String[] internalNames = new String[this.size()];
&nbsp;            int i = 0;
&nbsp;
&nbsp;            for(TypeDescription typeDescription : this) {
&nbsp;                internalNames[i++] = typeDescription.getInternalName();
&nbsp;            }
&nbsp;
&nbsp;            return internalNames.length == 0 ? NO_INTERFACES : internalNames;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForLoadedTypes extends AbstractBase {
&nbsp;        private final List&lt;? extends Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;        public ForLoadedTypes(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            this(Arrays.asList(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        public ForLoadedTypes(List&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;            this.types = types;</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription get(int index) {
&nbsp;            return ForLoadedType.of((Class)this.types.get(index));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public int size() {</b>
&nbsp;            return this.types.size();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public String[] toInternalNames() {
&nbsp;            String[] internalNames = new String[this.types.size()];
&nbsp;            int i = 0;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            for(Class&lt;?&gt; type : this.types) {</b>
<b class="fc">&nbsp;                internalNames[i++] = net.bytebuddy.jar.asm.Type.getInternalName(type);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return internalNames.length == 0 ? NO_INTERFACES : internalNames;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class Explicit extends AbstractBase {
&nbsp;        private final List&lt;? extends TypeDescription&gt; typeDescriptions;
&nbsp;
&nbsp;        public Explicit(TypeDescription... typeDescription) {
&nbsp;            this(Arrays.asList(typeDescription));
&nbsp;        }
&nbsp;
&nbsp;        public Explicit(List&lt;? extends TypeDescription&gt; typeDescriptions) {
&nbsp;            this.typeDescriptions = typeDescriptions;
&nbsp;        }
&nbsp;
&nbsp;        public static TypeList of(List&lt;? extends JavaConstant&gt; constants) {
&nbsp;            List&lt;TypeDescription&gt; typeDescriptions = new ArrayList(constants.size());
&nbsp;
&nbsp;            for(JavaConstant constant : constants) {
&nbsp;                typeDescriptions.add(constant.getTypeDescription());
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return new Explicit(typeDescriptions);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription get(int index) {
&nbsp;            return (TypeDescription)this.typeDescriptions.get(index);
&nbsp;        }
&nbsp;
&nbsp;        public int size() {
<b class="fc">&nbsp;            return this.typeDescriptions.size();</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public static class Empty extends FilterableList.Empty&lt;TypeDescription, TypeList&gt; implements TypeList {
&nbsp;        public Empty() {
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @SuppressFBWarnings(</b>
&nbsp;            value = {&quot;EI_EXPOSE_REP&quot;},
&nbsp;            justification = &quot;Value is null&quot;
&nbsp;        )
&nbsp;        public String[] toInternalNames() {
&nbsp;            return NO_INTERFACES;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public int getStackSize() {
&nbsp;            return 0;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Generic extends FilterableList&lt;TypeDescription.Generic, Generic&gt; {
&nbsp;        TypeList asErasures();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        Generic asRawTypes();</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        ByteCodeElement.Token.TokenList&lt;TypeVariableToken&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; var1);</b>
&nbsp;
<b class="nc">&nbsp;        Generic accept(TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; var1);</b>
&nbsp;
&nbsp;        int getStackSize();
&nbsp;
&nbsp;        public abstract static class AbstractBase extends FilterableList.AbstractBase&lt;TypeDescription.Generic, Generic&gt; implements Generic {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            protected Generic wrap(List&lt;TypeDescription.Generic&gt; values) {
&nbsp;                return new Explicit(values);
&nbsp;            }
&nbsp;
&nbsp;            public Generic accept(TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                List&lt;TypeDescription.Generic&gt; visited = new ArrayList(this.size());
&nbsp;
&nbsp;                for(TypeDescription.Generic typeDescription : this) {
&nbsp;                    visited.add(typeDescription.accept(visitor));
&nbsp;                }
&nbsp;
&nbsp;                return new Explicit(visited);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public ByteCodeElement.Token.TokenList&lt;TypeVariableToken&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {</b>
&nbsp;                List&lt;TypeVariableToken&gt; tokens = new ArrayList(this.size());
&nbsp;
&nbsp;                for(TypeDescription.Generic typeVariable : this) {
&nbsp;                    tokens.add(TypeVariableToken.of(typeVariable, matcher));
&nbsp;                }
&nbsp;
&nbsp;                return new ByteCodeElement.Token.TokenList(tokens);
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public int getStackSize() {
&nbsp;                int stackSize = 0;
&nbsp;
&nbsp;                for(TypeDescription.Generic typeDescription : this) {
&nbsp;                    stackSize += typeDescription.getStackSize().getSize();
&nbsp;                }
&nbsp;
&nbsp;                return stackSize;
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public TypeList asErasures() {</b>
<b class="nc">&nbsp;                List&lt;TypeDescription&gt; typeDescriptions = new ArrayList(this.size());</b>
&nbsp;
<b class="nc">&nbsp;                for(TypeDescription.Generic typeDescription : this) {</b>
&nbsp;                    typeDescriptions.add(typeDescription.asErasure());
&nbsp;                }
&nbsp;
&nbsp;                return new Explicit(typeDescriptions);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public Generic asRawTypes() {</b>
&nbsp;                List&lt;TypeDescription.Generic&gt; typeDescriptions = new ArrayList(this.size());
&nbsp;
&nbsp;                for(TypeDescription.Generic typeDescription : this) {
&nbsp;                    typeDescriptions.add(typeDescription.asRawType());
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                return new Explicit(typeDescriptions);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class Explicit extends AbstractBase {
&nbsp;            private final List&lt;? extends TypeDefinition&gt; typeDefinitions;
&nbsp;
<b class="fc">&nbsp;            public Explicit(TypeDefinition... typeDefinition) {</b>
&nbsp;                this(Arrays.asList(typeDefinition));
&nbsp;            }
&nbsp;
&nbsp;            public Explicit(List&lt;? extends TypeDefinition&gt; typeDefinitions) {
&nbsp;                this.typeDefinitions = typeDefinitions;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return ((TypeDefinition)this.typeDefinitions.get(index)).asGenericType();
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.typeDefinitions.size();
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public static class ForLoadedTypes extends AbstractBase {
&nbsp;            private final List&lt;? extends Type&gt; types;
&nbsp;
&nbsp;            public ForLoadedTypes(Type... type) {
&nbsp;                this(Arrays.asList(type));
&nbsp;            }
&nbsp;
&nbsp;            public ForLoadedTypes(List&lt;? extends Type&gt; types) {
&nbsp;                this.types = types;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return Sort.describe((Type)this.types.get(index));
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.types.size();
&nbsp;            }
&nbsp;
&nbsp;            public static class OfTypeVariables extends AbstractBase {
&nbsp;                private final List&lt;TypeVariable&lt;?&gt;&gt; typeVariables;
&nbsp;
&nbsp;                protected OfTypeVariables(TypeVariable&lt;?&gt;... typeVariable) {
&nbsp;                    this(Arrays.asList(typeVariable));
&nbsp;                }
&nbsp;
&nbsp;                protected OfTypeVariables(List&lt;TypeVariable&lt;?&gt;&gt; typeVariables) {
&nbsp;                    this.typeVariables = typeVariables;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic of(GenericDeclaration genericDeclaration) {
&nbsp;                    return new OfTypeVariables(genericDeclaration.getTypeParameters());
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic get(int index) {
&nbsp;                    TypeVariable&lt;?&gt; typeVariable = (TypeVariable)this.typeVariables.get(index);
&nbsp;                    return Sort.describe(typeVariable, new TypeDescription.AnnotationReader.Delegator.ForLoadedTypeVariable(typeVariable));
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return this.typeVariables.size();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class ForDetachedTypes extends AbstractBase {
&nbsp;            private final List&lt;? extends TypeDescription.Generic&gt; detachedTypes;
<b class="fc">&nbsp;            private final TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;</b>
&nbsp;
&nbsp;            public ForDetachedTypes(List&lt;? extends TypeDescription.Generic&gt; detachedTypes, TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                this.detachedTypes = detachedTypes;
<b class="fc">&nbsp;                this.visitor = visitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            public static Generic attachVariables(TypeDescription typeDescription, List&lt;? extends TypeVariableToken&gt; detachedTypeVariables) {
&nbsp;                return new OfTypeVariables(typeDescription, detachedTypeVariables, ForAttachment.of(typeDescription));
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public static Generic attach(FieldDescription fieldDescription, List&lt;? extends TypeDescription.Generic&gt; detachedTypes) {</b>
<b class="fc">&nbsp;                return new ForDetachedTypes(detachedTypes, ForAttachment.of(fieldDescription));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public static Generic attach(MethodDescription methodDescription, List&lt;? extends TypeDescription.Generic&gt; detachedTypes) {</b>
&nbsp;                return new ForDetachedTypes(detachedTypes, ForAttachment.of(methodDescription));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic attachVariables(MethodDescription methodDescription, List&lt;? extends TypeVariableToken&gt; detachedTypeVariables) {
&nbsp;                return new OfTypeVariables(methodDescription, detachedTypeVariables, ForAttachment.of(methodDescription));
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static Generic attach(ParameterDescription parameterDescription, List&lt;? extends TypeDescription.Generic&gt; detachedTypes) {</b>
<b class="fc">&nbsp;                return new ForDetachedTypes(detachedTypes, ForAttachment.of(parameterDescription));</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return (TypeDescription.Generic)((TypeDescription.Generic)this.detachedTypes.get(index)).accept(this.visitor);
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.detachedTypes.size();
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static class WithResolvedErasure extends AbstractBase {</b>
&nbsp;                private final List&lt;? extends TypeDescription.Generic&gt; detachedTypes;
<b class="fc">&nbsp;                private final TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;</b>
&nbsp;
&nbsp;                public WithResolvedErasure(List&lt;? extends TypeDescription.Generic&gt; detachedTypes, TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                    this.detachedTypes = detachedTypes;
&nbsp;                    this.visitor = visitor;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeDescription.Generic get(int index) {</b>
<b class="fc">&nbsp;                    return new TypeDescription.LazyProjection.WithResolvedErasure((TypeDescription.Generic)this.detachedTypes.get(index), this.visitor);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                public int size() {</b>
&nbsp;                    return this.detachedTypes.size();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfTypeVariables extends AbstractBase {
&nbsp;                private final TypeVariableSource typeVariableSource;
<b class="fc">&nbsp;                private final List&lt;? extends TypeVariableToken&gt; detachedTypeVariables;</b>
<b class="fc">&nbsp;                private final TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;</b>
<b class="fc">&nbsp;</b>
&nbsp;                public OfTypeVariables(TypeVariableSource typeVariableSource, List&lt;? extends TypeVariableToken&gt; detachedTypeVariables, TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;                    this.typeVariableSource = typeVariableSource;</b>
&nbsp;                    this.detachedTypeVariables = detachedTypeVariables;
&nbsp;                    this.visitor = visitor;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic get(int index) {
&nbsp;                    return new AttachedTypeVariable(this.typeVariableSource, (TypeVariableToken)this.detachedTypeVariables.get(index), this.visitor);
&nbsp;                }
&nbsp;
&nbsp;                public int size() {
&nbsp;                    return this.detachedTypeVariables.size();
&nbsp;                }
&nbsp;
&nbsp;                protected static class AttachedTypeVariable extends TypeDescription.OfTypeVariable {
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;                    private final TypeVariableToken typeVariableToken;
&nbsp;                    private final TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;                    protected AttachedTypeVariable(TypeVariableSource typeVariableSource, TypeVariableToken typeVariableToken, TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                        this.typeVariableSource = typeVariableSource;
<b class="fc">&nbsp;                        this.typeVariableToken = typeVariableToken;</b>
&nbsp;                        this.visitor = visitor;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic getUpperBounds() {
&nbsp;                        return this.typeVariableToken.getBounds().accept(this.visitor);
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public TypeVariableSource getTypeVariableSource() {</b>
<b class="fc">&nbsp;                        return this.typeVariableSource;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public String getSymbol() {
&nbsp;                        return this.typeVariableToken.getSymbol();
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public AnnotationList getDeclaredAnnotations() {</b>
&nbsp;                        return this.typeVariableToken.getAnnotations();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public static class OfLoadedInterfaceTypes extends AbstractBase {</b>
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            public OfLoadedInterfaceTypes(Class&lt;?&gt; type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return new TypeProjection(this.type, index, this.type.getInterfaces());
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.type.getInterfaces().length;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList asErasures() {
&nbsp;                return new ForLoadedTypes(this.type.getInterfaces());
&nbsp;            }
&nbsp;
&nbsp;            private static class TypeProjection extends TypeDescription.LazyProjection.WithLazyNavigation.OfAnnotatedElement {
<b class="fc">&nbsp;                private final Class&lt;?&gt; type;</b>
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                private TypeProjection(Class&lt;?&gt; type, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.type = type;
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected TypeDescription.Generic resolve() {
&nbsp;                    TypeDescription.Generic var1 = this.resolved;
&nbsp;                    TypeDescription.Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        Type[] type = this.type.getGenericInterfaces();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describeOrNull(type[this.index], this.getAnnotationReader()) : this.asRawType();
&nbsp;                    }
&nbsp;
&nbsp;                    TypeDescription.Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
<b class="fc">&nbsp;                        var2 = this.resolved;</b>
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected TypeDescription.AnnotationReader getAnnotationReader() {
&nbsp;                    return new TypeDescription.AnnotationReader.Delegator.ForLoadedInterface(this.type, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class OfConstructorExceptionTypes extends AbstractBase {
<b class="fc">&nbsp;            private final Constructor&lt;?&gt; constructor;</b>
&nbsp;
&nbsp;            public OfConstructorExceptionTypes(Constructor&lt;?&gt; constructor) {
&nbsp;                this.constructor = constructor;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return new TypeProjection(this.constructor, index, this.constructor.getExceptionTypes());
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public int size() {
&nbsp;                return this.constructor.getExceptionTypes().length;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList asErasures() {
&nbsp;                return new ForLoadedTypes(this.constructor.getExceptionTypes());
&nbsp;            }
&nbsp;
&nbsp;            private static class TypeProjection extends TypeDescription.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
<b class="fc">&nbsp;                private final Constructor&lt;?&gt; constructor;</b>
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                private TypeProjection(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.constructor = constructor;
&nbsp;                    this.index = index;
<b class="fc">&nbsp;                    this.erasure = erasure;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected TypeDescription.Generic resolve() {
&nbsp;                    TypeDescription.Generic var1 = this.resolved;
&nbsp;                    TypeDescription.Generic var10000;
&nbsp;                    if (var1 != null) {
<b class="fc">&nbsp;                        var10000 = null;</b>
&nbsp;                    } else {
&nbsp;                        Type[] type = this.constructor.getGenericExceptionTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describeOrNull(type[this.index], this.getAnnotationReader()) : this.asRawType();
&nbsp;                    }
&nbsp;
&nbsp;                    TypeDescription.Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected TypeDescription.AnnotationReader getAnnotationReader() {
&nbsp;                    return new TypeDescription.AnnotationReader.Delegator.ForLoadedExecutableExceptionType(this.constructor, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class OfMethodExceptionTypes extends AbstractBase {
<b class="fc">&nbsp;            private final Method method;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public OfMethodExceptionTypes(Method method) {</b>
&nbsp;                this.method = method;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription.Generic get(int index) {
&nbsp;                return new TypeProjection(this.method, index, this.method.getExceptionTypes());
&nbsp;            }
&nbsp;
&nbsp;            public int size() {
&nbsp;                return this.method.getExceptionTypes().length;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public TypeList asErasures() {
&nbsp;                return new ForLoadedTypes(this.method.getExceptionTypes());
&nbsp;            }
&nbsp;
&nbsp;            private static class TypeProjection extends TypeDescription.LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Method method;
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                public TypeProjection(Method method, int index, Class&lt;?&gt;[] erasure) {
<b class="nc">&nbsp;                    this.method = method;</b>
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(&quot;resolved&quot;)
&nbsp;                protected TypeDescription.Generic resolve() {
&nbsp;                    TypeDescription.Generic var1 = this.resolved;
&nbsp;                    TypeDescription.Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        Type[] type = this.method.getGenericExceptionTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describeOrNull(type[this.index], this.getAnnotationReader()) : this.asRawType();
&nbsp;                    }
&nbsp;
&nbsp;                    TypeDescription.Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected TypeDescription.AnnotationReader getAnnotationReader() {
&nbsp;                    return new TypeDescription.AnnotationReader.Delegator.ForLoadedExecutableExceptionType(this.method, this.index);
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public static class Empty extends FilterableList.Empty&lt;TypeDescription.Generic, Generic&gt; implements Generic {
&nbsp;            public Empty() {
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public TypeList asErasures() {</b>
&nbsp;                return new Empty();
&nbsp;            }
&nbsp;
&nbsp;            public Generic asRawTypes() {
&nbsp;                return this;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public Generic accept(TypeDescription.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                return new Empty();
&nbsp;            }
&nbsp;
&nbsp;            public ByteCodeElement.Token.TokenList&lt;TypeVariableToken&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
&nbsp;                return new ByteCodeElement.Token.TokenList(new TypeVariableToken[0]);
&nbsp;            }
&nbsp;
&nbsp;            public int getStackSize() {
&nbsp;                return 0;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
