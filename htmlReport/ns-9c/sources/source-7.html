


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MockMethodAdvice</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.creation.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: MockMethodAdvice (org.mockito.internal.creation.bytebuddy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MockMethodAdvice</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (1/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.7%
  </span>
  <span class="absValue">
    (9/77)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MockMethodAdvice$ConstructorShortcut</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5%
  </span>
  <span class="absValue">
    (2/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ConstructorShortcut$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/147)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForEquals</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForHashCode</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForReadObject</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$ForStatic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$Identifier</td>
  </tr>
  <tr>
    <td class="name">MockMethodAdvice$SelfCallInfo</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (1/8)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (3/33)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/126)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.1%
  </span>
  <span class="absValue">
    (12/295)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.creation.bytebuddy;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.IntStream;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.Advice;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.asm.Advice.AllArguments;
&nbsp;import net.bytebuddy.asm.Advice.Argument;
&nbsp;import net.bytebuddy.asm.Advice.Enter;
&nbsp;import net.bytebuddy.asm.Advice.OnMethodEnter;
&nbsp;import net.bytebuddy.asm.Advice.OnMethodExit;
&nbsp;import net.bytebuddy.asm.Advice.Origin;
&nbsp;import net.bytebuddy.asm.Advice.Return;
&nbsp;import net.bytebuddy.asm.Advice.This;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner.Typing;
&nbsp;import net.bytebuddy.jar.asm.Label;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.internal.configuration.plugins.Plugins;
&nbsp;import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
&nbsp;import org.mockito.internal.debugging.LocationFactory;
&nbsp;import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
&nbsp;import org.mockito.internal.invocation.RealMethod;
&nbsp;import org.mockito.internal.invocation.SerializableMethod;
&nbsp;import org.mockito.internal.invocation.mockref.MockReference;
&nbsp;import org.mockito.internal.invocation.mockref.MockWeakReference;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal;
&nbsp;import org.mockito.internal.util.concurrent.WeakConcurrentMap;
&nbsp;import org.mockito.plugins.MemberAccessor;
&nbsp;
&nbsp;public class MockMethodAdvice extends MockMethodDispatcher {
&nbsp;    private final WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; interceptors;
&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics;
<b class="fc">&nbsp;    private final String identifier;</b>
<b class="fc">&nbsp;    private final SelfCallInfo selfCallInfo = new SelfCallInfo();</b>
<b class="fc">&nbsp;    private final MethodGraph.Compiler compiler = Default.forJavaHierarchy();</b>
&nbsp;    private final WeakConcurrentMap&lt;Class&lt;?&gt;, SoftReference&lt;MethodGraph&gt;&gt; graphs = new WeakConcurrentMap.WithInlinedExpunction();
&nbsp;    private final Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction;
&nbsp;    private final ConstructionCallback onConstruction;
&nbsp;
&nbsp;    public MockMethodAdvice(WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; interceptors, DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics, String identifier, Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction, ConstructionCallback onConstruction) {
&nbsp;        this.interceptors = interceptors;
&nbsp;        this.mockedStatics = mockedStatics;
&nbsp;        this.onConstruction = onConstruction;
&nbsp;        this.identifier = identifier;
&nbsp;        this.isMockConstruction = isMockConstruction;
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @OnMethodEnter(</b>
<b class="fc">&nbsp;        skipOn = Advice.OnNonDefaultValue.class</b>
<b class="fc">&nbsp;    )</b>
<b class="fc">&nbsp;    private static Callable&lt;?&gt; enter(@MockMethodAdvice.Identifier String identifier, @This Object mock, @Origin Method origin, @AllArguments Object[] arguments) throws Throwable {</b>
&nbsp;        MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
&nbsp;        return dispatcher != null &amp;&amp; dispatcher.isMocked(mock) &amp;&amp; !dispatcher.isOverridden(mock, origin) ? dispatcher.handle(mock, origin, arguments) : null;
&nbsp;    }
&nbsp;
&nbsp;    @OnMethodExit
&nbsp;    private static void exit(@Return(readOnly = false,typing = Typing.DYNAMIC) Object returned, @Enter Callable&lt;?&gt; mocked) throws Throwable {
&nbsp;        if (mocked != null) {
&nbsp;            returned = mocked.call();
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public Callable&lt;?&gt; handle(Object instance, Method origin, Object[] arguments) throws Throwable {</b>
<b class="nc">&nbsp;        MockMethodInterceptor interceptor = (MockMethodInterceptor)this.interceptors.get(instance);</b>
<b class="nc">&nbsp;        if (interceptor == null) {</b>
&nbsp;            return null;
<b class="nc">&nbsp;        } else {</b>
&nbsp;            RealMethod realMethod;
&nbsp;            if (instance instanceof Serializable) {
&nbsp;                realMethod = new SerializableRealMethodCall(this.identifier, origin, instance, arguments);
&nbsp;            } else {
&nbsp;                realMethod = new RealMethodCall(this.selfCallInfo, origin, instance, arguments);
&nbsp;            }
&nbsp;
&nbsp;            return new ReturnValueWrapper(interceptor.doIntercept(instance, origin, arguments, realMethod, LocationFactory.create(true)));
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public Callable&lt;?&gt; handleStatic(Class&lt;?&gt; type, Method origin, Object[] arguments) throws Throwable {
&nbsp;        Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();
&nbsp;        return interceptors != null &amp;&amp; interceptors.containsKey(type) ? new ReturnValueWrapper(((MockMethodInterceptor)interceptors.get(type)).doIntercept(type, origin, arguments, new StaticMethodCall(this.selfCallInfo, type, origin, arguments), LocationFactory.create(true))) : null;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public Object handleConstruction(Class&lt;?&gt; type, Object object, Object[] arguments, String[] parameterTypeNames) {</b>
<b class="nc">&nbsp;        return this.onConstruction.apply(type, object, arguments, parameterTypeNames);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public boolean isMock(Object instance) {
<b class="nc">&nbsp;        return instance != this.interceptors.target &amp;&amp; this.interceptors.containsKey(instance);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public boolean isMocked(Object instance) {</b>
&nbsp;        return this.isMock(instance) &amp;&amp; this.selfCallInfo.checkSelfCall(instance);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public boolean isMockedStatic(Class&lt;?&gt; type) {</b>
&nbsp;        if (!this.selfCallInfo.checkSelfCall(type)) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            Map&lt;Class&lt;?&gt;, ?&gt; interceptors = (Map)this.mockedStatics.get();
&nbsp;            return interceptors != null &amp;&amp; interceptors.containsKey(type);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public boolean isOverridden(Object instance, Method origin) {
<b class="nc">&nbsp;        SoftReference&lt;MethodGraph&gt; reference = (SoftReference)this.graphs.get(instance.getClass());</b>
&nbsp;        MethodGraph methodGraph = reference == null ? null : (MethodGraph)reference.get();
<b class="nc">&nbsp;        if (methodGraph == null) {</b>
<b class="nc">&nbsp;            methodGraph = this.compiler.compile(ForLoadedType.of(instance.getClass()));</b>
&nbsp;            this.graphs.put(instance.getClass(), new SoftReference(methodGraph));
&nbsp;        }
&nbsp;
&nbsp;        MethodGraph.Node node = methodGraph.locate((new MethodDescription.ForLoadedMethod(origin)).asSignatureToken());
<b class="nc">&nbsp;        return !node.getSort().isResolved() || !((MethodDescription.InDefinedShape)node.getRepresentative().asDefined()).getDeclaringType().represents(origin.getDeclaringClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    public boolean isConstructorMock(Class&lt;?&gt; type) {
&nbsp;        return this.isMockConstruction.test(type);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private static Object tryInvoke(Method origin, Object instance, Object[] arguments) throws Throwable {
&nbsp;        MemberAccessor accessor = Plugins.getMemberAccessor();
&nbsp;
&nbsp;        try {
&nbsp;            return accessor.invoke(origin, instance, arguments);
&nbsp;        } catch (InvocationTargetException exception) {
<b class="nc">&nbsp;            Throwable cause = exception.getCause();</b>
&nbsp;            (new ConditionalStackTraceFilter()).filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
&nbsp;            throw cause;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    static Throwable removeRecursiveCalls(Throwable cause, Class&lt;?&gt; declaringClass) {
&nbsp;        List&lt;String&gt; uniqueStackTraceItems = new ArrayList();
&nbsp;        List&lt;Integer&gt; indexesToBeRemoved = new ArrayList();
&nbsp;
<b class="nc">&nbsp;        for(StackTraceElement element : cause.getStackTrace()) {</b>
<b class="nc">&nbsp;            String var10000 = element.getClassName();</b>
&nbsp;            String key = var10000 + element.getLineNumber();
<b class="nc">&nbsp;            int elementIndex = uniqueStackTraceItems.lastIndexOf(key);</b>
<b class="nc">&nbsp;            uniqueStackTraceItems.add(key);</b>
&nbsp;            if (elementIndex &gt; -1 &amp;&amp; declaringClass.getName().equals(element.getClassName())) {
&nbsp;                indexesToBeRemoved.add(elementIndex);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        List&lt;StackTraceElement&gt; adjustedList = new ArrayList(Arrays.asList(cause.getStackTrace()));</b>
<b class="nc">&nbsp;        IntStream var11 = indexesToBeRemoved.stream().sorted(Comparator.reverseOrder()).mapToInt(Integer::intValue);</b>
<b class="nc">&nbsp;        Objects.requireNonNull(adjustedList);</b>
<b class="nc">&nbsp;        var11.forEach(adjustedList::remove);</b>
<b class="nc">&nbsp;        cause.setStackTrace((StackTraceElement[])adjustedList.toArray(new StackTraceElement[0]));</b>
<b class="nc">&nbsp;        return cause;</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static class RealMethodCall implements RealMethod {</b>
<b class="nc">&nbsp;        private final SelfCallInfo selfCallInfo;</b>
<b class="nc">&nbsp;        private final Method origin;</b>
<b class="nc">&nbsp;        private final MockWeakReference&lt;Object&gt; instanceRef;</b>
<b class="nc">&nbsp;        private final Object[] arguments;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private RealMethodCall(SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {</b>
&nbsp;            this.selfCallInfo = selfCallInfo;
&nbsp;            this.origin = origin;
&nbsp;            this.instanceRef = new MockWeakReference(instance);
&nbsp;            this.arguments = arguments;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isInvokable() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke() throws Throwable {
&nbsp;            this.selfCallInfo.set(this.instanceRef.get());
&nbsp;            return MockMethodAdvice.tryInvoke(this.origin, this.instanceRef.get(), this.arguments);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class SerializableRealMethodCall implements RealMethod {
&nbsp;        private final String identifier;
&nbsp;        private final SerializableMethod origin;
&nbsp;        private final MockReference&lt;Object&gt; instanceRef;
&nbsp;        private final Object[] arguments;
&nbsp;
&nbsp;        private SerializableRealMethodCall(String identifier, Method origin, Object instance, Object[] arguments) {
&nbsp;            this.origin = new SerializableMethod(origin);
&nbsp;            this.identifier = identifier;
&nbsp;            this.instanceRef = new MockWeakReference(instance);
&nbsp;            this.arguments = arguments;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokable() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke() throws Throwable {
&nbsp;            Method method = this.origin.getJavaMethod();
&nbsp;            MockMethodDispatcher mockMethodDispatcher = MockMethodDispatcher.get(this.identifier, this.instanceRef.get());
&nbsp;            if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
&nbsp;                throw new MockitoException(&quot;Unexpected dispatcher for advice-based super call&quot;);
&nbsp;            } else {
&nbsp;                Object previous = ((MockMethodAdvice)mockMethodDispatcher).selfCallInfo.replace(this.instanceRef.get());
&nbsp;
&nbsp;                Object var4;
&nbsp;                try {
&nbsp;                    var4 = MockMethodAdvice.tryInvoke(method, this.instanceRef.get(), this.arguments);
&nbsp;                } finally {
&nbsp;                    ((MockMethodAdvice)mockMethodDispatcher).selfCallInfo.set(previous);
&nbsp;                }
&nbsp;
&nbsp;                return var4;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class StaticMethodCall implements RealMethod {
&nbsp;        private final SelfCallInfo selfCallInfo;
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;        private final Method origin;
&nbsp;        private final Object[] arguments;
&nbsp;
&nbsp;        private StaticMethodCall(SelfCallInfo selfCallInfo, Class&lt;?&gt; type, Method origin, Object[] arguments) {
&nbsp;            this.selfCallInfo = selfCallInfo;
&nbsp;            this.type = type;
&nbsp;            this.origin = origin;
&nbsp;            this.arguments = arguments;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokable() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke() throws Throwable {
&nbsp;            this.selfCallInfo.set(this.type);
&nbsp;            return MockMethodAdvice.tryInvoke(this.origin, (Object)null, this.arguments);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class ReturnValueWrapper implements Callable&lt;Object&gt; {
&nbsp;        private final Object returned;
&nbsp;
&nbsp;        private ReturnValueWrapper(Object returned) {
&nbsp;            this.returned = returned;
&nbsp;        }
&nbsp;
&nbsp;        public Object call() {
&nbsp;            return this.returned;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class SelfCallInfo extends ThreadLocal&lt;Object&gt; {
&nbsp;        private SelfCallInfo() {
&nbsp;        }
&nbsp;
&nbsp;        Object replace(Object value) {
&nbsp;            Object current = this.get();
&nbsp;            this.set(value);
&nbsp;            return current;
&nbsp;        }
&nbsp;
&nbsp;        boolean checkSelfCall(Object value) {
&nbsp;            if (value == this.get()) {
&nbsp;                this.set((Object)null);
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static class ConstructorShortcut implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {
&nbsp;        private final String identifier;
&nbsp;
<b class="nc">&nbsp;        ConstructorShortcut(String identifier) {</b>
&nbsp;            this.identifier = identifier;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public MethodVisitor wrap(final TypeDescription instrumentedType, final MethodDescription instrumentedMethod, MethodVisitor methodVisitor, final Implementation.Context implementationContext, TypePool typePool, int writerFlags, int readerFlags) {</b>
<b class="nc">&nbsp;            if (instrumentedMethod.isConstructor() &amp;&amp; !instrumentedType.represents(Object.class)) {</b>
<b class="nc">&nbsp;                MethodList&lt;MethodDescription.InDefinedShape&gt; constructors = (MethodList)instrumentedType.getSuperClass().asErasure().getDeclaredMethods().filter(ElementMatchers.isConstructor().and(ElementMatchers.isVisibleTo(instrumentedType)));</b>
&nbsp;                int arguments = Integer.MAX_VALUE;
&nbsp;                boolean packagePrivate = true;
&nbsp;                final MethodDescription.InDefinedShape current = null;
&nbsp;
&nbsp;                for(MethodDescription.InDefinedShape constructor : constructors) {
<b class="nc">&nbsp;                    if (constructor.getParameters().size() &lt; arguments &amp;&amp; (packagePrivate || !constructor.isPackagePrivate())) {</b>
<b class="nc">&nbsp;                        arguments = constructor.getParameters().size();</b>
<b class="nc">&nbsp;                        packagePrivate = constructor.isPackagePrivate();</b>
<b class="nc">&nbsp;                        current = constructor;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (current != null) {</b>
<b class="nc">&nbsp;                    return new MethodVisitor(OpenedClassReader.ASM_API, methodVisitor) {</b>
&nbsp;                        public void visitCode() {
&nbsp;                            super.visitCode();
<b class="nc">&nbsp;                            Label label = new Label();</b>
<b class="nc">&nbsp;                            super.visitLdcInsn(ConstructorShortcut.this.identifier);</b>
<b class="nc">&nbsp;                            if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));</b>
<b class="nc">&nbsp;                            } else {</b>
<b class="nc">&nbsp;                                super.visitLdcInsn(instrumentedType.getName());</b>
<b class="nc">&nbsp;                                super.visitMethodInsn(184, Type.getInternalName(Class.class), &quot;forName&quot;, Type.getMethodDescriptor(Type.getType(Class.class), new Type[]{Type.getType(String.class)}), false);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            super.visitMethodInsn(184, Type.getInternalName(MockMethodDispatcher.class), &quot;isConstructorMock&quot;, Type.getMethodDescriptor(Type.BOOLEAN_TYPE, new Type[]{Type.getType(String.class), Type.getType(Class.class)}), false);
&nbsp;                            super.visitInsn(3);
&nbsp;                            super.visitJumpInsn(159, label);
&nbsp;                            super.visitVarInsn(25, 0);
&nbsp;
&nbsp;                            for(TypeDescription type : current.getParameters().asTypeList().asErasures()) {
&nbsp;                                if (!type.represents(Boolean.TYPE) &amp;&amp; !type.represents(Byte.TYPE) &amp;&amp; !type.represents(Short.TYPE) &amp;&amp; !type.represents(Character.TYPE) &amp;&amp; !type.represents(Integer.TYPE)) {
&nbsp;                                    if (type.represents(Long.TYPE)) {
&nbsp;                                        super.visitInsn(9);
&nbsp;                                    } else if (type.represents(Float.TYPE)) {
&nbsp;                                        super.visitInsn(11);
&nbsp;                                    } else if (type.represents(Double.TYPE)) {
&nbsp;                                        super.visitInsn(14);
&nbsp;                                    } else {
&nbsp;                                        super.visitInsn(1);
<b class="fc">&nbsp;                                    }</b>
&nbsp;                                } else {
&nbsp;                                    super.visitInsn(3);
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;</b>
&nbsp;                            super.visitMethodInsn(183, current.getDeclaringType().getInternalName(), current.getInternalName(), current.getDescriptor(), false);
&nbsp;                            super.visitLdcInsn(ConstructorShortcut.this.identifier);
&nbsp;                            if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V5)) {
<b class="nc">&nbsp;                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));</b>
<b class="nc">&nbsp;                            } else {</b>
<b class="nc">&nbsp;                                super.visitLdcInsn(instrumentedType.getName());</b>
&nbsp;                                super.visitMethodInsn(184, Type.getInternalName(Class.class), &quot;forName&quot;, Type.getMethodDescriptor(Type.getType(Class.class), new Type[]{Type.getType(String.class)}), false);
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            super.visitVarInsn(25, 0);
&nbsp;                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
&nbsp;                            super.visitTypeInsn(189, Type.getInternalName(Object.class));
&nbsp;                            int index = 0;
&nbsp;
&nbsp;                            for(ParameterDescription parameter : instrumentedMethod.getParameters()) {
&nbsp;                                super.visitInsn(89);
&nbsp;                                super.visitLdcInsn(index++);
<b class="fc">&nbsp;                                Type type = Type.getType(parameter.getType().asErasure().getDescriptor());</b>
<b class="fc">&nbsp;                                super.visitVarInsn(type.getOpcode(21), parameter.getOffset());</b>
&nbsp;                                if (parameter.getType().isPrimitive()) {
&nbsp;                                    Type wrapper = Type.getType(parameter.getType().asErasure().asBoxed().getDescriptor());
&nbsp;                                    super.visitMethodInsn(184, wrapper.getInternalName(), &quot;valueOf&quot;, Type.getMethodDescriptor(wrapper, new Type[]{type}), false);
&nbsp;                                }
&nbsp;
&nbsp;                                super.visitInsn(83);
&nbsp;                            }
&nbsp;
&nbsp;                            index = 0;
&nbsp;                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
&nbsp;                            super.visitTypeInsn(189, Type.getInternalName(String.class));
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                            for(TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
&nbsp;                                super.visitInsn(89);
<b class="nc">&nbsp;                                super.visitLdcInsn(index++);</b>
<b class="nc">&nbsp;                                super.visitLdcInsn(typeDescription.getName());</b>
<b class="nc">&nbsp;                                super.visitInsn(83);</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                            super.visitMethodInsn(184, Type.getInternalName(MockMethodDispatcher.class), &quot;handleConstruction&quot;, Type.getMethodDescriptor(Type.getType(Object.class), new Type[]{Type.getType(String.class), Type.getType(Class.class), Type.getType(Object.class), Type.getType(Object[].class), Type.getType(String[].class)}), false);</b>
<b class="nc">&nbsp;                            FieldList&lt;FieldDescription.InDefinedShape&gt; fields = (FieldList)instrumentedType.getDeclaredFields().filter(ElementMatchers.not(ElementMatchers.isStatic()));</b>
<b class="nc">&nbsp;                            super.visitTypeInsn(192, instrumentedType.getInternalName());</b>
&nbsp;                            super.visitInsn(89);
&nbsp;                            Label noSpy = new Label();
&nbsp;                            super.visitJumpInsn(198, noSpy);
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                            for(FieldDescription field : fields) {</b>
<b class="nc">&nbsp;                                super.visitInsn(89);</b>
<b class="nc">&nbsp;                                super.visitFieldInsn(180, instrumentedType.getInternalName(), field.getInternalName(), field.getDescriptor());</b>
<b class="nc">&nbsp;                                super.visitVarInsn(25, 0);</b>
&nbsp;                                super.visitInsn(field.getType().getStackSize() == StackSize.DOUBLE ? 91 : 90);
&nbsp;                                super.visitInsn(87);
<b class="nc">&nbsp;                                super.visitFieldInsn(181, instrumentedType.getInternalName(), field.getInternalName(), field.getDescriptor());</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;</b>
&nbsp;                            super.visitLabel(noSpy);
&nbsp;                            if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {
<b class="nc">&nbsp;                                Object[] locals = MockMethodAdvice.ConstructorShortcut.toFrames(instrumentedType.getInternalName(), instrumentedMethod.getParameters().asTypeList().asErasures());</b>
&nbsp;                                super.visitFrame(0, locals.length, locals, 1, new Object[]{instrumentedType.getInternalName()});
&nbsp;                            }
&nbsp;
&nbsp;                            super.visitInsn(87);
&nbsp;                            super.visitInsn(177);
&nbsp;                            super.visitLabel(label);
&nbsp;                            if (implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6)) {
&nbsp;                                Object[] locals = MockMethodAdvice.ConstructorShortcut.toFrames(Opcodes.UNINITIALIZED_THIS, instrumentedMethod.getParameters().asTypeList().asErasures());
&nbsp;                                super.visitFrame(0, locals.length, locals, 0, new Object[0]);
&nbsp;                            }
&nbsp;
&nbsp;                        }
&nbsp;
&nbsp;                        public void visitMaxs(int maxStack, int maxLocals) {
&nbsp;                            int prequel = Math.max(5, current.getStackSize());
&nbsp;
&nbsp;                            for(ParameterDescription parameter : instrumentedMethod.getParameters()) {
&nbsp;                                prequel = Math.max(prequel, 6 + parameter.getType().getStackSize().getSize());
&nbsp;                                prequel = Math.max(prequel, 8);
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                            super.visitMaxs(Math.max(maxStack, prequel), maxLocals);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    };</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return methodVisitor;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        private static Object[] toFrames(Object self, List&lt;TypeDescription&gt; types) {
<b class="nc">&nbsp;            Object[] frames = new Object[1 + types.size()];</b>
<b class="nc">&nbsp;            frames[0] = self;</b>
<b class="nc">&nbsp;            int index = 0;</b>
&nbsp;
&nbsp;            for(TypeDescription type : types) {
<b class="nc">&nbsp;                Object frame;</b>
&nbsp;                if (!type.represents(Boolean.TYPE) &amp;&amp; !type.represents(Byte.TYPE) &amp;&amp; !type.represents(Short.TYPE) &amp;&amp; !type.represents(Character.TYPE) &amp;&amp; !type.represents(Integer.TYPE)) {
<b class="nc">&nbsp;                    if (type.represents(Long.TYPE)) {</b>
&nbsp;                        frame = Opcodes.LONG;
<b class="nc">&nbsp;                    } else if (type.represents(Float.TYPE)) {</b>
&nbsp;                        frame = Opcodes.FLOAT;
<b class="nc">&nbsp;                    } else if (type.represents(Double.TYPE)) {</b>
<b class="nc">&nbsp;                        frame = Opcodes.DOUBLE;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        frame = type.getInternalName();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    frame = Opcodes.INTEGER;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                ++index;</b>
<b class="nc">&nbsp;                frames[index] = frame;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return frames;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    static class ForHashCode {</b>
<b class="nc">&nbsp;        ForHashCode() {</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        @OnMethodEnter(</b>
&nbsp;            skipOn = Advice.OnNonDefaultValue.class
&nbsp;        )
<b class="nc">&nbsp;        private static boolean enter(@MockMethodAdvice.Identifier String id, @This Object self) {</b>
&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
<b class="nc">&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMock(self);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        @OnMethodExit
<b class="nc">&nbsp;        private static void enter(@This Object self, @Return(readOnly = false) int hashCode, @Enter boolean skipped) {</b>
<b class="nc">&nbsp;            if (skipped) {</b>
<b class="nc">&nbsp;                hashCode = System.identityHashCode(self);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    static class ForEquals {
<b class="nc">&nbsp;        ForEquals() {</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @OnMethodEnter(</b>
<b class="nc">&nbsp;            skipOn = Advice.OnNonDefaultValue.class</b>
&nbsp;        )
&nbsp;        private static boolean enter(@MockMethodAdvice.Identifier String identifier, @This Object self) {
<b class="nc">&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);</b>
<b class="nc">&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMock(self);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @OnMethodExit</b>
&nbsp;        private static void enter(@This Object self, @Argument(0) Object other, @Return(readOnly = false) boolean equals, @Enter boolean skipped) {
<b class="nc">&nbsp;            if (skipped) {</b>
<b class="nc">&nbsp;                boolean var10000 = self == other;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    static class ForStatic {</b>
<b class="nc">&nbsp;        ForStatic() {</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        @OnMethodEnter(
<b class="nc">&nbsp;            skipOn = Advice.OnNonDefaultValue.class</b>
<b class="nc">&nbsp;        )</b>
<b class="nc">&nbsp;        private static Callable&lt;?&gt; enter(@MockMethodAdvice.Identifier String identifier, @Origin Class&lt;?&gt; type, @Origin Method origin, @AllArguments Object[] arguments) throws Throwable {</b>
<b class="nc">&nbsp;            MockMethodDispatcher dispatcher = MockMethodDispatcher.getStatic(identifier, type);</b>
<b class="nc">&nbsp;            return dispatcher != null &amp;&amp; dispatcher.isMockedStatic(type) ? dispatcher.handleStatic(type, origin, arguments) : null;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @OnMethodExit
<b class="nc">&nbsp;        private static void exit(@Return(readOnly = false,typing = Typing.DYNAMIC) Object returned, @Enter Callable&lt;?&gt; mocked) throws Throwable {</b>
&nbsp;            if (mocked != null) {
&nbsp;                returned = mocked.call();
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static class ForReadObject {</b>
&nbsp;        public ForReadObject() {
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public static void doReadObject(@MockMethodAdvice.Identifier String identifier, @net.bytebuddy.implementation.bind.annotation.This MockAccess thiz, @net.bytebuddy.implementation.bind.annotation.Argument(0) ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException {</b>
<b class="nc">&nbsp;            objectInputStream.defaultReadObject();</b>
<b class="nc">&nbsp;            MockMethodAdvice mockMethodAdvice = (MockMethodAdvice)MockMethodDispatcher.get(identifier, thiz);</b>
&nbsp;            if (mockMethodAdvice != null) {
<b class="nc">&nbsp;                mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Retention(RetentionPolicy.RUNTIME)</b>
<b class="nc">&nbsp;    @interface Identifier {</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:43</div>
</div>
</body>
</html>
