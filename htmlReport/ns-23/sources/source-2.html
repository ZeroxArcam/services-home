


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Implementation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: Implementation (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Implementation$Composable</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (12/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.8%
  </span>
  <span class="absValue">
    (47/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AbstractPropertyAccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethodDelegation</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$CacheValueField</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$DelegationRecord</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldCacheEntry</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldGetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldSetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Disabled$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Factory</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration</td>
<td class="coverageStat">
  <span class="percent">
    27.3%
  </span>
  <span class="absValue">
    (3/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.9%
  </span>
  <span class="absValue">
    (7/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Simple</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.4%
  </span>
  <span class="absValue">
    (14/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    61.7%
  </span>
  <span class="absValue">
    (74/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.1%
  </span>
  <span class="absValue">
    (28/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58%
  </span>
  <span class="absValue">
    (166/286)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType.Prepareable.NoOp;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer.None;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool.Record.Sort;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation.Trivial;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.jar.asm.ClassVisitor;
&nbsp;import net.bytebuddy.jar.asm.FieldVisitor;
&nbsp;import net.bytebuddy.jar.asm.MethodVisitor;
&nbsp;import net.bytebuddy.jar.asm.Opcodes;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.JavaConstant.MethodHandle;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public interface Implementation extends InstrumentedType.Prepareable {
&nbsp;    ByteCodeAppender appender(Target var1);
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class Compound implements Implementation {
&nbsp;        private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;        public Compound(Implementation... implementation) {
&nbsp;            this(Arrays.asList(implementation));
&nbsp;        }
&nbsp;
&nbsp;        public Compound(List&lt;? extends Implementation&gt; implementations) {
&nbsp;            this.implementations = new ArrayList();
&nbsp;
&nbsp;            for(Implementation implementation : implementations) {
&nbsp;                if (implementation instanceof Composable) {
&nbsp;                    this.implementations.addAll(((Composable)implementation).implementations);
&nbsp;                    this.implementations.add(((Composable)implementation).composable);
&nbsp;                } else if (implementation instanceof Compound) {
&nbsp;                    this.implementations.addAll(((Compound)implementation).implementations);
&nbsp;                } else {
&nbsp;                    this.implementations.add(implementation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            for(Implementation implementation : this.implementations) {
&nbsp;                instrumentedType = implementation.prepare(instrumentedType);
&nbsp;            }
&nbsp;
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[this.implementations.size()];
&nbsp;            int index = 0;
&nbsp;
&nbsp;            for(Implementation implementation : this.implementations) {
&nbsp;                byteCodeAppender[index++] = implementation.appender(implementationTarget);
&nbsp;            }
&nbsp;
&nbsp;            return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.implementations.equals(((Compound)var1).implementations);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.implementations.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Composable implements Composable {
&nbsp;            private final Composable composable;
&nbsp;            private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;            public Composable(Implementation implementation, Composable composable) {
&nbsp;                this(Collections.singletonList(implementation), composable);
&nbsp;            }
&nbsp;
&nbsp;            public Composable(List&lt;? extends Implementation&gt; implementations, Composable composable) {
&nbsp;                this.implementations = new ArrayList();
&nbsp;
&nbsp;                for(Implementation implementation : implementations) {
&nbsp;                    if (implementation instanceof Composable) {
&nbsp;                        this.implementations.addAll(((Composable)implementation).implementations);
&nbsp;                        this.implementations.add(((Composable)implementation).composable);
&nbsp;                    } else if (implementation instanceof Compound) {
&nbsp;                        this.implementations.addAll(((Compound)implementation).implementations);
&nbsp;                    } else {
&nbsp;                        this.implementations.add(implementation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                if (composable instanceof Composable) {
&nbsp;                    this.implementations.addAll(((Composable)composable).implementations);
&nbsp;                    this.composable = ((Composable)composable).composable;
&nbsp;                } else {
&nbsp;                    this.composable = composable;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                for(Implementation implementation : this.implementations) {
<b class="fc">&nbsp;                    instrumentedType = implementation.prepare(instrumentedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                return this.composable.prepare(instrumentedType);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {</b>
&nbsp;                ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[this.implementations.size() + 1];
&nbsp;                int index = 0;
&nbsp;
&nbsp;                for(Implementation implementation : this.implementations) {
&nbsp;                    byteCodeAppender[index++] = implementation.appender(implementationTarget);
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                byteCodeAppender[index] = this.composable.appender(implementationTarget);
&nbsp;                return new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;            }
&nbsp;
&nbsp;            public Implementation andThen(Implementation implementation) {
&nbsp;                return new Compound(CompoundList.of(this.implementations, this.composable.andThen(implementation)));
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public Composable andThen(Composable implementation) {
&nbsp;                return new Composable(this.implementations, this.composable.andThen(implementation));
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
<b class="nc">&nbsp;                if (this == var1) {</b>
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.composable.equals(((Composable)var1).composable)) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else {
&nbsp;                    return this.implementations.equals(((Composable)var1).implementations);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public int hashCode() {
&nbsp;                return (this.getClass().hashCode() * 31 + this.composable.hashCode()) * 31 + this.implementations.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @Enhance</b>
&nbsp;    public static class Simple implements Implementation {
&nbsp;        private static final int NO_ADDITIONAL_VARIABLES = 0;
&nbsp;        private final ByteCodeAppender byteCodeAppender;
&nbsp;
<b class="fc">&nbsp;        public Simple(ByteCodeAppender... byteCodeAppender) {</b>
&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Compound(byteCodeAppender);
&nbsp;        }
&nbsp;
&nbsp;        public Simple(StackManipulation... stackManipulation) {
<b class="nc">&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Simple(stackManipulation);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public static Implementation of(Dispatcher dispatcher) {</b>
&nbsp;            return of(dispatcher, 0);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public static Implementation of(Dispatcher dispatcher, int additionalVariableLength) {</b>
&nbsp;            return of(dispatcher, NoOp.INSTANCE, additionalVariableLength);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable) {
&nbsp;            return of(dispatcher, prepareable, 0);
&nbsp;        }
&nbsp;
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
&nbsp;            if (additionalVariableLength &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;Additional variable length cannot be negative: &quot; + additionalVariableLength);
&nbsp;            } else {
&nbsp;                return new ForDispatcher(dispatcher, prepareable, additionalVariableLength);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;            return instrumentedType;
&nbsp;        }
&nbsp;
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;            return this.byteCodeAppender;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
<b class="fc">&nbsp;                return this.byteCodeAppender.equals(((Simple)var1).byteCodeAppender);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.byteCodeAppender.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        protected static class ForDispatcher implements Implementation {
&nbsp;            private final Dispatcher dispatcher;
&nbsp;            private final InstrumentedType.Prepareable prepareable;
&nbsp;            private final int additionalVariableLength;
&nbsp;
&nbsp;            protected ForDispatcher(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
&nbsp;                this.dispatcher = dispatcher;
<b class="fc">&nbsp;                this.prepareable = prepareable;</b>
<b class="fc">&nbsp;                this.additionalVariableLength = additionalVariableLength;</b>
&nbsp;            }
&nbsp;
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
&nbsp;                return this.prepareable.prepare(instrumentedType);
&nbsp;            }
&nbsp;
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;                return new Appender(implementationTarget);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                    return false;
&nbsp;                } else if (this.additionalVariableLength != ((ForDispatcher)var1).additionalVariableLength) {
&nbsp;                    return false;
&nbsp;                } else if (!this.dispatcher.equals(((ForDispatcher)var1).dispatcher)) {
&nbsp;                    return false;
&nbsp;                } else {
<b class="fc">&nbsp;                    return this.prepareable.equals(((ForDispatcher)var1).prepareable);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.dispatcher.hashCode()) * 31 + this.prepareable.hashCode()) * 31 + this.additionalVariableLength;
&nbsp;            }
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;            @Enhance(</b>
&nbsp;                includeSyntheticFields = true
<b class="nc">&nbsp;            )</b>
&nbsp;            protected class Appender implements ByteCodeAppender {
&nbsp;                private final Target implementationTarget;
&nbsp;
&nbsp;                protected Appender(Target implementationTarget) {
&nbsp;                    this.implementationTarget = implementationTarget;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {</b>
&nbsp;                    return new ByteCodeAppender.Size(ForDispatcher.this.dispatcher.apply(this.implementationTarget, instrumentedMethod).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize() + ForDispatcher.this.additionalVariableLength);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.implementationTarget.equals(((Appender)var1).implementationTarget)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return ForDispatcher.this.equals(ForDispatcher.this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.implementationTarget.hashCode()) * 31 + ForDispatcher.this.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Dispatcher {
&nbsp;            StackManipulation apply(Target var1, MethodDescription var2);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Composable extends Implementation {
&nbsp;        Implementation andThen(Implementation var1);
&nbsp;
&nbsp;        Composable andThen(Composable var1);
&nbsp;    }
&nbsp;
&nbsp;    public interface Context extends MethodAccessorFactory {
&nbsp;        TypeDescription register(AuxiliaryType var1);
&nbsp;
&nbsp;        FieldDescription.InDefinedShape cache(StackManipulation var1, TypeDescription var2);
&nbsp;
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;        FrameGeneration getFrameGeneration();
&nbsp;
&nbsp;        public static enum FrameGeneration {
&nbsp;            GENERATE(true) {
&nbsp;                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
&nbsp;                    methodVisitor.visitFrame(type, changedLocalVariableCount, changedLocalVariable, stackCount, stack);
&nbsp;                }
&nbsp;            },
&nbsp;            EXPAND(true) {
&nbsp;                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
&nbsp;                    methodVisitor.visitFrame(-1, fullLocalVariableCount, fullLocalVariable, stackCount, stack);
&nbsp;                }
&nbsp;            },
&nbsp;            DISABLED(false) {
&nbsp;                public void generate(MethodVisitor methodVisitor, int type, int stackCount, @MaybeNull Object[] stack, int changedLocalVariableCount, @MaybeNull Object[] changedLocalVariable, int fullLocalVariableCount, @MaybeNull Object[] fullLocalVariable) {
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            private static final Object[] EMPTY = new Object[0];
&nbsp;            private final boolean active;
&nbsp;
&nbsp;            private FrameGeneration(boolean active) {
&nbsp;                this.active = active;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isActive() {
&nbsp;                return this.active;
&nbsp;            }
&nbsp;
&nbsp;            public void same(MethodVisitor methodVisitor, List&lt;? extends TypeDefinition&gt; localVariables) {
&nbsp;                this.generate(methodVisitor, 3, EMPTY.length, EMPTY, EMPTY.length, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
&nbsp;            }
&nbsp;
&nbsp;            public void same1(MethodVisitor methodVisitor, TypeDefinition stackValue, List&lt;? extends TypeDefinition&gt; localVariables) {
&nbsp;                this.generate(methodVisitor, 4, 1, new Object[]{toStackMapFrame(stackValue)}, EMPTY.length, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
&nbsp;            }
&nbsp;
&nbsp;            public void append(MethodVisitor methodVisitor, List&lt;? extends TypeDefinition&gt; appended, List&lt;? extends TypeDefinition&gt; localVariables) {
&nbsp;                this.generate(methodVisitor, 1, EMPTY.length, EMPTY, appended.size(), toStackMapFrames(appended), localVariables.size() + appended.size(), toStackMapFrames(CompoundList.of(localVariables, appended)));
&nbsp;            }
&nbsp;
&nbsp;            public void chop(MethodVisitor methodVisitor, int chopped, List&lt;? extends TypeDefinition&gt; localVariables) {
&nbsp;                this.generate(methodVisitor, 2, EMPTY.length, EMPTY, chopped, EMPTY, localVariables.size(), toStackMapFrames(localVariables));
&nbsp;            }
&nbsp;
&nbsp;            public void full(MethodVisitor methodVisitor, List&lt;? extends TypeDefinition&gt; stackValues, List&lt;? extends TypeDefinition&gt; localVariables) {
&nbsp;                this.generate(methodVisitor, 0, stackValues.size(), toStackMapFrames(stackValues), localVariables.size(), toStackMapFrames(localVariables), localVariables.size(), toStackMapFrames(localVariables));
&nbsp;            }
&nbsp;
&nbsp;            protected abstract void generate(MethodVisitor var1, int var2, int var3, @MaybeNull Object[] var4, int var5, @MaybeNull Object[] var6, int var7, @MaybeNull Object[] var8);
&nbsp;
&nbsp;            private static Object[] toStackMapFrames(List&lt;? extends TypeDefinition&gt; typeDefinitions) {
&nbsp;                Object[] value = typeDefinitions.isEmpty() ? EMPTY : new Object[typeDefinitions.size()];
&nbsp;
&nbsp;                for(int index = 0; index &lt; typeDefinitions.size(); ++index) {
&nbsp;                    value[index] = toStackMapFrame((TypeDefinition)typeDefinitions.get(index));
&nbsp;                }
&nbsp;
&nbsp;                return value;
&nbsp;            }
&nbsp;
&nbsp;            private static Object toStackMapFrame(TypeDefinition typeDefinition) {
&nbsp;                if (!typeDefinition.represents(Boolean.TYPE) &amp;&amp; !typeDefinition.represents(Byte.TYPE) &amp;&amp; !typeDefinition.represents(Short.TYPE) &amp;&amp; !typeDefinition.represents(Character.TYPE) &amp;&amp; !typeDefinition.represents(Integer.TYPE)) {
&nbsp;                    if (typeDefinition.represents(Long.TYPE)) {
&nbsp;                        return Opcodes.LONG;
&nbsp;                    } else if (typeDefinition.represents(Float.TYPE)) {
&nbsp;                        return Opcodes.FLOAT;
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        return typeDefinition.represents(Double.TYPE) ? Opcodes.DOUBLE : typeDefinition.asErasure().getInternalName();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    return Opcodes.INTEGER;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class Disabled extends ExtractableView.AbstractBase {
<b class="fc">&nbsp;            protected Disabled(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {</b>
&nbsp;                super(instrumentedType, classFileVersion, frameGeneration);
&nbsp;            }
&nbsp;
&nbsp;            public boolean isEnabled() {
&nbsp;                return false;
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {</b>
<b class="fc">&nbsp;                return Collections.emptyList();</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {</b>
&nbsp;                drain.apply(classVisitor, None.INSTANCE, this);
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of auxiliary types was disabled: &quot; + auxiliaryType);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, MethodAccessorFactory.AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of method accessors was disabled: &quot; + specialMethodInvocation.getMethodDescription());
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Field values caching was disabled: &quot; + fieldType);</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public static enum Factory implements Factory {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                /** @deprecated */
&nbsp;                @Deprecated
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                    return this.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.DISABLED);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
<b class="fc">&nbsp;                    if (typeInitializer.isDefined()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define type initializer which was explicitly disabled: &quot; + typeInitializer);</b>
&nbsp;                    } else {
&nbsp;                        return new Disabled(instrumentedType, classFileVersion, frameGeneration);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public static class Default extends ExtractableView.AbstractBase {</b>
&nbsp;            public static final String ACCESSOR_METHOD_SUFFIX = &quot;accessor&quot;;
&nbsp;            public static final String FIELD_CACHE_PREFIX = &quot;cachedValue&quot;;
<b class="nc">&nbsp;            private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;</b>
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;            private final ClassFileVersion auxiliaryClassFileVersion;
&nbsp;            private final Map&lt;SpecialMethodInvocation, DelegationRecord&gt; registeredAccessorMethods;
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredGetters;
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredSetters;
&nbsp;            private final Map&lt;AuxiliaryType, DynamicType&gt; auxiliaryTypes;
&nbsp;            private final Map&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; registeredFieldCacheEntries;
&nbsp;            private final Set&lt;FieldDescription.InDefinedShape&gt; registeredFieldCacheFields;
&nbsp;            private final String suffix;
&nbsp;            private boolean fieldCacheCanAppendEntries;
<b class="pc">&nbsp;</b>
&nbsp;            protected Default(TypeDescription instrumentedType, ClassFileVersion classFileVersion, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration, String suffix) {
&nbsp;                super(instrumentedType, classFileVersion, frameGeneration);
&nbsp;                this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;
&nbsp;                this.typeInitializer = typeInitializer;
&nbsp;                this.auxiliaryClassFileVersion = auxiliaryClassFileVersion;
&nbsp;                this.suffix = suffix;
&nbsp;                this.registeredAccessorMethods = new HashMap();
&nbsp;                this.registeredGetters = new HashMap();
&nbsp;                this.registeredSetters = new HashMap();
&nbsp;                this.auxiliaryTypes = new HashMap();
&nbsp;                this.registeredFieldCacheEntries = new HashMap();
&nbsp;                this.registeredFieldCacheFields = new HashSet();
&nbsp;                this.fieldCacheCanAppendEntries = true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isEnabled() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, MethodAccessorFactory.AccessType accessType) {
&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredAccessorMethods.get(specialMethodInvocation);
&nbsp;                DelegationRecord var4 = record == null ? new AccessorMethodDelegation(this.instrumentedType, this.suffix, accessType, specialMethodInvocation) : record.with(accessType);
&nbsp;                this.registeredAccessorMethods.put(specialMethodInvocation, var4);
&nbsp;                return ((DelegationRecord)var4).getMethod();
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredGetters.get(fieldDescription);
&nbsp;                DelegationRecord var4 = record == null ? new FieldGetterDelegation(this.instrumentedType, this.suffix, accessType, fieldDescription) : record.with(accessType);
&nbsp;                this.registeredGetters.put(fieldDescription, var4);
&nbsp;                return ((DelegationRecord)var4).getMethod();
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, MethodAccessorFactory.AccessType accessType) {
&nbsp;                DelegationRecord record = (DelegationRecord)this.registeredSetters.get(fieldDescription);
&nbsp;                DelegationRecord var4 = record == null ? new FieldSetterDelegation(this.instrumentedType, this.suffix, accessType, fieldDescription) : record.with(accessType);
&nbsp;                this.registeredSetters.put(fieldDescription, var4);
&nbsp;                return ((DelegationRecord)var4).getMethod();
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
&nbsp;                DynamicType dynamicType = (DynamicType)this.auxiliaryTypes.get(auxiliaryType);
&nbsp;                if (dynamicType == null) {
&nbsp;                    dynamicType = auxiliaryType.make(this.auxiliaryTypeNamingStrategy.name(this.instrumentedType, auxiliaryType), this.auxiliaryClassFileVersion, this);
&nbsp;                    this.auxiliaryTypes.put(auxiliaryType, dynamicType);
&nbsp;                }
&nbsp;
&nbsp;                return dynamicType.getTypeDescription();
&nbsp;            }
&nbsp;
&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {
&nbsp;                return new ArrayList(this.auxiliaryTypes.values());
&nbsp;            }
&nbsp;
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
&nbsp;                FieldCacheEntry fieldCacheEntry = new FieldCacheEntry(fieldValue, fieldType);
&nbsp;                FieldDescription.InDefinedShape fieldCache = (FieldDescription.InDefinedShape)this.registeredFieldCacheEntries.get(fieldCacheEntry);
&nbsp;                if (fieldCache != null) {
&nbsp;                    return fieldCache;
&nbsp;                } else if (!this.fieldCacheCanAppendEntries) {
&nbsp;                    throw new IllegalStateException(&quot;Cached values cannot be registered after defining the type initializer for &quot; + this.instrumentedType);
&nbsp;                } else {
&nbsp;                    int hashCode = fieldValue.hashCode();
&nbsp;
&nbsp;                    do {
&nbsp;                        fieldCache = new CacheValueField(this.instrumentedType, fieldType.asGenericType(), this.suffix, hashCode++);
&nbsp;                    } while(!this.registeredFieldCacheFields.add(fieldCache));
&nbsp;
&nbsp;                    this.registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);
&nbsp;                    return fieldCache;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                this.fieldCacheCanAppendEntries = false;
&nbsp;                TypeInitializer typeInitializer = this.typeInitializer;
&nbsp;
<b class="fc">&nbsp;                for(Map.Entry&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; entry : this.registeredFieldCacheEntries.entrySet()) {</b>
&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(((FieldDescription.InDefinedShape)entry.getValue()).getModifiers(), ((FieldDescription.InDefinedShape)entry.getValue()).getInternalName(), ((FieldDescription.InDefinedShape)entry.getValue()).getDescriptor(), ((FieldDescription.InDefinedShape)entry.getValue()).getGenericSignature(), FieldDescription.NO_DEFAULT_VALUE);
&nbsp;                    if (fieldVisitor != null) {
&nbsp;                        fieldVisitor.visitEnd();
&nbsp;                        typeInitializer = typeInitializer.expandWith(((FieldCacheEntry)entry.getKey()).storeIn((FieldDescription)entry.getValue()));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                drain.apply(classVisitor, typeInitializer, this);
&nbsp;
<b class="nc">&nbsp;                for(TypeWriter.MethodPool.Record record : this.registeredAccessorMethods.values()) {</b>
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;                for(TypeWriter.MethodPool.Record record : this.registeredGetters.values()) {
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                for(TypeWriter.MethodPool.Record record : this.registeredSetters.values()) {
&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            protected static class CacheValueField extends FieldDescription.InDefinedShape.AbstractBase {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final TypeDescription.Generic fieldType;
<b class="nc">&nbsp;                private final String name;</b>
&nbsp;
&nbsp;                protected CacheValueField(TypeDescription instrumentedType, TypeDescription.Generic fieldType, String suffix, int hashCode) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.fieldType = fieldType;
&nbsp;                    this.name = &quot;cachedValue$&quot; + suffix + &quot;$&quot; + RandomString.hashOf(hashCode);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public TypeDescription.Generic getType() {
&nbsp;                    return this.fieldType;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="nc">&nbsp;                    return this.instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return 4120 | (this.instrumentedType.isInterface() ? 1 : 2);
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public String getName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class FieldCacheEntry implements StackManipulation {
&nbsp;                private final StackManipulation fieldValue;
&nbsp;                private final TypeDescription fieldType;
&nbsp;
&nbsp;                protected FieldCacheEntry(StackManipulation fieldValue, TypeDescription fieldType) {
&nbsp;                    this.fieldValue = fieldValue;
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected ByteCodeAppender storeIn(FieldDescription fieldDescription) {
&nbsp;                    return new ByteCodeAppender.Simple(new StackManipulation[]{this, FieldAccess.forField(fieldDescription).write()});
&nbsp;                }
&nbsp;
&nbsp;                protected TypeDescription getFieldType() {
&nbsp;                    return this.fieldType;
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public boolean isValid() {
&nbsp;                    return this.fieldValue.isValid();
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {
&nbsp;                    return this.fieldValue.apply(methodVisitor, implementationContext);
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int result = this.fieldValue.hashCode();
<b class="nc">&nbsp;                    result = 31 * result + this.fieldType.hashCode();</b>
&nbsp;                    return result;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object other) {
&nbsp;                    if (this == other) {
<b class="nc">&nbsp;                        return true;</b>
<b class="nc">&nbsp;                    } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {</b>
&nbsp;                        FieldCacheEntry fieldCacheEntry = (FieldCacheEntry)other;
&nbsp;                        return this.fieldValue.equals(fieldCacheEntry.fieldValue) &amp;&amp; this.fieldType.equals(fieldCacheEntry.fieldType);
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class AbstractPropertyAccessorMethod extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;                protected AbstractPropertyAccessorMethod() {
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public int getModifiers() {</b>
&nbsp;                    return 4096 | this.getBaseModifiers() | (this.getDeclaringType().isInterface() ? 1 : 16);
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                protected abstract int getBaseModifiers();
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected static class AccessorMethod extends AbstractPropertyAccessorMethod {</b>
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final MethodDescription methodDescription;
&nbsp;                private final String name;
&nbsp;
&nbsp;                protected AccessorMethod(TypeDescription instrumentedType, MethodDescription methodDescription, TypeDescription typeDescription, String suffix) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                    this.name = methodDescription.getInternalName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix + (typeDescription.isInterface() ? &quot;$&quot; + RandomString.hashOf(typeDescription.hashCode()) : &quot;&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return this.methodDescription.getReturnType().asRawType();
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Explicit.ForTypes(this, this.methodDescription.getParameters().asTypeList().asRawTypes());
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public TypeList.Generic getExceptionTypes() {</b>
<b class="nc">&nbsp;                    return this.methodDescription.getExceptionTypes().asRawTypes();</b>
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return this.instrumentedType;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return this.methodDescription.isStatic() ? 8 : 0;
&nbsp;                }
&nbsp;
&nbsp;                public String getInternalName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class FieldGetter extends AbstractPropertyAccessorMethod {
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;                private final FieldDescription fieldDescription;
<b class="nc">&nbsp;                private final String name;</b>
&nbsp;
<b class="nc">&nbsp;                protected FieldGetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {</b>
<b class="nc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
<b class="nc">&nbsp;                    this.name = fieldDescription.getName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return this.fieldDescription.getType().asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
<b class="nc">&nbsp;                public TypeDescription getDeclaringType() {</b>
<b class="nc">&nbsp;                    return this.instrumentedType;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                protected int getBaseModifiers() {</b>
&nbsp;                    return this.fieldDescription.isStatic() ? 8 : 0;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public String getInternalName() {</b>
<b class="nc">&nbsp;                    return this.name;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            protected static class FieldSetter extends AbstractPropertyAccessorMethod {</b>
<b class="nc">&nbsp;                private final TypeDescription instrumentedType;</b>
<b class="nc">&nbsp;                private final FieldDescription fieldDescription;</b>
<b class="nc">&nbsp;                private final String name;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {</b>
<b class="nc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
&nbsp;                    this.fieldDescription = fieldDescription;
<b class="nc">&nbsp;                    this.name = fieldDescription.getName() + &quot;$&quot; + &quot;accessor&quot; + &quot;$&quot; + suffix;</b>
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription.Generic getReturnType() {
&nbsp;                    return ForLoadedType.of(Void.TYPE);
&nbsp;                }
&nbsp;
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(this.fieldDescription.getType().asRawType()));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getExceptionTypes() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;                    return AnnotationValue.UNDEFINED;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return new TypeList.Generic.Empty();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                protected int getBaseModifiers() {
&nbsp;                    return this.fieldDescription.isStatic() ? 8 : 0;
&nbsp;                }
&nbsp;
&nbsp;                public String getInternalName() {
&nbsp;                    return this.name;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
&nbsp;                protected final MethodDescription.InDefinedShape methodDescription;
&nbsp;                protected final Visibility visibility;
&nbsp;
&nbsp;                protected DelegationRecord(MethodDescription.InDefinedShape methodDescription, Visibility visibility) {
&nbsp;                    this.methodDescription = methodDescription;
&nbsp;                    this.visibility = visibility;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract DelegationRecord with(MethodAccessorFactory.AccessType var1);
&nbsp;
&nbsp;                public MethodDescription.InDefinedShape getMethod() {
&nbsp;                    return this.methodDescription;
&nbsp;                }
&nbsp;
&nbsp;                public TypeWriter.MethodPool.Record.Sort getSort() {
&nbsp;                    return Sort.IMPLEMENTED;
&nbsp;                }
&nbsp;
&nbsp;                public Visibility getVisibility() {
&nbsp;                    return this.visibility;
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public void applyHead(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    methodVisitor.visitCode();
&nbsp;                    ByteCodeAppender.Size size = this.applyCode(methodVisitor, implementationContext);
&nbsp;                    methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {</b>
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Context implementationContext) {
&nbsp;                    return this.apply(methodVisitor, implementationContext, this.getMethod());
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {</b>
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot prepend code to a delegation for &quot; + this.methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
<b class="nc">&nbsp;                    } else if (var1 == null) {</b>
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.visibility.equals(((DelegationRecord)var1).visibility)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.methodDescription.equals(((DelegationRecord)var1).methodDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.methodDescription.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class AccessorMethodDelegation extends DelegationRecord {
&nbsp;                private final StackManipulation accessorMethodInvocation;
&nbsp;
&nbsp;                protected AccessorMethodDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, SpecialMethodInvocation specialMethodInvocation) {
&nbsp;                    this(new AccessorMethod(instrumentedType, specialMethodInvocation.getMethodDescription(), specialMethodInvocation.getTypeDescription(), suffix), accessType.getVisibility(), specialMethodInvocation);
&nbsp;                }
&nbsp;
&nbsp;                private AccessorMethodDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, StackManipulation accessorMethodInvocation) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.accessorMethodInvocation = accessorMethodInvocation;
&nbsp;                }
&nbsp;
&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {
&nbsp;                    return new AccessorMethodDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.accessorMethodInvocation);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), this.accessorMethodInvocation, MethodReturn.of(instrumentedMethod.getReturnType())})).apply(methodVisitor, implementationContext);
&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.accessorMethodInvocation.equals(((AccessorMethodDelegation)var1).accessorMethodInvocation);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.accessorMethodInvocation.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class FieldGetterDelegation extends DelegationRecord {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected FieldGetterDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    this(new FieldGetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                private FieldGetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {
&nbsp;                    return new FieldGetterDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{(StackManipulation)(this.fieldDescription.isStatic() ? Trivial.INSTANCE : MethodVariableAccess.loadThis()), FieldAccess.forField(this.fieldDescription).read(), MethodReturn.of(this.fieldDescription.getType())})).apply(methodVisitor, implementationContext);
<b class="fc">&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.fieldDescription.equals(((FieldGetterDelegation)var1).fieldDescription);
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            @Enhance
&nbsp;            protected static class FieldSetterDelegation extends DelegationRecord {
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                protected FieldSetterDelegation(TypeDescription instrumentedType, String suffix, MethodAccessorFactory.AccessType accessType, FieldDescription fieldDescription) {
&nbsp;                    this(new FieldSetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                private FieldSetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
&nbsp;                    super(methodDescription, visibility);
&nbsp;                    this.fieldDescription = fieldDescription;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                protected DelegationRecord with(MethodAccessorFactory.AccessType accessType) {</b>
&nbsp;                    return new FieldSetterDelegation(this.methodDescription, this.visibility.expandTo(accessType.getVisibility()), this.fieldDescription);
&nbsp;                }
&nbsp;
&nbsp;                public ByteCodeAppender.Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
&nbsp;                    StackManipulation.Size stackSize = (new StackManipulation.Compound(new StackManipulation[]{MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(), FieldAccess.forField(this.fieldDescription).write(), MethodReturn.VOID})).apply(methodVisitor, implementationContext);
&nbsp;                    return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return this.fieldDescription.equals(((FieldSetterDelegation)var1).fieldDescription);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.fieldDescription.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Factory implements Factory {
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                private Factory() {
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                /** @deprecated */</b>
&nbsp;                @Deprecated
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                    return this.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.DISABLED);
&nbsp;                }
&nbsp;
&nbsp;                public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
&nbsp;                    return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion, frameGeneration, RandomString.make());
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class WithFixedSuffix implements Factory {
&nbsp;                    private final String suffix;
&nbsp;
<b class="pc">&nbsp;                    public WithFixedSuffix(String suffix) {</b>
<b class="nc">&nbsp;                        this.suffix = suffix;</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    /** @deprecated */
&nbsp;                    @Deprecated
&nbsp;                    public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion) {
&nbsp;                        return this.make(instrumentedType, auxiliaryTypeNamingStrategy, typeInitializer, classFileVersion, auxiliaryClassFileVersion, classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6) ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.DISABLED);
&nbsp;                    }
&nbsp;
&nbsp;                    public ExtractableView make(TypeDescription instrumentedType, AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy, TypeInitializer typeInitializer, ClassFileVersion classFileVersion, ClassFileVersion auxiliaryClassFileVersion, FrameGeneration frameGeneration) {
&nbsp;                        return new Default(instrumentedType, classFileVersion, auxiliaryTypeNamingStrategy, typeInitializer, auxiliaryClassFileVersion, frameGeneration, this.suffix);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.suffix.equals(((WithFixedSuffix)var1).suffix);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.suffix.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface ExtractableView extends Context {
&nbsp;            boolean isEnabled();
&nbsp;
&nbsp;            List&lt;DynamicType&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;            void drain(TypeInitializer.Drain var1, ClassVisitor var2, AnnotationValueFilter.Factory var3);
&nbsp;
&nbsp;            @Enhance
&nbsp;            public abstract static class AbstractBase implements ExtractableView {
&nbsp;                protected final TypeDescription instrumentedType;
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;                protected final FrameGeneration frameGeneration;
&nbsp;
&nbsp;                protected AbstractBase(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {
&nbsp;                    this.instrumentedType = instrumentedType;
&nbsp;                    this.classFileVersion = classFileVersion;
&nbsp;                    this.frameGeneration = frameGeneration;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getInstrumentedType() {
&nbsp;                    return this.instrumentedType;
&nbsp;                }
&nbsp;
&nbsp;                public ClassFileVersion getClassFileVersion() {
&nbsp;                    return this.classFileVersion;
&nbsp;                }
&nbsp;
&nbsp;                public FrameGeneration getFrameGeneration() {
&nbsp;                    return this.frameGeneration;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.frameGeneration.equals(((AbstractBase)var1).frameGeneration)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.instrumentedType.equals(((AbstractBase)var1).instrumentedType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.classFileVersion.equals(((AbstractBase)var1).classFileVersion);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.classFileVersion.hashCode()) * 31 + this.frameGeneration.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            /** @deprecated */
&nbsp;            @Deprecated
&nbsp;            ExtractableView make(TypeDescription var1, AuxiliaryType.NamingStrategy var2, TypeInitializer var3, ClassFileVersion var4, ClassFileVersion var5);
&nbsp;
&nbsp;            ExtractableView make(TypeDescription var1, AuxiliaryType.NamingStrategy var2, TypeInitializer var3, ClassFileVersion var4, ClassFileVersion var5, FrameGeneration var6);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface SpecialMethodInvocation extends StackManipulation {
&nbsp;        MethodDescription getMethodDescription();
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        TypeDescription getTypeDescription();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken var1);</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        JavaConstant.MethodHandle toMethodHandle();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public static enum Illegal implements SpecialMethodInvocation {</b>
<b class="fc">&nbsp;            INSTANCE;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            private Illegal() {</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean isValid() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot implement an undefined method&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription getMethodDescription() {
&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public TypeDescription getTypeDescription() {</b>
<b class="pc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant.MethodHandle toMethodHandle() {
&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public abstract static class AbstractBase extends StackManipulation.AbstractBase implements SpecialMethodInvocation {</b>
&nbsp;            public AbstractBase() {
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)</b>
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : 31 * this.getMethodDescription().asSignatureToken().hashCode() + this.getTypeDescription().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
<b class="nc">&nbsp;                    this.hashCode = var2;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                return var2;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public boolean equals(@MaybeNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof SpecialMethodInvocation)) {
&nbsp;                    return false;
&nbsp;                } else {
<b class="fc">&nbsp;                    SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation)other;</b>
<b class="pc">&nbsp;                    return this.getMethodDescription().asSignatureToken().equals(specialMethodInvocation.getMethodDescription().asSignatureToken()) &amp;&amp; this.getTypeDescription().equals(specialMethodInvocation.getTypeDescription());</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public static class Simple extends AbstractBase {
<b class="fc">&nbsp;            private final MethodDescription methodDescription;</b>
&nbsp;            private final TypeDescription typeDescription;
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            protected Simple(MethodDescription methodDescription, TypeDescription typeDescription, StackManipulation stackManipulation) {
&nbsp;                this.methodDescription = methodDescription;
&nbsp;                this.typeDescription = typeDescription;
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            public static SpecialMethodInvocation of(MethodDescription methodDescription, TypeDescription typeDescription) {
&nbsp;                StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);
&nbsp;                return (SpecialMethodInvocation)(stackManipulation.isValid() ? new Simple(methodDescription, typeDescription, stackManipulation) : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public MethodDescription getMethodDescription() {</b>
<b class="pc">&nbsp;                return this.methodDescription;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="pc">&nbsp;            public TypeDescription getTypeDescription() {</b>
<b class="nc">&nbsp;                return this.typeDescription;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public StackManipulation.Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                return this.stackManipulation.apply(methodVisitor, implementationContext);</b>
<b class="pc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {</b>
&nbsp;                return (SpecialMethodInvocation)(this.methodDescription.asTypeToken().equals(token) ? this : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant.MethodHandle toMethodHandle() {
&nbsp;                return MethodHandle.ofSpecial((MethodDescription.InDefinedShape)this.methodDescription.asDefined(), this.typeDescription);
&nbsp;            }
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public interface Target {</b>
<b class="fc">&nbsp;        TypeDescription getInstrumentedType();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        TypeDefinition getOriginType();</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken var1);</b>
&nbsp;
<b class="pc">&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken var1);</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken var1, TypeDescription var2);</b>
&nbsp;
&nbsp;        SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken var1);
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @Enhance</b>
<b class="fc">&nbsp;        public abstract static class AbstractBase implements Target {</b>
&nbsp;            protected final TypeDescription instrumentedType;
<b class="pc">&nbsp;            protected final MethodGraph.Linked methodGraph;</b>
<b class="nc">&nbsp;            protected final DefaultMethodInvocation defaultMethodInvocation;</b>
&nbsp;
<b class="pc">&nbsp;            protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, DefaultMethodInvocation defaultMethodInvocation) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;                this.methodGraph = methodGraph;
&nbsp;                this.defaultMethodInvocation = defaultMethodInvocation;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getInstrumentedType() {
&nbsp;                return this.instrumentedType;
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
&nbsp;                SpecialMethodInvocation specialMethodInvocation = Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;
&nbsp;                for(TypeDescription interfaceType : this.instrumentedType.getInterfaces().asErasures()) {
&nbsp;                    SpecialMethodInvocation invocation = this.invokeDefault(token, interfaceType).withCheckedCompatibilityTo(token.asTypeToken());
&nbsp;                    if (invocation.isValid()) {
&nbsp;                        if (specialMethodInvocation.isValid()) {
&nbsp;                            return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
&nbsp;                        }
&nbsp;
&nbsp;                        specialMethodInvocation = invocation;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return specialMethodInvocation;
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
&nbsp;                return this.defaultMethodInvocation.apply(this.methodGraph.getInterfaceGraph(targetType).locate(token), targetType);
&nbsp;            }
&nbsp;
&nbsp;            public SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token) {
&nbsp;                SpecialMethodInvocation specialMethodInvocation = this.invokeSuper(token);
<b class="fc">&nbsp;                return specialMethodInvocation.isValid() ? specialMethodInvocation : this.invokeDefault(token);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else if (!this.defaultMethodInvocation.equals(((AbstractBase)var1).defaultMethodInvocation)) {</b>
&nbsp;                    return false;
&nbsp;                } else if (!this.instrumentedType.equals(((AbstractBase)var1).instrumentedType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodGraph.equals(((AbstractBase)var1).methodGraph);
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.instrumentedType.hashCode()) * 31 + this.methodGraph.hashCode()) * 31 + this.defaultMethodInvocation.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum DefaultMethodInvocation {
&nbsp;                ENABLED {
<b class="fc">&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {</b>
&nbsp;                        return (SpecialMethodInvocation)(node.getSort().isUnique() ? Implementation.SpecialMethodInvocation.Simple.of(node.getRepresentative(), targetType) : Implementation.SpecialMethodInvocation.Illegal.INSTANCE);
&nbsp;                    }
&nbsp;                },
&nbsp;                DISABLED {
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
&nbsp;                        return Implementation.SpecialMethodInvocation.Illegal.INSTANCE;
<b class="pc">&nbsp;                    }</b>
&nbsp;                };
&nbsp;
&nbsp;                private DefaultMethodInvocation() {
&nbsp;                }
&nbsp;
&nbsp;                public static DefaultMethodInvocation of(ClassFileVersion classFileVersion) {
&nbsp;                    return classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8) ? ENABLED : DISABLED;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                protected abstract SpecialMethodInvocation apply(MethodGraph.Node var1, TypeDescription var2);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Factory {
&nbsp;            Target make(TypeDescription var1, MethodGraph.Linked var2, ClassFileVersion var3);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
