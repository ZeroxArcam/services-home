


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ByteBuddyAgent</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent</a>
</div>

<h1>Coverage Summary for Class: ByteBuddyAgent (net.bytebuddy.agent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    36.7%
  </span>
  <span class="absValue">
    (11/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38%
  </span>
  <span class="absValue">
    (19/50)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50.5%
  </span>
  <span class="absValue">
    (55/109)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider$ForByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.2%
  </span>
  <span class="absValue">
    (14/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.9%
  </span>
  <span class="absValue">
    (25/57)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple$WithExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForEmulatedAttachment</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForJ9Vm</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForModularizedVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForStandardToolsJarVm</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForUserDefinedToolsJar</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$InstallationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    62.3%
  </span>
  <span class="absValue">
    (43/69)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39%
  </span>
  <span class="absValue">
    (39/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55%
  </span>
  <span class="absValue">
    (138/251)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.agent;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.security.CodeSource;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarInputStream;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import java.util.jar.Manifest;
&nbsp;import java.util.jar.Attributes.Name;
&nbsp;import net.bytebuddy.agent.VirtualMachine.Resolver;
&nbsp;import net.bytebuddy.agent.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.agent.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public class ByteBuddyAgent {
&nbsp;    public static final String LATENT_RESOLVE = &quot;net.bytebuddy.agent.latent&quot;;
&nbsp;    private static final String AGENT_CLASS_PROPERTY = &quot;Agent-Class&quot;;
&nbsp;    private static final String CAN_REDEFINE_CLASSES_PROPERTY = &quot;Can-Redefine-Classes&quot;;
&nbsp;    private static final String CAN_RETRANSFORM_CLASSES_PROPERTY = &quot;Can-Retransform-Classes&quot;;
&nbsp;    private static final String CAN_SET_NATIVE_METHOD_PREFIX = &quot;Can-Set-Native-Method-Prefix&quot;;
&nbsp;    private static final String MANIFEST_VERSION_VALUE = &quot;1.0&quot;;
&nbsp;    @AlwaysNull
&nbsp;    private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;
&nbsp;    @AlwaysNull
&nbsp;    private static final String WITHOUT_ARGUMENT = null;
&nbsp;    private static final String ATTACHER_FILE_NAME = &quot;byteBuddyAttacher&quot;;
&nbsp;    private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;    private static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;
&nbsp;    private static final String CLASS_PATH_ARGUMENT = &quot;-cp&quot;;
&nbsp;    private static final String AGENT_ARGUMENT_SEPARATOR = &quot;=&quot;;
&nbsp;    private static final String JAVA_HOME = &quot;java.home&quot;;
&nbsp;    private static final String OS_NAME = &quot;os.name&quot;;
&nbsp;    private static final String FILE_PROTOCOL = &quot;file&quot;;
&nbsp;    private static final AttachmentTypeEvaluator ATTACHMENT_TYPE_EVALUATOR;
&nbsp;
&nbsp;    private ByteBuddyAgent() {
<b class="nc">&nbsp;        throw new UnsupportedOperationException(&quot;This class is a utility class and not supposed to be instantiated&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;        try {
&nbsp;            return (T)Class.forName(&quot;java.security.AccessController&quot;).getMethod(&quot;doPrivileged&quot;, PrivilegedAction.class).invoke((Object)null, action);
&nbsp;        } catch (ClassNotFoundException var2) {
&nbsp;            return (T)action.run();
&nbsp;        } catch (InvocationTargetException exception) {
&nbsp;            throw new IllegalStateException(&quot;Failed to invoke access controller&quot;, exception.getTargetException());
&nbsp;        } catch (IllegalAccessException exception) {
&nbsp;            throw new IllegalStateException(&quot;Failed to access access controller&quot;, exception);
&nbsp;        } catch (NoSuchMethodException exception) {
&nbsp;            throw new IllegalStateException(&quot;Failed to resolve well-known access controller method&quot;, exception);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation getInstrumentation() {
&nbsp;        Instrumentation instrumentation = doGetInstrumentation();
&nbsp;        if (instrumentation == null) {
&nbsp;            throw new IllegalStateException(&quot;The Byte Buddy agent is not initialized or unavailable&quot;);
&nbsp;        } else {
&nbsp;            return instrumentation;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId) {
&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument) {
&nbsp;        attach(agentJar, processId, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, AttachmentProvider attachmentProvider) {
&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT, attachmentProvider);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentJar), false);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider) {</b>
&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument) {
&nbsp;        attach(agentJar, processProvider, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentJar), false);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId) {
&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument) {
&nbsp;        attachNative(agentLibrary, processId, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, AttachmentProvider attachmentProvider) {
&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentLibrary), true);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider) {
&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument) {
&nbsp;        attachNative(agentLibrary, processProvider, argument, ByteBuddyAgent.AttachmentProvider.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT, attachmentProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="fc">&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentLibrary), true);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation install() {
&nbsp;        return install(ByteBuddyAgent.AttachmentProvider.DEFAULT);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public static Instrumentation install(AttachmentProvider attachmentProvider) {
&nbsp;        return install(attachmentProvider, ByteBuddyAgent.ProcessProvider.ForCurrentVm.INSTANCE);
&nbsp;    }
&nbsp;
&nbsp;    public static Instrumentation install(ProcessProvider processProvider) {
&nbsp;        return install(ByteBuddyAgent.AttachmentProvider.DEFAULT, processProvider);
&nbsp;    }
&nbsp;
&nbsp;    public static synchronized Instrumentation install(AttachmentProvider attachmentProvider, ProcessProvider processProvider) {
&nbsp;        Instrumentation instrumentation = doGetInstrumentation();
&nbsp;        if (instrumentation != null) {
&nbsp;            return instrumentation;
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            install(attachmentProvider, processProvider.resolve(), WITHOUT_ARGUMENT, ByteBuddyAgent.AgentProvider.ForByteBuddyAgent.INSTANCE, false);</b>
<b class="fc">&nbsp;            return getInstrumentation();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private static void install(AttachmentProvider attachmentProvider, String processId, @MaybeNull String argument, AgentProvider agentProvider, boolean isNative) {</b>
&nbsp;        AttachmentProvider.Accessor attachmentAccessor = attachmentProvider.attempt();
<b class="nc">&nbsp;        if (!attachmentAccessor.isAvailable()) {</b>
&nbsp;            throw new IllegalStateException(&quot;No compatible attachment provider is available&quot;);
<b class="nc">&nbsp;        } else {</b>
&nbsp;            try {
&nbsp;                if (attachmentAccessor.isExternalAttachmentRequired() &amp;&amp; ATTACHMENT_TYPE_EVALUATOR.requiresExternalAttachment(processId)) {
&nbsp;                    installExternal(attachmentAccessor.getExternalAttachment(), processId, agentProvider.resolve(), isNative, argument);
&nbsp;                } else {
&nbsp;                    Attacher.install(attachmentAccessor.getVirtualMachineType(), processId, agentProvider.resolve().getAbsolutePath(), isNative, argument);
&nbsp;                }
&nbsp;
&nbsp;            } catch (RuntimeException exception) {
&nbsp;                throw exception;
&nbsp;            } catch (Exception exception) {
&nbsp;                throw new IllegalStateException(&quot;Error during attachment using: &quot; + attachmentProvider, exception);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment, String processId, File agent, boolean isNative, @MaybeNull String argument) throws Exception {
&nbsp;        File selfResolvedJar = trySelfResolve();
&nbsp;        File attachmentJar = null;
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;        try {</b>
<b class="nc">&nbsp;            if (selfResolvedJar == null) {</b>
&nbsp;                InputStream inputStream = Attacher.class.getResourceAsStream(&#39;/&#39; + Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
<b class="fc">&nbsp;                if (inputStream == null) {</b>
&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installation process&quot;);
&nbsp;                }
&nbsp;
&nbsp;                try {
&nbsp;                    attachmentJar = File.createTempFile(&quot;byteBuddyAttacher&quot;, &quot;.jar&quot;);
&nbsp;                    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(attachmentJar));
&nbsp;
&nbsp;                    try {
&nbsp;                        jarOutputStream.putNextEntry(new JarEntry(Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));
&nbsp;                        byte[] buffer = new byte[8192];
&nbsp;
&nbsp;                        int index;
&nbsp;                        while((index = inputStream.read(buffer)) != -1) {
&nbsp;                            jarOutputStream.write(buffer, 0, index);
&nbsp;                        }
&nbsp;
&nbsp;                        jarOutputStream.closeEntry();
<b class="nc">&nbsp;                    } finally {</b>
&nbsp;                        jarOutputStream.close();
&nbsp;                    }
&nbsp;                } finally {
&nbsp;                    inputStream.close();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            StringBuilder classPath = (new StringBuilder()).append((selfResolvedJar == null ? attachmentJar : selfResolvedJar).getCanonicalPath());
&nbsp;
&nbsp;            for(File jar : externalAttachment.getClassPath()) {
&nbsp;                classPath.append(File.pathSeparatorChar).append(jar.getCanonicalPath());
&nbsp;            }
&nbsp;
&nbsp;            if ((new ProcessBuilder(new String[]{System.getProperty(&quot;java.home&quot;) + File.separatorChar + &quot;bin&quot; + File.separatorChar + (System.getProperty(&quot;os.name&quot;, &quot;&quot;).toLowerCase(Locale.US).contains(&quot;windows&quot;) ? &quot;java.exe&quot; : &quot;java&quot;), &quot;-Dnet.bytebuddy.agent.attacher.dump=&quot; + System.getProperty(&quot;net.bytebuddy.agent.attacher.dump&quot;, &quot;&quot;), &quot;-cp&quot;, classPath.toString(), Attacher.class.getName(), externalAttachment.getVirtualMachineType(), processId, agent.getAbsolutePath(), Boolean.toString(isNative), argument == null ? &quot;&quot; : &quot;=&quot; + argument})).start().waitFor() != 0) {
&nbsp;                throw new IllegalStateException(&quot;Could not self-attach to current VM using external process - set a property net.bytebuddy.agent.attacher.dump to dump the process output to a file at the specified location&quot;);
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            if (attachmentJar != null &amp;&amp; !attachmentJar.delete()) {</b>
&nbsp;                attachmentJar.deleteOnExit();
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;        justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;    )
&nbsp;    private static File trySelfResolve() {
&nbsp;        try {
&nbsp;            if (Boolean.getBoolean(&quot;net.bytebuddy.agent.latent&quot;)) {
&nbsp;                return null;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                ProtectionDomain protectionDomain = Attacher.class.getProtectionDomain();
&nbsp;                if (protectionDomain == null) {
&nbsp;                    return null;
&nbsp;                } else {
&nbsp;                    CodeSource codeSource = protectionDomain.getCodeSource();
&nbsp;                    if (codeSource == null) {
&nbsp;                        return null;
&nbsp;                    } else {
&nbsp;                        URL location = codeSource.getLocation();
&nbsp;                        if (!location.getProtocol().equals(&quot;file&quot;)) {
&nbsp;                            return null;
&nbsp;                        } else {
&nbsp;                            try {
&nbsp;                                File file = new File(location.toURI());
&nbsp;                                return file.getPath().contains(&quot;=&quot;) ? null : file;
&nbsp;                            } catch (URISyntaxException var4) {
&nbsp;                                return new File(location.getPath());
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (Exception var5) {
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    private static Instrumentation doGetInstrumentation() {
&nbsp;        if (!Installer.NAME.equals(Installer.class.getName())) {
&nbsp;            Instrumentation instrumentation = doGetInstrumentation(Installer.NAME);
&nbsp;            if (instrumentation != null) {
&nbsp;                return instrumentation;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return doGetInstrumentation(Installer.class.getName());
&nbsp;    }
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;        justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;    )
&nbsp;    private static Instrumentation doGetInstrumentation(String name) {
&nbsp;        try {
&nbsp;            Class&lt;?&gt; installer = Class.forName(name, true, ClassLoader.getSystemClassLoader());
&nbsp;
&nbsp;            try {
&nbsp;                Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;);
&nbsp;                Method getModule = Class.class.getMethod(&quot;getModule&quot;);
&nbsp;                Object source = getModule.invoke(ByteBuddyAgent.class);
<b class="nc">&nbsp;                Object target = getModule.invoke(installer);</b>
&nbsp;                if (!(Boolean)module.getMethod(&quot;canRead&quot;, module).invoke(source, target)) {
&nbsp;                    module.getMethod(&quot;addReads&quot;, module).invoke(source, target);
&nbsp;                }
&nbsp;            } catch (ClassNotFoundException var6) {
&nbsp;            }
&nbsp;
&nbsp;            return (Instrumentation)Class.forName(name, true, ClassLoader.getSystemClassLoader()).getMethod(&quot;getInstrumentation&quot;).invoke((Object)null);
&nbsp;        } catch (Exception var7) {
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        ATTACHMENT_TYPE_EVALUATOR = (AttachmentTypeEvaluator)doPrivileged(ByteBuddyAgent.AttachmentTypeEvaluator.InstallationAction.INSTANCE);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @SuppressFBWarnings(</b>
&nbsp;        value = {&quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;},
&nbsp;        justification = &quot;Safe initialization is implied&quot;
&nbsp;    )
&nbsp;    public interface AttachmentProvider {
&nbsp;        AttachmentProvider DEFAULT = new Compound(new AttachmentProvider[]{ByteBuddyAgent.AttachmentProvider.ForModularizedVm.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForJ9Vm.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.JVM_ROOT, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.JDK_ROOT, ByteBuddyAgent.AttachmentProvider.ForStandardToolsJarVm.MACINTOSH, ByteBuddyAgent.AttachmentProvider.ForUserDefinedToolsJar.INSTANCE, ByteBuddyAgent.AttachmentProvider.ForEmulatedAttachment.INSTANCE});
&nbsp;
&nbsp;        Accessor attempt();
&nbsp;
&nbsp;        public static enum ForModularizedVm implements AttachmentProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForModularizedVm() {
&nbsp;            }
&nbsp;
&nbsp;            public Accessor attempt() {
&nbsp;                return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(ClassLoader.getSystemClassLoader());
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static enum ForJ9Vm implements AttachmentProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForJ9Vm() {
&nbsp;            }
&nbsp;
&nbsp;            public Accessor attempt() {
&nbsp;                return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.ofJ9();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForStandardToolsJarVm implements AttachmentProvider {
&nbsp;            JVM_ROOT(&quot;../lib/tools.jar&quot;),
&nbsp;            JDK_ROOT(&quot;lib/tools.jar&quot;),
&nbsp;            MACINTOSH(&quot;../Classes/classes.jar&quot;);
<b class="nc">&nbsp;</b>
&nbsp;            private static final String JAVA_HOME_PROPERTY = &quot;java.home&quot;;
&nbsp;            private final String toolsJarPath;
&nbsp;
&nbsp;            private ForStandardToolsJarVm(String toolsJarPath) {
&nbsp;                this.toolsJarPath = toolsJarPath;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                justification = &quot;Assuring privilege is explicit user responsibility.&quot;
&nbsp;            )
&nbsp;            public Accessor attempt() {
&nbsp;                File toolsJar = new File(System.getProperty(&quot;java.home&quot;), this.toolsJarPath);
&nbsp;
&nbsp;                try {
&nbsp;                    return (Accessor)(toolsJar.isFile() &amp;&amp; toolsJar.canRead() ? ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ByteBuddyAgent.BOOTSTRAP_CLASS_LOADER), toolsJar) : ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE);
&nbsp;                } catch (MalformedURLException var3) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForUserDefinedToolsJar implements AttachmentProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            public static final String PROPERTY = &quot;net.bytebuddy.agent.toolsjar&quot;;
&nbsp;
&nbsp;            private ForUserDefinedToolsJar() {
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                justification = &quot;Assuring privilege is explicit user responsibility.&quot;
&nbsp;            )
<b class="nc">&nbsp;            public Accessor attempt() {</b>
&nbsp;                String location = System.getProperty(&quot;net.bytebuddy.agent.toolsjar&quot;);
&nbsp;                if (location == null) {
&nbsp;                    return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;                } else {
&nbsp;                    File toolsJar = new File(location);
&nbsp;
&nbsp;                    try {
&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, ByteBuddyAgent.BOOTSTRAP_CLASS_LOADER), toolsJar);
&nbsp;                    } catch (MalformedURLException var4) {
&nbsp;                        throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum ForEmulatedAttachment implements AttachmentProvider {
&nbsp;            INSTANCE;
<b class="nc">&nbsp;</b>
&nbsp;            private ForEmulatedAttachment() {
&nbsp;            }
&nbsp;
&nbsp;            public Accessor attempt() {
&nbsp;                try {
&nbsp;                    return new Accessor.Simple.WithDirectAttachment((Class)ByteBuddyAgent.doPrivileged(Resolver.INSTANCE));
&nbsp;                } catch (Throwable var2) {
&nbsp;                    return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static class Compound implements AttachmentProvider {
&nbsp;            private final List&lt;AttachmentProvider&gt; attachmentProviders;
&nbsp;
&nbsp;            public Compound(AttachmentProvider... attachmentProvider) {
<b class="nc">&nbsp;                this(Arrays.asList(attachmentProvider));</b>
&nbsp;            }
&nbsp;
&nbsp;            public Compound(List&lt;? extends AttachmentProvider&gt; attachmentProviders) {
&nbsp;                this.attachmentProviders = new ArrayList();
&nbsp;
&nbsp;                for(AttachmentProvider attachmentProvider : attachmentProviders) {
&nbsp;                    if (attachmentProvider instanceof Compound) {
&nbsp;                        this.attachmentProviders.addAll(((Compound)attachmentProvider).attachmentProviders);
&nbsp;                    } else {
&nbsp;                        this.attachmentProviders.add(attachmentProvider);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public Accessor attempt() {
&nbsp;                for(AttachmentProvider attachmentProvider : this.attachmentProviders) {
<b class="nc">&nbsp;                    Accessor accessor = attachmentProvider.attempt();</b>
&nbsp;                    if (accessor.isAvailable()) {
&nbsp;                        return accessor;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Accessor {
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME = &quot;com.sun.tools.attach.VirtualMachine&quot;;
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME_J9 = &quot;com.ibm.tools.attach.VirtualMachine&quot;;
&nbsp;
&nbsp;            boolean isAvailable();
&nbsp;
&nbsp;            boolean isExternalAttachmentRequired();
<b class="nc">&nbsp;</b>
&nbsp;            Class&lt;?&gt; getVirtualMachineType();
&nbsp;
&nbsp;            ExternalAttachment getExternalAttachment();
&nbsp;
&nbsp;            public static enum Unavailable implements Accessor {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Unavailable() {
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isExternalAttachmentRequired() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public ExternalAttachment getExternalAttachment() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ExternalAttachment {
&nbsp;                private final String virtualMachineType;
&nbsp;                private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                public ExternalAttachment(String virtualMachineType, List&lt;File&gt; classPath) {
&nbsp;                    this.virtualMachineType = virtualMachineType;
&nbsp;                    this.classPath = classPath;
&nbsp;                }
&nbsp;
&nbsp;                public String getVirtualMachineType() {
&nbsp;                    return this.virtualMachineType;
&nbsp;                }
&nbsp;
&nbsp;                public List&lt;File&gt; getClassPath() {
&nbsp;                    return this.classPath;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Simple implements Accessor {
&nbsp;                protected final Class&lt;?&gt; virtualMachineType;
&nbsp;
&nbsp;                protected Simple(Class&lt;?&gt; virtualMachineType) {
<b class="fc">&nbsp;                    this.virtualMachineType = virtualMachineType;</b>
&nbsp;                }
&nbsp;
&nbsp;                public static Accessor of(@MaybeNull ClassLoader classLoader, File... classPath) {
&nbsp;                    try {
&nbsp;                        return new WithExternalAttachment(Class.forName(&quot;com.sun.tools.attach.VirtualMachine&quot;, false, classLoader), Arrays.asList(classPath));
&nbsp;                    } catch (ClassNotFoundException var3) {
&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static Accessor ofJ9() {
&nbsp;                    try {
&nbsp;                        return new WithExternalAttachment(ClassLoader.getSystemClassLoader().loadClass(&quot;com.ibm.tools.attach.VirtualMachine&quot;), Collections.emptyList());
&nbsp;                    } catch (ClassNotFoundException var1) {
&nbsp;                        return ByteBuddyAgent.AttachmentProvider.Accessor.Unavailable.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {</b>
&nbsp;                    return this.virtualMachineType;
&nbsp;                }
&nbsp;
&nbsp;                protected static class WithExternalAttachment extends Simple {
&nbsp;                    private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                    public WithExternalAttachment(Class&lt;?&gt; virtualMachineType, List&lt;File&gt; classPath) {
&nbsp;                        super(virtualMachineType);
&nbsp;                        this.classPath = classPath;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isExternalAttachmentRequired() {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    public ExternalAttachment getExternalAttachment() {
&nbsp;                        return new ExternalAttachment(this.virtualMachineType.getName(), this.classPath);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class WithDirectAttachment extends Simple {
&nbsp;                    public WithDirectAttachment(Class&lt;?&gt; virtualMachineType) {
&nbsp;                        super(virtualMachineType);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean isExternalAttachmentRequired() {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public ExternalAttachment getExternalAttachment() {
&nbsp;                        throw new IllegalStateException(&quot;Cannot apply external attachment&quot;);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected interface AgentProvider {
&nbsp;        File resolve() throws IOException;
&nbsp;
&nbsp;        public static enum ForByteBuddyAgent implements AgentProvider {
&nbsp;            INSTANCE;
&nbsp;
<b class="fc">&nbsp;            private static final String AGENT_FILE_NAME = &quot;byteBuddyAgent&quot;;</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            private ForByteBuddyAgent() {</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            @MaybeNull</b>
&nbsp;            private static File trySelfResolve(Class&lt;?&gt; installer) throws IOException {
&nbsp;                ProtectionDomain protectionDomain = installer.getProtectionDomain();
&nbsp;                if (Boolean.getBoolean(&quot;net.bytebuddy.agent.latent&quot;)) {
&nbsp;                    return null;
&nbsp;                } else if (protectionDomain == null) {
&nbsp;                    return null;
&nbsp;                } else {
&nbsp;                    CodeSource codeSource = protectionDomain.getCodeSource();
&nbsp;                    if (codeSource == null) {
&nbsp;                        return null;
&nbsp;                    } else {
&nbsp;                        URL location = codeSource.getLocation();
<b class="fc">&nbsp;                        if (!location.getProtocol().equals(&quot;file&quot;)) {</b>
<b class="pc">&nbsp;                            return null;</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            File agentJar;
&nbsp;                            try {
<b class="pc">&nbsp;                                agentJar = new File(location.toURI());</b>
<b class="fc">&nbsp;                            } catch (URISyntaxException var12) {</b>
&nbsp;                                agentJar = new File(location.getPath());
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            if (agentJar.isFile() &amp;&amp; agentJar.canRead()) {
&nbsp;                                JarInputStream jarInputStream = new JarInputStream(new FileInputStream(agentJar));
&nbsp;
<b class="nc">&nbsp;                                Object attributes;</b>
&nbsp;                                try {
&nbsp;                                    Manifest manifest = jarInputStream.getManifest();
&nbsp;                                    if (manifest != null) {
&nbsp;                                        Attributes attributes = manifest.getMainAttributes();
&nbsp;                                        if (attributes == null) {
&nbsp;                                            Object var16 = null;
&nbsp;                                            return (File)var16;
&nbsp;                                        }
&nbsp;
&nbsp;                                        if (installer.getName().equals(attributes.getValue(&quot;Agent-Class&quot;)) &amp;&amp; Boolean.parseBoolean(attributes.getValue(&quot;Can-Redefine-Classes&quot;)) &amp;&amp; Boolean.parseBoolean(attributes.getValue(&quot;Can-Retransform-Classes&quot;)) &amp;&amp; Boolean.parseBoolean(attributes.getValue(&quot;Can-Set-Native-Method-Prefix&quot;))) {
&nbsp;                                            File var15 = agentJar;
&nbsp;                                            return var15;
&nbsp;                                        }
&nbsp;
&nbsp;                                        Object var8 = null;
&nbsp;                                        return (File)var8;
&nbsp;                                    }
&nbsp;
&nbsp;                                    attributes = null;
<b class="fc">&nbsp;                                } finally {</b>
&nbsp;                                    jarInputStream.close();
<b class="pc">&nbsp;                                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                                return (File)attributes;</b>
<b class="nc">&nbsp;                            } else {</b>
&nbsp;                                return null;
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            private static File createJarFile() throws IOException {
<b class="nc">&nbsp;                InputStream inputStream = Installer.class.getResourceAsStream(&#39;/&#39; + Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);</b>
<b class="nc">&nbsp;                if (inputStream == null) {</b>
&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installer&quot;);
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    File var14;
&nbsp;                    try {
&nbsp;                        File agentJar = File.createTempFile(&quot;byteBuddyAgent&quot;, &quot;.jar&quot;);
&nbsp;                        agentJar.deleteOnExit();
&nbsp;                        Manifest manifest = new Manifest();
&nbsp;                        manifest.getMainAttributes().put(Name.MANIFEST_VERSION, &quot;1.0&quot;);
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Agent-Class&quot;), Installer.class.getName());
<b class="pc">&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Redefine-Classes&quot;), Boolean.TRUE.toString());</b>
&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Retransform-Classes&quot;), Boolean.TRUE.toString());
<b class="fc">&nbsp;                        manifest.getMainAttributes().put(new Attributes.Name(&quot;Can-Set-Native-Method-Prefix&quot;), Boolean.TRUE.toString());</b>
<b class="pc">&nbsp;                        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(agentJar), manifest);</b>
<b class="nc">&nbsp;</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            jarOutputStream.putNextEntry(new JarEntry(Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));</b>
&nbsp;                            byte[] buffer = new byte[8192];
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;                            int index;</b>
&nbsp;                            while((index = inputStream.read(buffer)) != -1) {
<b class="fc">&nbsp;                                jarOutputStream.write(buffer, 0, index);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;</b>
&nbsp;                            jarOutputStream.closeEntry();
<b class="fc">&nbsp;                        } finally {</b>
<b class="pc">&nbsp;                            jarOutputStream.close();</b>
<b class="pc">&nbsp;                        }</b>
<b class="nc">&nbsp;</b>
&nbsp;                        var14 = agentJar;
&nbsp;                    } finally {
&nbsp;                        inputStream.close();
&nbsp;                    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                    return var14;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;            )
&nbsp;            public File resolve() throws IOException {
&nbsp;                try {
&nbsp;                    if (!Installer.class.getName().equals(Installer.NAME)) {
&nbsp;                        try {
&nbsp;                            File resolved = trySelfResolve(Class.forName(Installer.NAME, false, ClassLoader.getSystemClassLoader()));
&nbsp;                            if (resolved != null) {
&nbsp;                                return resolved;
&nbsp;                            }
<b class="pc">&nbsp;                        } catch (ClassNotFoundException var2) {</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                    File resolved = trySelfResolve(Installer.class);</b>
<b class="nc">&nbsp;                    if (resolved != null) {</b>
&nbsp;                        return resolved;
<b class="fc">&nbsp;                    }</b>
<b class="pc">&nbsp;                } catch (Exception var3) {</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                return createJarFile();</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static class ForExistingAgent implements AgentProvider {
<b class="fc">&nbsp;            private final File agent;</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            protected ForExistingAgent(File agent) {</b>
&nbsp;                this.agent = agent;
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            public File resolve() {</b>
&nbsp;                return this.agent;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    protected interface AttachmentTypeEvaluator {
&nbsp;        boolean requiresExternalAttachment(String var1);
&nbsp;
&nbsp;        public static enum InstallationAction implements PrivilegedAction&lt;AttachmentTypeEvaluator&gt; {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private static final String JDK_ALLOW_SELF_ATTACH = &quot;jdk.attach.allowAttachSelf&quot;;
&nbsp;
&nbsp;            private InstallationAction() {
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @SuppressFBWarnings(</b>
<b class="nc">&nbsp;                value = {&quot;REC_CATCH_EXCEPTION&quot;},</b>
&nbsp;                justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;            )
<b class="fc">&nbsp;            public AttachmentTypeEvaluator run() {</b>
&nbsp;                try {
&nbsp;                    return (AttachmentTypeEvaluator)(Boolean.getBoolean(&quot;jdk.attach.allowAttachSelf&quot;) ? ByteBuddyAgent.AttachmentTypeEvaluator.Disabled.INSTANCE : new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;), Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;)));
&nbsp;                } catch (Exception var2) {
&nbsp;                    return ByteBuddyAgent.AttachmentTypeEvaluator.Disabled.INSTANCE;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum Disabled implements AttachmentTypeEvaluator {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Disabled() {
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public boolean requiresExternalAttachment(String processId) {
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;        public static class ForJava9CapableVm implements AttachmentTypeEvaluator {</b>
&nbsp;            private final Method current;
&nbsp;            private final Method pid;
&nbsp;
&nbsp;            protected ForJava9CapableVm(Method current, Method pid) {
<b class="fc">&nbsp;                this.current = current;</b>
<b class="fc">&nbsp;                this.pid = pid;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public boolean requiresExternalAttachment(String processId) {</b>
&nbsp;                try {
&nbsp;                    return this.pid.invoke(this.current.invoke((Object)null)).toString().equals(processId);
&nbsp;                } catch (IllegalAccessException exception) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);
&nbsp;                } catch (InvocationTargetException exception) {
&nbsp;                    throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface ProcessProvider {
<b class="fc">&nbsp;        String resolve();</b>
&nbsp;
&nbsp;        public static enum ForCurrentVm implements ProcessProvider {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private final ProcessProvider dispatcher = ByteBuddyAgent.ProcessProvider.ForCurrentVm.ForJava9CapableVm.make();
&nbsp;
&nbsp;            private ForCurrentVm() {
&nbsp;            }
&nbsp;
&nbsp;            public String resolve() {
&nbsp;                return this.dispatcher.resolve();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum ForLegacyVm implements ProcessProvider {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private ForLegacyVm() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public String resolve() {
&nbsp;                    String runtimeName;
&nbsp;                    try {
&nbsp;                        Method method = Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getMethod(&quot;getRuntimeMXBean&quot;);
&nbsp;                        runtimeName = (String)method.getReturnType().getMethod(&quot;getName&quot;).invoke(method.invoke((Object)null));
&nbsp;                    } catch (Exception exception) {
&nbsp;                        throw new IllegalStateException(&quot;Failed to access VM name via management factory&quot;, exception);
&nbsp;                    }
&nbsp;
&nbsp;                    int processIdIndex = runtimeName.indexOf(64);
&nbsp;                    if (processIdIndex == -1) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot extract process id from runtime management bean&quot;);
&nbsp;                    } else {
&nbsp;                        return runtimeName.substring(0, processIdIndex);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForJava9CapableVm implements ProcessProvider {
&nbsp;                private final Method current;
&nbsp;                private final Method pid;
&nbsp;
&nbsp;                protected ForJava9CapableVm(Method current, Method pid) {
&nbsp;                    this.current = current;
&nbsp;                    this.pid = pid;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public static ProcessProvider make() {
&nbsp;                    try {
&nbsp;                        return new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;), Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;));
&nbsp;                    } catch (Exception var1) {
&nbsp;                        return ByteBuddyAgent.ProcessProvider.ForCurrentVm.ForLegacyVm.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public String resolve() {
&nbsp;                    try {
&nbsp;                        return this.pid.invoke(this.current.invoke((Object)null)).toString();
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
