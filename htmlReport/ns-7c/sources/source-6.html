


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TempDirectory</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.junit.jupiter.engine.extension</a>
</div>

<h1>Coverage Summary for Class: TempDirectory (org.junit.jupiter.engine.extension)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TempDirectory</td>
<td class="coverageStat">
  <span class="percent">
    40.6%
  </span>
  <span class="absValue">
    (13/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (2/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.7%
  </span>
  <span class="absValue">
    (19/74)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TempDirectory$Scope</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    44.1%
  </span>
  <span class="absValue">
    (15/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (2/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (22/77)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.junit.jupiter.engine.extension;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.nio.file.DirectoryNotEmptyException;
&nbsp;import java.nio.file.FileSystems;
&nbsp;import java.nio.file.FileVisitResult;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.LinkOption;
&nbsp;import java.nio.file.NoSuchFileException;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.nio.file.SimpleFileVisitor;
&nbsp;import java.nio.file.attribute.BasicFileAttributes;
&nbsp;import java.nio.file.attribute.DosFileAttributeView;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import org.junit.jupiter.api.extension.AnnotatedElementContext;
&nbsp;import org.junit.jupiter.api.extension.BeforeAllCallback;
&nbsp;import org.junit.jupiter.api.extension.BeforeEachCallback;
&nbsp;import org.junit.jupiter.api.extension.ExtensionConfigurationException;
&nbsp;import org.junit.jupiter.api.extension.ExtensionContext;
&nbsp;import org.junit.jupiter.api.extension.ParameterContext;
&nbsp;import org.junit.jupiter.api.extension.ParameterResolutionException;
&nbsp;import org.junit.jupiter.api.extension.ParameterResolver;
&nbsp;import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
&nbsp;import org.junit.jupiter.api.io.CleanupMode;
&nbsp;import org.junit.jupiter.api.io.TempDir;
&nbsp;import org.junit.jupiter.api.io.TempDirFactory;
&nbsp;import org.junit.jupiter.engine.config.EnumConfigurationParameterConverter;
&nbsp;import org.junit.jupiter.engine.config.JupiterConfiguration;
&nbsp;import org.junit.platform.commons.JUnitException;
&nbsp;import org.junit.platform.commons.PreconditionViolationException;
&nbsp;import org.junit.platform.commons.logging.Logger;
&nbsp;import org.junit.platform.commons.logging.LoggerFactory;
&nbsp;import org.junit.platform.commons.util.AnnotationUtils;
&nbsp;import org.junit.platform.commons.util.ExceptionUtils;
&nbsp;import org.junit.platform.commons.util.Preconditions;
&nbsp;import org.junit.platform.commons.util.ReflectionUtils;
&nbsp;import org.junit.platform.commons.util.ToStringBuilder;
&nbsp;
&nbsp;class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterResolver {
&nbsp;    static final ExtensionContext.Namespace NAMESPACE = Namespace.create(new Object[]{TempDirectory.class});
&nbsp;    private static final String KEY = &quot;temp.dir&quot;;
&nbsp;    private static final String FAILURE_TRACKER = &quot;failure.tracker&quot;;
&nbsp;    private static final String CHILD_FAILED = &quot;child.failed&quot;;
&nbsp;    static final String FILE_OPERATIONS_KEY = &quot;file.operations&quot;;
&nbsp;    private final JupiterConfiguration configuration;
&nbsp;
&nbsp;    public TempDirectory(JupiterConfiguration configuration) {
&nbsp;        this.configuration = configuration;
&nbsp;    }
&nbsp;
&nbsp;    public void beforeAll(ExtensionContext context) {
&nbsp;        installFailureTracker(context);
&nbsp;        this.injectStaticFields(context, context.getRequiredTestClass());
&nbsp;    }
&nbsp;
&nbsp;    public void beforeEach(ExtensionContext context) {
&nbsp;        installFailureTracker(context);
&nbsp;        context.getRequiredTestInstances().getAllInstances().forEach((instance) -&gt; this.injectInstanceFields(context, instance));
&nbsp;    }
&nbsp;
&nbsp;    private static void installFailureTracker(ExtensionContext context) {
<b class="nc">&nbsp;        context.getStore(NAMESPACE).put(&quot;failure.tracker&quot;, (ExtensionContext.Store.CloseableResource)() -&gt; context.getParent().ifPresent((it) -&gt; {</b>
&nbsp;                if (selfOrChildFailed(context)) {
<b class="fc">&nbsp;                    it.getStore(NAMESPACE).put(&quot;child.failed&quot;, true);</b>
&nbsp;                }
&nbsp;
&nbsp;            }));
&nbsp;    }
&nbsp;
&nbsp;    private void injectStaticFields(ExtensionContext context, Class&lt;?&gt; testClass) {
&nbsp;        this.injectFields(context, (Object)null, testClass, ReflectionUtils::isStatic);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private void injectInstanceFields(ExtensionContext context, Object instance) {</b>
<b class="fc">&nbsp;        this.injectFields(context, instance, instance.getClass(), ReflectionUtils::isNotStatic);</b>
&nbsp;    }
&nbsp;
&nbsp;    private void injectFields(ExtensionContext context, Object testInstance, Class&lt;?&gt; testClass, Predicate&lt;Field&gt; predicate) {
&nbsp;        Scope scope = this.getScope(context);
&nbsp;        AnnotationUtils.findAnnotatedFields(testClass, TempDir.class, predicate).forEach((field) -&gt; {
&nbsp;            this.assertNonFinalField(field);
&nbsp;            this.assertSupportedType(&quot;field&quot;, field.getType());
&nbsp;
&nbsp;            try {
<b class="fc">&nbsp;                CleanupMode cleanupMode = this.determineCleanupModeForField(field);</b>
<b class="fc">&nbsp;                TempDirFactory factory = this.determineTempDirFactoryForField(field, scope);</b>
&nbsp;                ReflectionUtils.makeAccessible(field).set(testInstance, this.getPathOrFile(field.getType(), new FieldContext(field), factory, cleanupMode, scope, context));
&nbsp;            } catch (Throwable t) {
&nbsp;                throw ExceptionUtils.throwAsUncheckedException(t);
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
&nbsp;        boolean annotated = parameterContext.isAnnotated(TempDir.class);
<b class="fc">&nbsp;        if (annotated &amp;&amp; parameterContext.getDeclaringExecutable() instanceof Constructor) {</b>
<b class="fc">&nbsp;            throw new ParameterResolutionException(&quot;@TempDir is not supported on constructor parameters. Please use field injection instead.&quot;);</b>
<b class="fc">&nbsp;        } else {</b>
&nbsp;            return annotated;
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {</b>
<b class="pc">&nbsp;        Class&lt;?&gt; parameterType = parameterContext.getParameter().getType();</b>
<b class="nc">&nbsp;        this.assertSupportedType(&quot;parameter&quot;, parameterType);</b>
&nbsp;        CleanupMode cleanupMode = this.determineCleanupModeForParameter(parameterContext);
&nbsp;        Scope scope = this.getScope(extensionContext);
&nbsp;        TempDirFactory factory = this.determineTempDirFactoryForParameter(parameterContext, scope);
&nbsp;        return this.getPathOrFile(parameterType, parameterContext, factory, cleanupMode, scope, extensionContext);
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    private CleanupMode determineCleanupModeForField(Field field) {
&nbsp;        TempDir tempDir = (TempDir)AnnotationUtils.findAnnotation(field, TempDir.class).orElseThrow(() -&gt; new JUnitException(&quot;Field &quot; + field + &quot; must be annotated with @TempDir&quot;));
&nbsp;        return this.determineCleanupMode(tempDir);
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private CleanupMode determineCleanupModeForParameter(ParameterContext parameterContext) {
&nbsp;        TempDir tempDir = (TempDir)parameterContext.findAnnotation(TempDir.class).orElseThrow(() -&gt; new JUnitException(&quot;Parameter &quot; + parameterContext.getParameter() + &quot; must be annotated with @TempDir&quot;));
&nbsp;        return this.determineCleanupMode(tempDir);
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    private CleanupMode determineCleanupMode(TempDir tempDir) {
<b class="fc">&nbsp;        CleanupMode cleanupMode = tempDir.cleanup();</b>
<b class="nc">&nbsp;        return cleanupMode == CleanupMode.DEFAULT ? this.configuration.getDefaultTempDirCleanupMode() : cleanupMode;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Scope getScope(ExtensionContext context) {
<b class="nc">&nbsp;        return (Scope)context.getRoot().getStore(NAMESPACE).getOrComputeIfAbsent(Scope.class, (__) -&gt; {</b>
<b class="nc">&nbsp;            EnumConfigurationParameterConverter var10000 = new EnumConfigurationParameterConverter(Scope.class, &quot;@TempDir scope&quot;);</b>
<b class="nc">&nbsp;            Objects.requireNonNull(context);</b>
<b class="nc">&nbsp;            return (Scope)var10000.get(&quot;junit.jupiter.tempdir.scope&quot;, context::getConfigurationParameter, TempDirectory.Scope.PER_DECLARATION);</b>
&nbsp;        }, Scope.class);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private TempDirFactory determineTempDirFactoryForField(Field field, Scope scope) {
&nbsp;        TempDir tempDir = (TempDir)AnnotationUtils.findAnnotation(field, TempDir.class).orElseThrow(() -&gt; new JUnitException(&quot;Field &quot; + field + &quot; must be annotated with @TempDir&quot;));
&nbsp;        return this.determineTempDirFactory(tempDir, scope);
&nbsp;    }
&nbsp;
&nbsp;    private TempDirFactory determineTempDirFactoryForParameter(ParameterContext parameterContext, Scope scope) {
&nbsp;        TempDir tempDir = (TempDir)parameterContext.findAnnotation(TempDir.class).orElseThrow(() -&gt; new JUnitException(&quot;Parameter &quot; + parameterContext.getParameter() + &quot; must be annotated with @TempDir&quot;));
&nbsp;        return this.determineTempDirFactory(tempDir, scope);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private TempDirFactory determineTempDirFactory(TempDir tempDir, Scope scope) {</b>
<b class="nc">&nbsp;        Class&lt;? extends TempDirFactory&gt; factory = tempDir.factory();</b>
<b class="nc">&nbsp;        if (factory != TempDirFactory.class &amp;&amp; scope == TempDirectory.Scope.PER_CONTEXT) {</b>
&nbsp;            throw new ExtensionConfigurationException(&quot;Custom @TempDir factory is not supported with junit.jupiter.tempdir.scope=&quot; + TempDirectory.Scope.PER_CONTEXT.name().toLowerCase() + &quot;. Use &quot; + &quot;junit.jupiter.tempdir.factory.default&quot; + &quot; instead.&quot;);
&nbsp;        } else {
<b class="nc">&nbsp;            return factory == TempDirFactory.class ? (TempDirFactory)this.configuration.getDefaultTempDirFactorySupplier().get() : (TempDirFactory)ReflectionUtils.newInstance(factory, new Object[0]);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void assertNonFinalField(Field field) {
&nbsp;        if (ReflectionUtils.isFinal(field)) {
&nbsp;            throw new ExtensionConfigurationException(&quot;@TempDir field [&quot; + field + &quot;] must not be declared as final.&quot;);
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private void assertSupportedType(String target, Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;        if (type != Path.class &amp;&amp; type != File.class) {</b>
<b class="nc">&nbsp;            throw new ExtensionConfigurationException(&quot;Can only resolve @TempDir &quot; + target + &quot; of type &quot; + Path.class.getName() + &quot; or &quot; + File.class.getName() + &quot; but was: &quot; + type.getName());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private Object getPathOrFile(Class&lt;?&gt; elementType, AnnotatedElementContext elementContext, TempDirFactory factory, CleanupMode cleanupMode, Scope scope, ExtensionContext extensionContext) {
&nbsp;        ExtensionContext.Namespace namespace = scope == TempDirectory.Scope.PER_DECLARATION ? NAMESPACE.append(new Object[]{elementContext}) : NAMESPACE;
<b class="nc">&nbsp;        Path path = ((CloseablePath)extensionContext.getStore(namespace).getOrComputeIfAbsent(&quot;temp.dir&quot;, (__) -&gt; createTempDir(factory, cleanupMode, elementType, elementContext, extensionContext), CloseablePath.class)).get();</b>
<b class="nc">&nbsp;        return elementType == Path.class ? path : path.toFile();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    static CloseablePath createTempDir(TempDirFactory factory, CleanupMode cleanupMode, Class&lt;?&gt; elementType, AnnotatedElementContext elementContext, ExtensionContext extensionContext) {
&nbsp;        try {
<b class="nc">&nbsp;            return new CloseablePath(factory, cleanupMode, elementType, elementContext, extensionContext);</b>
<b class="nc">&nbsp;        } catch (Exception ex) {</b>
<b class="nc">&nbsp;            throw new ExtensionConfigurationException(&quot;Failed to create default temp directory&quot;, ex);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static boolean selfOrChildFailed(ExtensionContext context) {</b>
<b class="nc">&nbsp;        return context.getExecutionException().isPresent() || (Boolean)context.getStore(NAMESPACE).getOrDefault(&quot;child.failed&quot;, Boolean.class, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    static class CloseablePath implements ExtensionContext.Store.CloseableResource {
&nbsp;        private static final Logger logger = LoggerFactory.getLogger(CloseablePath.class);
<b class="fc">&nbsp;        private final Path dir;</b>
&nbsp;        private final TempDirFactory factory;
&nbsp;        private final CleanupMode cleanupMode;
<b class="fc">&nbsp;        private final ExtensionContext extensionContext;</b>
&nbsp;
&nbsp;        private CloseablePath(TempDirFactory factory, CleanupMode cleanupMode, Class&lt;?&gt; elementType, AnnotatedElementContext elementContext, ExtensionContext extensionContext) throws Exception {
&nbsp;            this.dir = factory.createTempDirectory(elementContext, extensionContext);
&nbsp;            this.factory = factory;
&nbsp;            this.cleanupMode = cleanupMode;
<b class="nc">&nbsp;            this.extensionContext = extensionContext;</b>
<b class="nc">&nbsp;            if (this.dir != null &amp;&amp; Files.isDirectory(this.dir, new LinkOption[0])) {</b>
<b class="nc">&nbsp;                if (elementType == File.class &amp;&amp; !this.dir.getFileSystem().equals(FileSystems.getDefault())) {</b>
&nbsp;                    this.close();
&nbsp;                    throw new PreconditionViolationException(&quot;temp directory with non-default file system cannot be injected into &quot; + File.class.getName() + &quot; target&quot;);
&nbsp;                }
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                this.close();</b>
<b class="nc">&nbsp;                throw new PreconditionViolationException(&quot;temp directory must be a directory&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        Path get() {
<b class="nc">&nbsp;            return this.dir;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void close() throws IOException {</b>
<b class="nc">&nbsp;            try {</b>
&nbsp;                if (this.cleanupMode != CleanupMode.NEVER &amp;&amp; (this.cleanupMode != CleanupMode.ON_SUCCESS || !TempDirectory.selfOrChildFailed(this.extensionContext))) {
&nbsp;                    FileOperations fileOperations = (FileOperations)this.extensionContext.getStore(TempDirectory.NAMESPACE).getOrDefault(&quot;file.operations&quot;, FileOperations.class, TempDirectory.FileOperations.DEFAULT);
&nbsp;                    SortedMap&lt;Path, IOException&gt; failures = this.deleteAllFilesAndDirectories(fileOperations);
<b class="nc">&nbsp;                    if (failures.isEmpty()) {</b>
<b class="nc">&nbsp;                        return;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    throw this.createIOExceptionWithAttachedFailures(failures);
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                logger.info(() -&gt; &quot;Skipping cleanup of temp dir &quot; + this.dir + &quot; due to cleanup mode configuration.&quot;);</b>
&nbsp;            } finally {
&nbsp;                this.factory.close();
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private SortedMap&lt;Path, IOException&gt; deleteAllFilesAndDirectories(final FileOperations fileOperations) throws IOException {</b>
&nbsp;            if (this.dir != null &amp;&amp; !Files.notExists(this.dir, new LinkOption[0])) {
&nbsp;                final SortedMap&lt;Path, IOException&gt; failures = new TreeMap();
&nbsp;                final Set&lt;Path&gt; retriedPaths = new HashSet();
&nbsp;                tryToResetPermissions(this.dir);
&nbsp;                Files.walkFileTree(this.dir, new SimpleFileVisitor&lt;Path&gt;() {
<b class="nc">&nbsp;                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {</b>
<b class="nc">&nbsp;                        if (!dir.equals(CloseablePath.this.dir)) {</b>
<b class="nc">&nbsp;                            TempDirectory.CloseablePath.tryToResetPermissions(dir);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                        return FileVisitResult.CONTINUE;</b>
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public FileVisitResult visitFileFailed(Path file, IOException exc) {
<b class="nc">&nbsp;                        if (exc instanceof NoSuchFileException) {</b>
&nbsp;                            return FileVisitResult.CONTINUE;
&nbsp;                        } else {
&nbsp;                            this.resetPermissionsAndTryToDeleteAgain(file, exc);
&nbsp;                            return FileVisitResult.CONTINUE;
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public FileVisitResult visitFile(Path file, BasicFileAttributes attributes) {
<b class="nc">&nbsp;                        return this.deleteAndContinue(file);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
&nbsp;                        return this.deleteAndContinue(dir);
<b class="pc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    private FileVisitResult deleteAndContinue(Path path) {
&nbsp;                        try {
&nbsp;                            fileOperations.delete(path);
&nbsp;                        } catch (NoSuchFileException var3) {
&nbsp;                        } catch (DirectoryNotEmptyException exception) {
&nbsp;                            failures.put(path, exception);
&nbsp;                        } catch (IOException exception) {
&nbsp;                            this.resetPermissionsAndTryToDeleteAgain(path, exception);
&nbsp;                        }
&nbsp;
&nbsp;                        return FileVisitResult.CONTINUE;
&nbsp;                    }
&nbsp;
&nbsp;                    private void resetPermissionsAndTryToDeleteAgain(Path path, IOException exception) {
&nbsp;                        boolean notYetRetried = retriedPaths.add(path);
&nbsp;                        if (notYetRetried) {
&nbsp;                            try {
&nbsp;                                TempDirectory.CloseablePath.tryToResetPermissions(path);
&nbsp;                                if (Files.isDirectory(path, new LinkOption[0])) {
&nbsp;                                    Files.walkFileTree(path, this);
&nbsp;                                } else {
&nbsp;                                    fileOperations.delete(path);
&nbsp;                                }
&nbsp;                            } catch (Exception suppressed) {
&nbsp;                                exception.addSuppressed(suppressed);
&nbsp;                                failures.put(path, exception);
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            failures.put(path, exception);
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                });
&nbsp;                return failures;
&nbsp;            } else {
&nbsp;                return Collections.emptySortedMap();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static void tryToResetPermissions(Path path) {
&nbsp;            File file;
&nbsp;            try {
&nbsp;                file = path.toFile();
&nbsp;            } catch (UnsupportedOperationException var5) {
&nbsp;                return;
&nbsp;            }
&nbsp;
&nbsp;            file.setReadable(true);
&nbsp;            file.setWritable(true);
&nbsp;            if (Files.isDirectory(path, new LinkOption[0])) {
&nbsp;                file.setExecutable(true);
&nbsp;            }
&nbsp;
&nbsp;            DosFileAttributeView dos = (DosFileAttributeView)Files.getFileAttributeView(path, DosFileAttributeView.class);
&nbsp;            if (dos != null) {
&nbsp;                try {
&nbsp;                    dos.setReadOnly(false);
&nbsp;                } catch (IOException var4) {
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        private IOException createIOExceptionWithAttachedFailures(SortedMap&lt;Path, IOException&gt; failures) {
&nbsp;            Path emptyPath = Paths.get(&quot;&quot;);
&nbsp;            String joinedPaths = (String)failures.keySet().stream().map(this::tryToDeleteOnExit).map(this::relativizeSafely).map((path) -&gt; emptyPath.equals(path) ? &quot;&lt;root&gt;&quot; : path.toString()).collect(Collectors.joining(&quot;, &quot;));
&nbsp;            IOException exception = new IOException(&quot;Failed to delete temp directory &quot; + this.dir.toAbsolutePath() + &quot;. The following paths could not be deleted (see suppressed exceptions for details): &quot; + joinedPaths);
&nbsp;            Collection var10000 = failures.values();
&nbsp;            Objects.requireNonNull(exception);
&nbsp;            var10000.forEach(exception::addSuppressed);
&nbsp;            return exception;
&nbsp;        }
&nbsp;
&nbsp;        private Path tryToDeleteOnExit(Path path) {
&nbsp;            try {
&nbsp;                path.toFile().deleteOnExit();
&nbsp;            } catch (UnsupportedOperationException var3) {
&nbsp;            }
&nbsp;
&nbsp;            return path;
&nbsp;        }
&nbsp;
&nbsp;        private Path relativizeSafely(Path path) {
&nbsp;            try {
&nbsp;                return this.dir.relativize(path);
&nbsp;            } catch (IllegalArgumentException var3) {
&nbsp;                return path;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static enum Scope {
&nbsp;        PER_CONTEXT,
&nbsp;        PER_DECLARATION;
&nbsp;
&nbsp;        private Scope() {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    interface FileOperations {
&nbsp;        FileOperations DEFAULT = Files::delete;
&nbsp;
&nbsp;        void delete(Path path) throws IOException;
&nbsp;    }
&nbsp;
&nbsp;    private static class FieldContext implements AnnotatedElementContext {
&nbsp;        private final Field field;
&nbsp;
&nbsp;        private FieldContext(Field field) {
&nbsp;            this.field = (Field)Preconditions.notNull(field, &quot;field must not be null&quot;);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotatedElement getAnnotatedElement() {
&nbsp;            return this.field;
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return (new ToStringBuilder(this)).append(&quot;field&quot;, this.field).toString();
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
