


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > AnnotationDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationDescription (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (4/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (8/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.8%
  </span>
  <span class="absValue">
    (19/71)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32.1%
  </span>
  <span class="absValue">
    (18/56)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    34.9%
  </span>
  <span class="absValue">
    (30/86)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Loadable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    54.2%
  </span>
  <span class="absValue">
    (13/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.1%
  </span>
  <span class="absValue">
    (26/96)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.6%
  </span>
  <span class="absValue">
    (50/158)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.AnnotationTypeMismatchException;
&nbsp;import java.lang.annotation.Documented;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.annotation.IncompleteAnnotationException;
&nbsp;import java.lang.annotation.Inherited;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.annotation.Target;
&nbsp;import java.lang.reflect.InvocationHandler;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForAnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForConstant;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForDescriptionArray;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForEnumerationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.ForTypeDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue.State;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.privilege.SetAccessibleAction;
&nbsp;
&nbsp;public interface AnnotationDescription {
&nbsp;    @AlwaysNull
&nbsp;    Loadable&lt;?&gt; UNDEFINED = null;
&nbsp;
&nbsp;    AnnotationValue&lt;?, ?&gt; getValue(String var1);
&nbsp;
&nbsp;    AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape var1);
&nbsp;
&nbsp;    TypeDescription getAnnotationType();
&nbsp;
&nbsp;    &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; var1);
&nbsp;
<b class="fc">&nbsp;    RetentionPolicy getRetention();</b>
&nbsp;
&nbsp;    Set&lt;ElementType&gt; getElementTypes();
&nbsp;
&nbsp;    boolean isSupportedOn(ElementType var1);
&nbsp;
&nbsp;    boolean isSupportedOn(String var1);
&nbsp;
&nbsp;    boolean isInherited();
&nbsp;
&nbsp;    boolean isDocumented();
&nbsp;
&nbsp;    public static enum RenderingDispatcher {
&nbsp;        LEGACY_VM,
&nbsp;        JAVA_14_CAPABLE_VM {
&nbsp;            public void appendPrefix(StringBuilder toString, String key, int count) {
&nbsp;                if (count &gt; 1 || !key.equals(&quot;value&quot;)) {
&nbsp;                    super.appendPrefix(toString, key, count);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        },
&nbsp;        JAVA_19_CAPABLE_VM {
&nbsp;            public void appendPrefix(StringBuilder toString, String key, int count) {
&nbsp;                if (count &gt; 1 || !key.equals(&quot;value&quot;)) {
&nbsp;                    super.appendPrefix(toString, key, count);
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;
&nbsp;            public void appendType(StringBuilder toString, TypeDescription typeDescription) {
&nbsp;                toString.append(typeDescription.getCanonicalName());
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        public static final RenderingDispatcher CURRENT;
&nbsp;
&nbsp;        private RenderingDispatcher() {
&nbsp;        }
&nbsp;
&nbsp;        public void appendPrefix(StringBuilder toString, String key, int count) {
&nbsp;            toString.append(key).append(&#39;=&#39;);
&nbsp;        }
&nbsp;
&nbsp;        public void appendType(StringBuilder toString, TypeDescription typeDescription) {
&nbsp;            toString.append(typeDescription.getName());
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);
&nbsp;            if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V19)) {
&nbsp;                CURRENT = JAVA_19_CAPABLE_VM;
&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {
&nbsp;                CURRENT = JAVA_14_CAPABLE_VM;
&nbsp;            } else {
&nbsp;                CURRENT = LEGACY_VM;
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class AnnotationInvocationHandler&lt;T extends Annotation&gt; implements InvocationHandler {
&nbsp;        private static final String HASH_CODE = &quot;hashCode&quot;;
&nbsp;        private static final String EQUALS = &quot;equals&quot;;
&nbsp;        private static final String TO_STRING = &quot;toString&quot;;
&nbsp;        private static final String ANNOTATION_TYPE = &quot;annotationType&quot;;
&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];
&nbsp;        private final Class&lt;? extends Annotation&gt; annotationType;
&nbsp;        private final LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;        protected AnnotationInvocationHandler(Class&lt;T&gt; annotationType, LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values) {
&nbsp;            this.annotationType = annotationType;
&nbsp;            this.values = values;
&nbsp;        }
&nbsp;
&nbsp;        public static &lt;S extends Annotation&gt; S of(@MaybeNull ClassLoader classLoader, Class&lt;S&gt; annotationType, Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; values) {
&nbsp;            LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; loadedValues = new LinkedHashMap();
&nbsp;
&nbsp;            for(Method method : annotationType.getDeclaredMethods()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue)values.get(method.getName());
&nbsp;                if (annotationValue == null) {
&nbsp;                    Object defaultValue = method.getDefaultValue();
&nbsp;                    loadedValues.put(method, ((AnnotationValue)(defaultValue == null ? new AnnotationValue.ForMissingValue(new TypeDescription.ForLoadedType(method.getDeclaringClass()), method.getName()) : AnnotationDescription.ForLoadedAnnotation.asValue(defaultValue, method.getReturnType()))).load(classLoader));
&nbsp;                } else {
&nbsp;                    loadedValues.put(method, annotationValue.filter(new MethodDescription.ForLoadedMethod(method)).load(classLoader));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return (S)(Proxy.newProxyInstance(classLoader, new Class[]{annotationType}, new AnnotationInvocationHandler(annotationType, loadedValues)));
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) {
&nbsp;            if (method.getDeclaringClass() != this.annotationType) {
&nbsp;                if (method.getName().equals(&quot;hashCode&quot;)) {
&nbsp;                    return this.hashCodeRepresentation();
&nbsp;                } else if (method.getName().equals(&quot;equals&quot;) &amp;&amp; method.getParameterTypes().length == 1) {
&nbsp;                    return this.equalsRepresentation(proxy, argument[0]);
&nbsp;                } else if (method.getName().equals(&quot;toString&quot;)) {
&nbsp;                    return this.toStringRepresentation();
&nbsp;                } else if (method.getName().equals(&quot;annotationType&quot;)) {
&nbsp;                    return this.annotationType;
&nbsp;                } else {
&nbsp;                    throw new IllegalStateException(&quot;Unexpected method: &quot; + method);
&nbsp;                }
&nbsp;            } else {
&nbsp;                return ((AnnotationValue.Loaded)this.values.get(method)).resolve();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected String toStringRepresentation() {
&nbsp;            StringBuilder toString = new StringBuilder();
&nbsp;            toString.append(&#39;@&#39;);
&nbsp;            AnnotationDescription.RenderingDispatcher.CURRENT.appendType(toString, ForLoadedType.of(this.annotationType));
&nbsp;            toString.append(&#39;(&#39;);
&nbsp;            boolean firstMember = true;
&nbsp;
&nbsp;            for(Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : this.values.entrySet()) {
&nbsp;                if (((AnnotationValue.Loaded)entry.getValue()).getState().isDefined()) {
&nbsp;                    if (firstMember) {
&nbsp;                        firstMember = false;
&nbsp;                    } else {
&nbsp;                        toString.append(&quot;, &quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    AnnotationDescription.RenderingDispatcher.CURRENT.appendPrefix(toString, ((Method)entry.getKey()).getName(), this.values.entrySet().size());
&nbsp;                    toString.append(((AnnotationValue.Loaded)entry.getValue()).toString());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            toString.append(&#39;)&#39;);
&nbsp;            return toString.toString();
&nbsp;        }
&nbsp;
&nbsp;        private int hashCodeRepresentation() {
&nbsp;            int hashCode = 0;
&nbsp;
&nbsp;            for(Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : this.values.entrySet()) {
&nbsp;                if (((AnnotationValue.Loaded)entry.getValue()).getState().isDefined()) {
&nbsp;                    hashCode += 127 * ((Method)entry.getKey()).getName().hashCode() ^ ((AnnotationValue.Loaded)entry.getValue()).hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return hashCode;
&nbsp;        }
&nbsp;
&nbsp;        private boolean equalsRepresentation(Object self, Object other) {
&nbsp;            if (self == other) {
&nbsp;                return true;
&nbsp;            } else if (!this.annotationType.isInstance(other)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                if (Proxy.isProxyClass(other.getClass())) {
&nbsp;                    InvocationHandler invocationHandler = Proxy.getInvocationHandler(other);
&nbsp;                    if (invocationHandler instanceof AnnotationInvocationHandler) {
&nbsp;                        return invocationHandler.equals(this);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                try {
&nbsp;                    for(Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : this.values.entrySet()) {
&nbsp;                        try {
&nbsp;                            if (!((AnnotationValue.Loaded)entry.getValue()).represents(((Method)entry.getKey()).invoke(other, NO_ARGUMENT))) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        } catch (RuntimeException var6) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                } catch (InvocationTargetException var7) {
&nbsp;                    return false;
&nbsp;                } catch (IllegalAccessException exception) {
&nbsp;                    throw new IllegalStateException(&quot;Could not access annotation property&quot;, exception);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = this.annotationType.hashCode();
&nbsp;                result = 31 * result + this.values.hashCode();
&nbsp;
&nbsp;                for(Map.Entry&lt;Method, ?&gt; entry : this.values.entrySet()) {
&nbsp;                    result = 31 * result + entry.getValue().hashCode();
&nbsp;                }
&nbsp;
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof AnnotationInvocationHandler)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                AnnotationInvocationHandler&lt;?&gt; that = (AnnotationInvocationHandler)other;
&nbsp;                if (!this.annotationType.equals(that.annotationType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    for(Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : this.values.entrySet()) {
&nbsp;                        if (!((AnnotationValue.Loaded)entry.getValue()).equals(that.values.get(entry.getKey()))) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public abstract static class AbstractBase implements AnnotationDescription {
&nbsp;        private static final Set&lt;ElementType&gt; DEFAULT_TARGET = new HashSet();
&nbsp;        private static final MethodDescription.InDefinedShape RETENTION_VALUE;
&nbsp;        private static final MethodDescription.InDefinedShape TARGET_VALUE;
&nbsp;
&nbsp;        public AbstractBase() {
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(String property) {
&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; candidates = (MethodList)this.getAnnotationType().getDeclaredMethods().filter(ElementMatchers.named(property).and(ElementMatchers.takesArguments(0)).and(ElementMatchers.isPublic()).and(ElementMatchers.not(ElementMatchers.isStatic())));
&nbsp;            if (candidates.size() == 1) {
&nbsp;                return this.getValue((MethodDescription.InDefinedShape)candidates.getOnly());
&nbsp;            } else {
&nbsp;                throw new IllegalArgumentException(&quot;Unknown property of &quot; + this.getAnnotationType() + &quot;: &quot; + property);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public RetentionPolicy getRetention() {
&nbsp;            Loadable&lt;Retention&gt; retention = this.getAnnotationType().getDeclaredAnnotations().ofType(Retention.class);
&nbsp;            return retention == null ? RetentionPolicy.CLASS : (RetentionPolicy)retention.getValue(RETENTION_VALUE).load(ClassLoadingStrategy.BOOTSTRAP_LOADER).resolve(RetentionPolicy.class);
&nbsp;        }
&nbsp;
&nbsp;        public Set&lt;ElementType&gt; getElementTypes() {
&nbsp;            Loadable&lt;Target&gt; target = this.getAnnotationType().getDeclaredAnnotations().ofType(Target.class);
&nbsp;            return (Set&lt;ElementType&gt;)(target == null ? Collections.unmodifiableSet(DEFAULT_TARGET) : new HashSet(Arrays.asList(target.getValue(TARGET_VALUE).load(ClassLoadingStrategy.BOOTSTRAP_LOADER).resolve(ElementType[].class))));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSupportedOn(ElementType elementType) {
&nbsp;            return this.isSupportedOn(elementType.name());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSupportedOn(String elementType) {
&nbsp;            Loadable&lt;Target&gt; target = this.getAnnotationType().getDeclaredAnnotations().ofType(Target.class);
&nbsp;            if (target == null) {
&nbsp;                if (elementType.equals(&quot;TYPE_USE&quot;)) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                for(ElementType candidate : DEFAULT_TARGET) {
&nbsp;                    if (candidate.name().equals(elementType)) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
&nbsp;                for(EnumerationDescription enumerationDescription : (EnumerationDescription[])target.getValue(TARGET_VALUE).resolve(EnumerationDescription[].class)) {
&nbsp;                    if (enumerationDescription.getValue().equals(elementType)) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInherited() {
&nbsp;            return this.getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Inherited.class);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isDocumented() {
&nbsp;            return this.getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Documented.class);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                AbstractBase var2 = this;
&nbsp;                int hashCode = 0;
&nbsp;
&nbsp;                for(MethodDescription.InDefinedShape methodDescription : this.getAnnotationType().getDeclaredMethods()) {
&nbsp;                    hashCode += 31 * var2.getValue(methodDescription).hashCode();
&nbsp;                }
&nbsp;
&nbsp;                var10000 = hashCode;
&nbsp;            }
&nbsp;
&nbsp;            int var7 = var10000;
&nbsp;            if (var7 == 0) {
&nbsp;                var7 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var7;
&nbsp;            }
&nbsp;
&nbsp;            return var7;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof AnnotationDescription)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                AnnotationDescription annotationDescription = (AnnotationDescription)other;
&nbsp;                TypeDescription annotationType = this.getAnnotationType();
&nbsp;                if (!annotationDescription.getAnnotationType().equals(annotationType)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    for(MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {
&nbsp;                        if (!this.getValue(methodDescription).equals(annotationDescription.getValue(methodDescription))) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            TypeDescription annotationType = this.getAnnotationType();
&nbsp;            StringBuilder toString = (new StringBuilder()).append(&#39;@&#39;);
&nbsp;            AnnotationDescription.RenderingDispatcher.CURRENT.appendType(toString, annotationType);
&nbsp;            toString.append(&#39;(&#39;);
&nbsp;            boolean firstMember = true;
&nbsp;
&nbsp;            for(MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; value = this.getValue(methodDescription);
&nbsp;                if (value.getState() != State.UNDEFINED) {
&nbsp;                    if (firstMember) {
&nbsp;                        firstMember = false;
&nbsp;                    } else {
&nbsp;                        toString.append(&quot;, &quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    AnnotationDescription.RenderingDispatcher.CURRENT.appendPrefix(toString, methodDescription.getName(), annotationType.getDeclaredMethods().size());
&nbsp;                    toString.append(value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return toString.append(&#39;)&#39;).toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            for(ElementType elementType : ElementType.values()) {
&nbsp;                if (!elementType.name().equals(&quot;TYPE_PARAMETER&quot;)) {
&nbsp;                    DEFAULT_TARGET.add(elementType);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            RETENTION_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(Retention.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;            TARGET_VALUE = (MethodDescription.InDefinedShape)((MethodList)ForLoadedType.of(Target.class).getDeclaredMethods().filter(ElementMatchers.named(&quot;value&quot;))).getOnly();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ForLoadedAnnotation&lt;S extends Annotation&gt; extends AbstractBase implements Loadable&lt;S&gt; {
&nbsp;        private static final Object[] NO_ARGUMENT;
&nbsp;        private final S annotation;
&nbsp;        private final Class&lt;S&gt; annotationType;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        protected ForLoadedAnnotation(S annotation) {
&nbsp;            this(annotation, annotation.annotationType());
&nbsp;        }
&nbsp;
&nbsp;        private ForLoadedAnnotation(S annotation, Class&lt;S&gt; annotationType) {
&nbsp;            this.annotation = annotation;
&nbsp;            this.annotationType = annotationType;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public static &lt;U extends Annotation&gt; Loadable&lt;U&gt; of(U annotation) {
&nbsp;            return new ForLoadedAnnotation&lt;U&gt;(annotation);
&nbsp;        }
&nbsp;
&nbsp;        public S load() {
&nbsp;            return (S)(this.annotationType == this.annotation.annotationType() ? this.annotation : AnnotationDescription.AnnotationInvocationHandler.of(this.annotationType.getClassLoader(), this.annotationType, asValue(this.annotation)));
&nbsp;        }
&nbsp;
&nbsp;        private static Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; asValue(Annotation annotation) {
&nbsp;            Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap();
&nbsp;
&nbsp;            for(Method property : annotation.annotationType().getDeclaredMethods()) {
&nbsp;                try {
&nbsp;                    annotationValues.put(property.getName(), asValue(property.invoke(annotation, NO_ARGUMENT), property.getReturnType()));
&nbsp;                } catch (InvocationTargetException exception) {
&nbsp;                    Throwable cause = exception.getTargetException();
&nbsp;                    if (cause instanceof TypeNotPresentException) {
&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForMissingType(((TypeNotPresentException)cause).typeName()));
&nbsp;                    } else if (cause instanceof EnumConstantNotPresentException) {
&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(new TypeDescription.ForLoadedType(((EnumConstantNotPresentException)cause).enumType()), ((EnumConstantNotPresentException)cause).constantName()));
&nbsp;                    } else if (cause instanceof AnnotationTypeMismatchException) {
<b class="fc">&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForMismatchedType(new MethodDescription.ForLoadedMethod(((AnnotationTypeMismatchException)cause).element()), ((AnnotationTypeMismatchException)cause).foundType()));</b>
<b class="fc">&nbsp;                    } else if (!(cause instanceof IncompleteAnnotationException)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot read &quot; + property, cause);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } catch (IllegalAccessException exception) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + property, exception);
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            return annotationValues;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public static AnnotationValue&lt;?, ?&gt; asValue(Object value, Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;            if (Enum.class.isAssignableFrom(type)) {</b>
&nbsp;                return ForEnumerationDescription.of(new EnumerationDescription.ForLoadedEnumeration((Enum)value));
&nbsp;            } else if (Enum[].class.isAssignableFrom(type)) {
&nbsp;                Enum&lt;?&gt;[] element = (Enum[])value;
&nbsp;                EnumerationDescription[] enumerationDescription = new EnumerationDescription[element.length];
&nbsp;                int index = 0;
&nbsp;
<b class="nc">&nbsp;                for(Enum&lt;?&gt; anElement : element) {</b>
<b class="nc">&nbsp;                    enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(anElement);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                return ForDescriptionArray.of(ForLoadedType.of(type.getComponentType()), enumerationDescription);</b>
<b class="nc">&nbsp;            } else if (Annotation.class.isAssignableFrom(type)) {</b>
&nbsp;                return ForAnnotationDescription.of(ForLoadedType.of(type), asValue((Annotation)value));
<b class="nc">&nbsp;            } else if (Annotation[].class.isAssignableFrom(type)) {</b>
&nbsp;                Annotation[] element = (Annotation[])value;
&nbsp;                AnnotationDescription[] annotationDescription = new AnnotationDescription[element.length];
&nbsp;                int index = 0;
&nbsp;
&nbsp;                for(Annotation anElement : element) {
&nbsp;                    annotationDescription[index++] = new Latent(ForLoadedType.of(type.getComponentType()), asValue(anElement));
&nbsp;                }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                return ForDescriptionArray.of(ForLoadedType.of(type.getComponentType()), annotationDescription);</b>
&nbsp;            } else if (Class.class.isAssignableFrom(type)) {
<b class="nc">&nbsp;                return ForTypeDescription.of(ForLoadedType.of((Class)value));</b>
&nbsp;            } else if (!Class[].class.isAssignableFrom(type)) {
&nbsp;                return ForConstant.of(value);
&nbsp;            } else {
&nbsp;                Class&lt;?&gt;[] element = (Class[])value;
&nbsp;                TypeDescription[] typeDescription = new TypeDescription[element.length];
&nbsp;                int index = 0;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                for(Class&lt;?&gt; anElement : element) {</b>
<b class="nc">&nbsp;                    typeDescription[index++] = ForLoadedType.of(anElement);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                return ForDescriptionArray.of(typeDescription);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
<b class="fc">&nbsp;            value = {&quot;REC_CATCH_EXCEPTION&quot;},</b>
&nbsp;            justification = &quot;Exception should always be wrapped for clarity.&quot;
&nbsp;        )
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;            if (!property.getDeclaringType().represents(this.annotation.annotationType())) {
&nbsp;                throw new IllegalArgumentException(property + &quot; does not represent &quot; + this.annotation.annotationType());
&nbsp;            } else {
<b class="fc">&nbsp;                try {</b>
<b class="pc">&nbsp;                    boolean accessible = property.getDeclaringType().isPublic();</b>
<b class="nc">&nbsp;                    Method method = property instanceof MethodDescription.ForLoadedMethod ? ((MethodDescription.ForLoadedMethod)property).getLoadedMethod() : null;</b>
<b class="nc">&nbsp;                    if (method == null || method.getDeclaringClass() != this.annotation.annotationType() || !accessible &amp;&amp; !method.isAccessible()) {</b>
&nbsp;                        method = this.annotation.annotationType().getMethod(property.getName());
<b class="nc">&nbsp;                        if (!accessible) {</b>
<b class="nc">&nbsp;                            doPrivileged(new SetAccessibleAction(method));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    return asValue(method.invoke(this.annotation, NO_ARGUMENT), method.getReturnType()).filter(property);
<b class="pc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                    Throwable cause = exception.getTargetException();</b>
<b class="fc">&nbsp;                    if (cause instanceof TypeNotPresentException) {</b>
&nbsp;                        return new AnnotationValue.ForMissingType(((TypeNotPresentException)cause).typeName());
&nbsp;                    } else if (cause instanceof EnumConstantNotPresentException) {
&nbsp;                        return new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(new TypeDescription.ForLoadedType(((EnumConstantNotPresentException)cause).enumType()), ((EnumConstantNotPresentException)cause).constantName());
<b class="nc">&nbsp;                    } else if (cause instanceof AnnotationTypeMismatchException) {</b>
&nbsp;                        return new AnnotationValue.ForMismatchedType(new MethodDescription.ForLoadedMethod(((AnnotationTypeMismatchException)cause).element()), ((AnnotationTypeMismatchException)cause).foundType());
&nbsp;                    } else if (cause instanceof IncompleteAnnotationException) {
&nbsp;                        return new AnnotationValue.ForMissingValue(new TypeDescription.ForLoadedType(((IncompleteAnnotationException)cause).annotationType()), ((IncompleteAnnotationException)cause).elementName());
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Error reading annotation property &quot; + property, cause);
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Exception exception) {</b>
&nbsp;                    throw new IllegalStateException(&quot;Cannot access annotation property &quot; + property, exception);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="nc">&nbsp;            if (!this.annotation.annotationType().getName().equals(annotationType.getName())) {</b>
&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotation.annotationType());
&nbsp;            } else {
&nbsp;                return annotationType == this.annotation.annotationType() ? this : new ForLoadedAnnotation(this.annotation, annotationType);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public TypeDescription getAnnotationType() {</b>
<b class="nc">&nbsp;            return ForLoadedType.of(this.annotation.annotationType());</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
<b class="nc">&nbsp;            } catch (ClassNotFoundException var0) {</b>
<b class="nc">&nbsp;                ACCESS_CONTROLLER = false;</b>
<b class="nc">&nbsp;            } catch (SecurityException var1) {</b>
<b class="nc">&nbsp;                ACCESS_CONTROLLER = true;</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            NO_ARGUMENT = new Object[0];</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public static class Latent extends AbstractBase {</b>
<b class="nc">&nbsp;        private final TypeDescription annotationType;</b>
<b class="nc">&nbsp;        private final Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues;</b>
&nbsp;
&nbsp;        protected Latent(TypeDescription annotationType, Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
<b class="nc">&nbsp;            this.annotationType = annotationType;</b>
&nbsp;            this.annotationValues = annotationValues;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="nc">&nbsp;            if (!property.getDeclaringType().equals(this.annotationType)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a property of &quot; + this.annotationType + &quot;: &quot; + property);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                AnnotationValue&lt;?, ?&gt; value = (AnnotationValue)this.annotationValues.get(property.getName());</b>
<b class="nc">&nbsp;                if (value != null) {</b>
<b class="nc">&nbsp;                    return value.filter(property);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    AnnotationValue&lt;?, ?&gt; defaultValue = property.getDefaultValue();</b>
&nbsp;                    return (AnnotationValue&lt;?, ?&gt;)(defaultValue == null ? new AnnotationValue.ForMissingValue(this.annotationType, property.getName()) : defaultValue);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public TypeDescription getAnnotationType() {
<b class="nc">&nbsp;            return this.annotationType;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {</b>
&nbsp;            if (!this.annotationType.represents(annotationType)) {
&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);
&nbsp;            } else {
&nbsp;                return new Loadable&lt;T&gt;(annotationType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected class Loadable&lt;S extends Annotation&gt; extends AbstractBase implements Loadable&lt;S&gt; {
&nbsp;            private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;            protected Loadable(Class&lt;S&gt; annotationType) {
&nbsp;                this.annotationType = annotationType;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public S load() {
&nbsp;                return (S)AnnotationDescription.AnnotationInvocationHandler.of(this.annotationType.getClassLoader(), this.annotationType, Latent.this.annotationValues);
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
&nbsp;                return Latent.this.getValue(property);
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription getAnnotationType() {
&nbsp;                return ForLoadedType.of(this.annotationType);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
&nbsp;                return Latent.this.prepare(annotationType);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    public static class Builder {</b>
&nbsp;        private final TypeDescription annotationType;
&nbsp;        private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues;
&nbsp;
&nbsp;        protected Builder(TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
&nbsp;            this.annotationType = annotationType;
&nbsp;            this.annotationValues = annotationValues;
&nbsp;        }
&nbsp;
&nbsp;        public static Builder ofType(Class&lt;? extends Annotation&gt; annotationType) {
<b class="fc">&nbsp;            return ofType(ForLoadedType.of(annotationType));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public static Builder ofType(TypeDescription annotationType) {
&nbsp;            if (!annotationType.isAnnotation()) {
&nbsp;                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);
&nbsp;            } else {
&nbsp;                return new Builder(annotationType, Collections.emptyMap());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public Builder define(String property, AnnotationValue&lt;?, ?&gt; value) {
&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodDescriptions = (MethodList)this.annotationType.getDeclaredMethods().filter(ElementMatchers.named(property));
&nbsp;            if (methodDescriptions.isEmpty()) {
<b class="nc">&nbsp;                throw new IllegalArgumentException(this.annotationType + &quot; does not define a property named &quot; + property);</b>
&nbsp;            } else {
&nbsp;                Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap(this.annotationValues);
&nbsp;                if (annotationValues.put(((MethodDescription.InDefinedShape)methodDescriptions.getOnly()).getName(), value) != null) {
&nbsp;                    throw new IllegalArgumentException(&quot;Property already defined: &quot; + property);
&nbsp;                } else {
&nbsp;                    return new Builder(this.annotationType, annotationValues);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Builder define(String property, Enum&lt;?&gt; value) {</b>
&nbsp;            return this.define(property, new EnumerationDescription.ForLoadedEnumeration(value));
&nbsp;        }
&nbsp;
&nbsp;        public Builder define(String property, TypeDescription enumerationType, String value) {
&nbsp;            return this.define(property, new EnumerationDescription.Latent(enumerationType, value));
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Builder define(String property, EnumerationDescription value) {
<b class="nc">&nbsp;            return this.define(property, ForEnumerationDescription.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        public Builder define(String property, Annotation annotation) {
&nbsp;            return this.define(property, new ForLoadedAnnotation(annotation));
&nbsp;        }
&nbsp;
&nbsp;        public Builder define(String property, AnnotationDescription annotationDescription) {
&nbsp;            return this.define(property, new AnnotationValue.ForAnnotationDescription(annotationDescription));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public Builder define(String property, Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;            return this.define(property, ForLoadedType.of(type));</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Builder define(String property, TypeDescription typeDescription) {
<b class="nc">&nbsp;            return this.define(property, ForTypeDescription.of(typeDescription));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; Builder defineEnumerationArray(String property, Class&lt;T&gt; enumerationType, T... value) {</b>
<b class="nc">&nbsp;            EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];</b>
<b class="nc">&nbsp;            int index = 0;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            for(T aValue : value) {</b>
<b class="nc">&nbsp;                enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(aValue);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return this.defineEnumerationArray(property, ForLoadedType.of(enumerationType), enumerationDescription);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, String... value) {
<b class="nc">&nbsp;            if (!enumerationType.isEnum()) {</b>
&nbsp;                throw new IllegalArgumentException(&quot;Not an enumeration type: &quot; + enumerationType);
&nbsp;            } else {
<b class="nc">&nbsp;                EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];</b>
&nbsp;
&nbsp;                for(int i = 0; i &lt; value.length; ++i) {
&nbsp;                    enumerationDescription[i] = new EnumerationDescription.Latent(enumerationType, value[i]);
&nbsp;                }
&nbsp;
&nbsp;                return this.defineEnumerationArray(property, enumerationType, enumerationDescription);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, EnumerationDescription... value) {
&nbsp;            return this.define(property, ForDescriptionArray.of(enumerationType, value));
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public &lt;T extends Annotation&gt; Builder defineAnnotationArray(String property, Class&lt;T&gt; annotationType, T... annotation) {</b>
<b class="fc">&nbsp;            return this.defineAnnotationArray(property, ForLoadedType.of(annotationType), (AnnotationDescription[])(new AnnotationList.ForLoadedAnnotations(annotation)).toArray(new AnnotationDescription[0]));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public Builder defineAnnotationArray(String property, TypeDescription annotationType, AnnotationDescription... annotationDescription) {</b>
<b class="fc">&nbsp;            return this.define(property, ForDescriptionArray.of(annotationType, annotationDescription));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        public Builder defineTypeArray(String property, Class&lt;?&gt;... type) {</b>
<b class="pc">&nbsp;            return this.defineTypeArray(property, (TypeDescription[])(new TypeList.ForLoadedTypes(type)).toArray(new TypeDescription[0]));</b>
<b class="nc">&nbsp;        }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder defineTypeArray(String property, TypeDescription... typeDescription) {</b>
<b class="nc">&nbsp;            return this.define(property, ForDescriptionArray.of(typeDescription));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder define(String property, boolean value) {</b>
&nbsp;            return this.define(property, ForConstant.of(value));
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public Builder define(String property, byte value) {</b>
<b class="pc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder define(String property, char value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Builder define(String property, short value) {</b>
&nbsp;            return this.define(property, ForConstant.of(value));
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Builder define(String property, int value) {
&nbsp;            return this.define(property, ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        public Builder define(String property, long value) {
&nbsp;            return this.define(property, ForConstant.of(value));
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public Builder define(String property, float value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Builder define(String property, double value) {</b>
<b class="pc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="pc">&nbsp;        public Builder define(String property, String value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public Builder defineArray(String property, boolean... value) {
&nbsp;            return this.define(property, ForConstant.of(value));
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Builder defineArray(String property, byte... value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder defineArray(String property, char... value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder defineArray(String property, short... value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Builder defineArray(String property, int... value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Builder defineArray(String property, long... value) {</b>
&nbsp;            return this.define(property, ForConstant.of(value));
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Builder defineArray(String property, float... value) {
&nbsp;            return this.define(property, ForConstant.of(value));
&nbsp;        }
&nbsp;
&nbsp;        public Builder defineArray(String property, double... value) {
&nbsp;            return this.define(property, ForConstant.of(value));
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public Builder defineArray(String property, String... value) {</b>
<b class="nc">&nbsp;            return this.define(property, ForConstant.of(value));</b>
&nbsp;        }
<b class="pc">&nbsp;</b>
&nbsp;        public AnnotationDescription build() {
&nbsp;            for(MethodDescription.InDefinedShape methodDescription : this.annotationType.getDeclaredMethods()) {
&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue)this.annotationValues.get(methodDescription.getName());
&nbsp;                if (annotationValue == null &amp;&amp; methodDescription.getDefaultValue() == null) {
&nbsp;                    throw new IllegalStateException(&quot;No value or default value defined for &quot; + methodDescription.getName());
&nbsp;                }
&nbsp;
&nbsp;                if (annotationValue != null &amp;&amp; annotationValue.filter(methodDescription).getState() != State.RESOLVED) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Illegal annotation value for &quot; + methodDescription + &quot;: &quot; + annotationValue);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return new Latent(this.annotationType, this.annotationValues);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationDescription build(boolean validated) {
&nbsp;            return (AnnotationDescription)(validated ? this.build() : new Latent(this.annotationType, this.annotationValues));
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.annotationType.equals(((Builder)var1).annotationType)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.annotationValues.equals(((Builder)var1).annotationValues);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (this.getClass().hashCode() * 31 + this.annotationType.hashCode()) * 31 + this.annotationValues.hashCode();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Loadable&lt;S extends Annotation&gt; extends AnnotationDescription {
&nbsp;        S load();
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
