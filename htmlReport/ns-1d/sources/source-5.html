


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > TypeDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: TypeDescription (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (24/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.4%
  </span>
  <span class="absValue">
    (59/340)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32.5%
  </span>
  <span class="absValue">
    (80/246)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$OfSimpleType</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.8%
  </span>
  <span class="absValue">
    (5/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.9%
  </span>
  <span class="absValue">
    (14/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ArrayProjection</td>
<td class="coverageStat">
  <span class="percent">
    28.1%
  </span>
  <span class="absValue">
    (9/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.5%
  </span>
  <span class="absValue">
    (12/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39.7%
  </span>
  <span class="absValue">
    (23/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    79.2%
  </span>
  <span class="absValue">
    (38/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.2%
  </span>
  <span class="absValue">
    (31/88)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65%
  </span>
  <span class="absValue">
    (89/137)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Chained</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableExceptionType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableExceptionType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableParameterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableParameterType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedInterface</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedMethodReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedMethodReturnType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType$AnnotatedParameterizedType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument$AnnotatedParameterizedType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$AnnotatedTypeVariable</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$OfFormalTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$OfFormalTypeVariable$FormalTypeVariable</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardUpperBoundType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardUpperBoundType$AnnotatedWildcardType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    21.4%
  </span>
  <span class="absValue">
    (3/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.7%
  </span>
  <span class="absValue">
    (4/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection</td>
<td class="coverageStat">
  <span class="percent">
    45.8%
  </span>
  <span class="absValue">
    (11/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.8%
  </span>
  <span class="absValue">
    (11/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithResolvedErasure</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProxy</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    30.8%
  </span>
  <span class="absValue">
    (8/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (6/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.9%
  </span>
  <span class="absValue">
    (12/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    48%
  </span>
  <span class="absValue">
    (12/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.7%
  </span>
  <span class="absValue">
    (5/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.4%
  </span>
  <span class="absValue">
    (18/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (38/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    28%
  </span>
  <span class="absValue">
    (7/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    8.3%
  </span>
  <span class="absValue">
    (3/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18%
  </span>
  <span class="absValue">
    (11/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForGenerifiedErasure</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (1/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType$ParameterArgumentTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (5/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10%
  </span>
  <span class="absValue">
    (1/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.9%
  </span>
  <span class="absValue">
    (8/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (6/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$ForLoadedType$TypeVariableBoundList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$Symbolic</td>
<td class="coverageStat">
  <span class="percent">
    17.2%
  </span>
  <span class="absValue">
    (5/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.4%
  </span>
  <span class="absValue">
    (7/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$WithAnnotationOverlay</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (2/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    4.3%
  </span>
  <span class="absValue">
    (2/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType$WildcardLowerBoundTypeList</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType$WildcardUpperBoundTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForRawType</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.8%
  </span>
  <span class="absValue">
    (17/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor$OfTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.8%
  </span>
  <span class="absValue">
    (3/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reducing</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.7%
  </span>
  <span class="absValue">
    (5/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForAttachment</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForDetachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$WithoutTypeSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (20/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$1</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$2</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$ForTypeAnnotations</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40.6%
  </span>
  <span class="absValue">
    (13/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (22/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$LazyProxy</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    55.3%
  </span>
  <span class="absValue">
    (326/589)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.4%
  </span>
  <span class="absValue">
    (195/738)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.5%
  </span>
  <span class="absValue">
    (647/1257)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AccessibleObject;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.GenericArrayType;
&nbsp;import java.lang.reflect.GenericDeclaration;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.InvocationHandler;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.ParameterizedType;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.lang.reflect.WildcardType;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource.Empty;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForLoadedTypes.OfTypeVariables;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureVisitor;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.FieldComparator;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Defaults;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Instance;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
<b class="fc">&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;</b>
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;
&nbsp;public interface TypeDescription extends TypeDefinition, ByteCodeElement, TypeVariableSource {
&nbsp;    /** @deprecated */
&nbsp;    @Deprecated
&nbsp;    TypeDescription OBJECT = TypeDescription.LazyProxy.of(Object.class);
&nbsp;    /** @deprecated */
<b class="fc">&nbsp;    @Deprecated</b>
&nbsp;    TypeDescription STRING = TypeDescription.LazyProxy.of(String.class);
&nbsp;    /** @deprecated */
&nbsp;    @Deprecated
&nbsp;    TypeDescription CLASS = TypeDescription.LazyProxy.of(Class.class);
&nbsp;    /** @deprecated */
&nbsp;    @Deprecated
&nbsp;    TypeDescription THROWABLE = TypeDescription.LazyProxy.of(Throwable.class);
<b class="fc">&nbsp;    /** @deprecated */</b>
&nbsp;    @Deprecated
&nbsp;    TypeDescription VOID = TypeDescription.LazyProxy.of(Void.TYPE);
&nbsp;    TypeList.Generic ARRAY_INTERFACES = new TypeList.Generic.ForLoadedTypes(new Type[]{Cloneable.class, Serializable.class});
&nbsp;    @AlwaysNull
&nbsp;    TypeDescription UNDEFINED = null;
&nbsp;
&nbsp;    FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields();
<b class="fc">&nbsp;</b>
&nbsp;    MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;    RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents();
&nbsp;
&nbsp;    boolean isInstance(Object var1);
&nbsp;
&nbsp;    boolean isAssignableFrom(Class&lt;?&gt; var1);
<b class="fc">&nbsp;</b>
&nbsp;    boolean isAssignableFrom(TypeDescription var1);
&nbsp;
&nbsp;    boolean isAssignableTo(Class&lt;?&gt; var1);
&nbsp;
<b class="fc">&nbsp;    boolean isAssignableTo(TypeDescription var1);</b>
&nbsp;
&nbsp;    boolean isInHierarchyWith(Class&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isInHierarchyWith(TypeDescription var1);
&nbsp;
&nbsp;    @MaybeNull
<b class="fc">&nbsp;    TypeDescription getComponentType();</b>
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    TypeDescription getDeclaringType();
&nbsp;
&nbsp;    TypeList getDeclaredTypes();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    MethodDescription.InDefinedShape getEnclosingMethod();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    TypeDescription getEnclosingType();
&nbsp;
&nbsp;    int getActualModifiers(boolean var1);
&nbsp;
&nbsp;    String getSimpleName();
&nbsp;
&nbsp;    String getLongSimpleName();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    String getCanonicalName();
&nbsp;
&nbsp;    boolean isAnonymousType();
&nbsp;
&nbsp;    boolean isLocalType();
&nbsp;
&nbsp;    boolean isMemberType();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    PackageDescription getPackage();
&nbsp;
&nbsp;    AnnotationList getInheritedAnnotations();
&nbsp;
&nbsp;    boolean isSamePackage(TypeDescription var1);
&nbsp;
&nbsp;    boolean isPrimitiveWrapper();
&nbsp;
&nbsp;    boolean isAnnotationReturnType();
&nbsp;
&nbsp;    boolean isAnnotationValue();
&nbsp;
&nbsp;    boolean isAnnotationValue(Object var1);
&nbsp;
&nbsp;    boolean isPackageType();
&nbsp;
&nbsp;    int getInnerClassCount();
&nbsp;
&nbsp;    boolean isInnerClass();
&nbsp;
&nbsp;    boolean isNestedClass();
&nbsp;
&nbsp;    TypeDescription asBoxed();
&nbsp;
&nbsp;    TypeDescription asUnboxed();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    Object getDefaultValue();
&nbsp;
&nbsp;    TypeDescription getNestHost();
&nbsp;
&nbsp;    TypeList getNestMembers();
&nbsp;
&nbsp;    boolean isNestHost();
&nbsp;
&nbsp;    boolean isNestMateOf(Class&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isNestMateOf(TypeDescription var1);
&nbsp;
&nbsp;    boolean isCompileTimeConstant();
&nbsp;
&nbsp;    TypeList getPermittedSubtypes();
&nbsp;
&nbsp;    boolean isSealed();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;    public interface Generic extends TypeDefinition, AnnotationSource {
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
&nbsp;        Generic OBJECT = TypeDescription.Generic.LazyProxy.of(Object.class);
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
&nbsp;        Generic CLASS = TypeDescription.Generic.LazyProxy.of(Class.class);
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
&nbsp;        Generic VOID = TypeDescription.Generic.LazyProxy.of(Void.TYPE);
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
&nbsp;        Generic ANNOTATION = TypeDescription.Generic.LazyProxy.of(Annotation.class);
&nbsp;        @AlwaysNull
&nbsp;        Generic UNDEFINED = null;
&nbsp;
&nbsp;        Generic asRawType();
&nbsp;
&nbsp;        TypeList.Generic getUpperBounds();
&nbsp;
&nbsp;        TypeList.Generic getLowerBounds();
&nbsp;
&nbsp;        TypeList.Generic getTypeArguments();
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        Generic getOwnerType();
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        Generic findBindingOf(Generic var1);
&nbsp;
&nbsp;        TypeVariableSource getTypeVariableSource();
&nbsp;
&nbsp;        String getSymbol();
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        Generic getComponentType();
&nbsp;
&nbsp;        FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields();
&nbsp;
&nbsp;        MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;        RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents();
&nbsp;
&nbsp;        &lt;T&gt; T accept(Visitor&lt;T&gt; var1);
&nbsp;
&nbsp;        public abstract static class AbstractBase extends ModifierReviewable.AbstractBase implements Generic {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public int getModifiers() {
&nbsp;                return this.asErasure().getModifiers();
&nbsp;            }
&nbsp;
&nbsp;            public Generic asGenericType() {
&nbsp;                return this;
&nbsp;            }
&nbsp;
&nbsp;            public Generic asRawType() {
&nbsp;                return this.asErasure().asGenericType();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class LazyProxy implements InvocationHandler {
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            protected LazyProxy(Class&lt;?&gt; type) {
&nbsp;                this.type = type;
&nbsp;            }
&nbsp;
&nbsp;            protected static Generic of(Class&lt;?&gt; type) {
&nbsp;                return (Generic)Proxy.newProxyInstance(Generic.class.getClassLoader(), new Class[]{Generic.class}, new LazyProxy(type));
&nbsp;            }
&nbsp;
&nbsp;            public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) throws Throwable {
&nbsp;                try {
&nbsp;                    return method.invoke(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.type), argument);
&nbsp;                } catch (InvocationTargetException exception) {
&nbsp;                    throw exception.getTargetException();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.type.equals(((LazyProxy)var1).type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.type.hashCode();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfNonGenericType extends AbstractBase {
&nbsp;            public OfNonGenericType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.NON_GENERIC;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                Generic superClass = erasure.getSuperClass();
&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {
&nbsp;                    return superClass;
&nbsp;                } else {
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, new Visitor.ForRawType(erasure), Empty.INSTANCE));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return (TypeList.Generic)(TypeDescription.AbstractBase.RAW_TYPES ? erasure.getInterfaces() : new TypeList.ForDetachedTypes.WithResolvedErasure(erasure.getInterfaces(), new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new FieldList.TypeSubstituting(this, erasure.getDeclaredFields(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new MethodList.TypeSubstituting(this, erasure.getDeclaredMethods(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                TypeDescription erasure = this.asErasure();
&nbsp;                return new RecordComponentList.TypeSubstituting(this, erasure.getRecordComponents(), (Visitor)(TypeDescription.AbstractBase.RAW_TYPES ? TypeDescription.Generic.Visitor.NoOp.INSTANCE : new Visitor.ForRawType(erasure)));
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onNonGenericType(this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.asErasure().getTypeName();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply upper type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply lower type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return this.asErasure().getStackSize();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.asErasure().getActualName();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return this.asErasure().isArray();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return this.asErasure().isPrimitive();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.asErasure().represents(type);
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.asErasure().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;},
&nbsp;                justification = &quot;Type check is performed by erasure implementation.&quot;
&nbsp;            )
&nbsp;            public boolean equals(@MaybeNull Object other) {
&nbsp;                return this == other || this.asErasure().equals(other);
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.asErasure().toString();
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfNonGenericType {
&nbsp;                private static final Map&lt;Class&lt;?&gt;, Generic&gt; TYPE_CACHE = new HashMap();
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(Class&lt;?&gt; type) {
&nbsp;                    this(type, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(Class&lt;?&gt; type, AnnotationReader annotationReader) {
&nbsp;                    this.type = type;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
&nbsp;                    Generic typeDescription = (Generic)TYPE_CACHE.get(type);
&nbsp;                    return (Generic)(typeDescription == null ? new ForLoadedType(type) : typeDescription);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.type);
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Class&lt;?&gt; declaringClass = this.type.getDeclaringClass();
&nbsp;                    return (Generic)(declaringClass == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedType(declaringClass, this.annotationReader.ofOuterClass()));
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
&nbsp;                    Class&lt;?&gt; componentType = this.type.getComponentType();
&nbsp;                    return (Generic)(componentType == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedType(componentType, this.annotationReader.ofComponentType()));
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.type == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));
&nbsp;                    TYPE_CACHE.put(Class.class, new ForLoadedType(Class.class));
&nbsp;                    TYPE_CACHE.put(Throwable.class, new ForLoadedType(Throwable.class));
&nbsp;                    TYPE_CACHE.put(Annotation.class, new ForLoadedType(Annotation.class));
&nbsp;                    TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));
&nbsp;                    TYPE_CACHE.put(String.class, new ForLoadedType(String.class));
&nbsp;                    TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));
&nbsp;                    TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));
&nbsp;                    TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));
&nbsp;                    TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));
&nbsp;                    TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));
&nbsp;                    TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));
&nbsp;                    TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));
&nbsp;                    TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));
&nbsp;                    TYPE_CACHE.put(Void.TYPE, new ForLoadedType(Void.TYPE));
&nbsp;                    TYPE_CACHE.put(Boolean.TYPE, new ForLoadedType(Boolean.TYPE));
&nbsp;                    TYPE_CACHE.put(Byte.TYPE, new ForLoadedType(Byte.TYPE));
&nbsp;                    TYPE_CACHE.put(Short.TYPE, new ForLoadedType(Short.TYPE));
&nbsp;                    TYPE_CACHE.put(Character.TYPE, new ForLoadedType(Character.TYPE));
&nbsp;                    TYPE_CACHE.put(Integer.TYPE, new ForLoadedType(Integer.TYPE));
&nbsp;                    TYPE_CACHE.put(Long.TYPE, new ForLoadedType(Long.TYPE));
&nbsp;                    TYPE_CACHE.put(Float.TYPE, new ForLoadedType(Float.TYPE));
&nbsp;                    TYPE_CACHE.put(Double.TYPE, new ForLoadedType(Double.TYPE));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForErasure extends OfNonGenericType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                public ForErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();</b>
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : declaringType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : componentType.asGenericType();
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfNonGenericType {
<b class="fc">&nbsp;                private final TypeDescription typeDescription;</b>
&nbsp;                @MaybeNull
&nbsp;                private final Generic declaringType;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(TypeDescription typeDescription, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType(), annotationSource);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                private Latent(TypeDescription typeDescription, @MaybeNull TypeDescription declaringType, AnnotationSource annotationSource) {
&nbsp;                    this(typeDescription, declaringType == null ? TypeDescription.Generic.UNDEFINED : declaringType.asGenericType(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                protected Latent(TypeDescription typeDescription, @MaybeNull Generic declaringType, AnnotationSource annotationSource) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    return this.declaringType;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : componentType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForReifiedErasure extends OfNonGenericType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                protected ForReifiedErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                protected static Generic of(TypeDescription typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isGenerified() ? new ForReifiedErasure(typeDescription) : new ForErasure(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = this.typeDescription.getSuperClass();
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, TypeDescription.Generic.Visitor.Reifying.INHERITING));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.ForDetachedTypes.WithResolvedErasure(this.typeDescription.getInterfaces(), TypeDescription.Generic.Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, this.typeDescription.getDeclaredFields(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, this.typeDescription.getDeclaredMethods(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : of(declaringType);
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
&nbsp;                    TypeDescription componentType = this.typeDescription.getComponentType();
&nbsp;                    return componentType == null ? TypeDescription.Generic.UNDEFINED : of(componentType);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfGenericArray extends AbstractBase {
&nbsp;            public OfGenericArray() {
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return this.getComponentType().getSort().isNonGeneric() ? Sort.NON_GENERIC : Sort.GENERIC_ARRAY;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public TypeDescription asErasure() {
&nbsp;                return TypeDescription.ArrayProjection.of(this.getComponentType().asErasure(), 1);
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return TypeDescription.ARRAY_INTERFACES;
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                return new FieldList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                return new RecordComponentList.Empty();
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply upper type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply lower type bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getOwnerType() {
&nbsp;                return TypeDescription.Generic.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().getTypeName() : this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().getActualName() : this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return (T)(this.getSort().isNonGeneric() ? visitor.onNonGenericType(this) : visitor.onGenericArray(this));
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : (this.getSort().isNonGeneric() ? this.asErasure().hashCode() : this.getComponentType().hashCode());
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Type check is performed by erasure implementation. Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public boolean equals(@MaybeNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (this.getSort().isNonGeneric()) {
&nbsp;                    return this.asErasure().equals(other);
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isGenericArray() &amp;&amp; this.getComponentType().equals(typeDescription.getComponentType());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Assuming component type for array type.&quot;
&nbsp;            )
&nbsp;            public String toString() {
&nbsp;                return this.getSort().isNonGeneric() ? this.asErasure().toString() : this.getComponentType().getTypeName() + &quot;[]&quot;;
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfGenericArray {
&nbsp;                private final GenericArrayType genericArrayType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(GenericArrayType genericArrayType) {
&nbsp;                    this(genericArrayType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(GenericArrayType genericArrayType, AnnotationReader annotationReader) {
&nbsp;                    this.genericArrayType = genericArrayType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
&nbsp;                    return Sort.describeOrNull(this.genericArrayType.getGenericComponentType(), this.annotationReader.ofComponentType());
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.genericArrayType == type || super.represents(type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfGenericArray {
&nbsp;                private final Generic componentType;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(Generic componentType, AnnotationSource annotationSource) {
&nbsp;                    this.componentType = componentType;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public Generic getComponentType() {
&nbsp;                    return this.componentType;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfWildcardType extends AbstractBase {
&nbsp;            public static final String SYMBOL = &quot;?&quot;;
&nbsp;
&nbsp;            public OfWildcardType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.WILDCARD;
&nbsp;            }
&nbsp;
&nbsp;            public TypeDescription asErasure() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not represent an erasable type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply field definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply method definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply record component definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an owner type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onWildcard(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an operand stack size: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var10000;
&nbsp;                if (var1 != 0) {
&nbsp;                    var10000 = 0;
&nbsp;                } else {
&nbsp;                    int lowerHash = 1;
&nbsp;                    int upperHash = 1;
&nbsp;
&nbsp;                    for(Generic lowerBound : this.getLowerBounds()) {
&nbsp;                        lowerHash = 31 * lowerHash + lowerBound.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    for(Generic upperBound : this.getUpperBounds()) {
&nbsp;                        upperHash = 31 * upperHash + upperBound.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = lowerHash ^ upperHash;
&nbsp;                }
&nbsp;
&nbsp;                int var2 = var10000;
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isWildcard() &amp;&amp; this.getUpperBounds().equals(typeDescription.getUpperBounds()) &amp;&amp; this.getLowerBounds().equals(typeDescription.getLowerBounds());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                StringBuilder stringBuilder = new StringBuilder(&quot;?&quot;);
&nbsp;                TypeList.Generic bounds = this.getLowerBounds();
&nbsp;                if (!bounds.isEmpty()) {
&nbsp;                    stringBuilder.append(&quot; super &quot;);
&nbsp;                } else {
&nbsp;                    bounds = this.getUpperBounds();
&nbsp;                    if (((Generic)bounds.getOnly()).equals(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class))) {
&nbsp;                        return &quot;?&quot;;
&nbsp;                    }
&nbsp;
&nbsp;                    stringBuilder.append(&quot; extends &quot;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.append(((Generic)bounds.getOnly()).getTypeName()).toString();
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfWildcardType {
&nbsp;                private final WildcardType wildcardType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(WildcardType wildcardType) {
&nbsp;                    this(wildcardType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(WildcardType wildcardType, AnnotationReader annotationReader) {
&nbsp;                    this.wildcardType = wildcardType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new WildcardUpperBoundTypeList(this.wildcardType.getUpperBounds(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new WildcardLowerBoundTypeList(this.wildcardType.getLowerBounds(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.wildcardType == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class WildcardUpperBoundTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] upperBound;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected WildcardUpperBoundTypeList(Type[] upperBound, AnnotationReader annotationReader) {
&nbsp;                        this.upperBound = upperBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describeOrNull(this.upperBound[index], this.annotationReader.ofWildcardUpperBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.upperBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class WildcardLowerBoundTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] lowerBound;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected WildcardLowerBoundTypeList(Type[] lowerBound, AnnotationReader annotationReader) {
&nbsp;                        this.lowerBound = lowerBound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describeOrNull(this.lowerBound[index], this.annotationReader.ofWildcardLowerBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.lowerBound.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfWildcardType {
&nbsp;                private final List&lt;? extends Generic&gt; upperBounds;
&nbsp;                private final List&lt;? extends Generic&gt; lowerBounds;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                protected Latent(List&lt;? extends Generic&gt; upperBounds, List&lt;? extends Generic&gt; lowerBounds, AnnotationSource annotationSource) {
&nbsp;                    this.upperBounds = upperBounds;
&nbsp;                    this.lowerBounds = lowerBounds;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic unbounded(AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), Collections.emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public static Generic boundedAbove(Generic upperBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(upperBound), Collections.emptyList(), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public static Generic boundedBelow(Generic lowerBound, AnnotationSource annotationSource) {
&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), Collections.singletonList(lowerBound), annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeList.Explicit(this.upperBounds);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    return new TypeList.Explicit(this.lowerBounds);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class OfParameterizedType extends AbstractBase {
&nbsp;            public OfParameterizedType() {
&nbsp;            }
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.PARAMETERIZED;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
&nbsp;                Generic superClass = this.asErasure().getSuperClass();
&nbsp;                return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, new Visitor.Substitutor.ForTypeVariableBinding(this)));
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                return new TypeList.ForDetachedTypes.WithResolvedErasure(this.asErasure().getInterfaces(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                return new FieldList.TypeSubstituting(this, this.asErasure().getDeclaredFields(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                return new MethodList.TypeSubstituting(this, this.asErasure().getDeclaredMethods(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                return new RecordComponentList.TypeSubstituting(this, this.asErasure().getRecordComponents(), new Visitor.Substitutor.ForTypeVariableBinding(this));
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                Generic typeDescription = this;
&nbsp;
&nbsp;                do {
&nbsp;                    TypeList.Generic typeArguments = typeDescription.getTypeArguments();
&nbsp;                    TypeList.Generic typeVariables = typeDescription.asErasure().getTypeVariables();
&nbsp;
&nbsp;                    for(int index = 0; index &lt; Math.min(typeArguments.size(), typeVariables.size()); ++index) {
&nbsp;                        if (typeVariable.equals(typeVariables.get(index))) {
&nbsp;                            return (Generic)typeArguments.get(index);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    typeDescription = typeDescription.getOwnerType();
&nbsp;                } while(typeDescription != null &amp;&amp; typeDescription.getSort().isParameterized());
&nbsp;
&nbsp;                return TypeDescription.Generic.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getUpperBounds() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply upper bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply lower bounds: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public Generic getComponentType() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a type variable source: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getSymbol() {
&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a symbol: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public String getActualName() {
&nbsp;                return this.toString();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                return new TypeDefinition.SuperClassIterator(this);
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onParameterizedType(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var10000;
&nbsp;                if (var1 != 0) {
&nbsp;                    var10000 = 0;
&nbsp;                } else {
&nbsp;                    int result = 1;
&nbsp;
&nbsp;                    for(Generic typeArgument : this.getTypeArguments()) {
&nbsp;                        result = 31 * result + typeArgument.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    Generic ownerType = this.getOwnerType();
&nbsp;                    var10000 = result ^ (ownerType == null ? this.asErasure().hashCode() : ownerType.hashCode());
&nbsp;                }
&nbsp;
&nbsp;                int var2 = var10000;
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object other) {
&nbsp;                if (this == other) {
&nbsp;                    return true;
&nbsp;                } else if (!(other instanceof Generic)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    if (!typeDescription.getSort().isParameterized()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic ownerType = this.getOwnerType();
&nbsp;                        Generic otherOwnerType = typeDescription.getOwnerType();
&nbsp;                        return this.asErasure().equals(typeDescription.asErasure()) &amp;&amp; (ownerType != null || otherOwnerType == null) &amp;&amp; (ownerType == null || ownerType.equals(otherOwnerType)) &amp;&amp; this.getTypeArguments().equals(typeDescription.getTypeArguments());
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                StringBuilder stringBuilder = new StringBuilder();
&nbsp;                TypeDescription.Generic.OfParameterizedType.RenderingDelegate.CURRENT.apply(stringBuilder, this.asErasure(), this.getOwnerType());
&nbsp;                TypeList.Generic typeArguments = this.getTypeArguments();
&nbsp;                if (!typeArguments.isEmpty()) {
&nbsp;                    stringBuilder.append(&#39;&lt;&#39;);
&nbsp;                    boolean multiple = false;
&nbsp;
&nbsp;                    for(Generic typeArgument : typeArguments) {
&nbsp;                        if (multiple) {
&nbsp;                            stringBuilder.append(&quot;, &quot;);
&nbsp;                        }
&nbsp;
&nbsp;                        stringBuilder.append(typeArgument.getTypeName());
&nbsp;                        multiple = true;
&nbsp;                    }
&nbsp;
&nbsp;                    stringBuilder.append(&#39;&gt;&#39;);
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.toString();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum RenderingDelegate {
&nbsp;                FOR_LEGACY_VM {
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @MaybeNull Generic ownerType) {
&nbsp;                        if (ownerType != null) {
&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;.&#39;).append(ownerType.getSort().isParameterized() ? erasure.getSimpleName() : erasure.getName());
&nbsp;                        } else {
&nbsp;                            stringBuilder.append(erasure.getName());
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                },
&nbsp;                FOR_JAVA_8_CAPABLE_VM {
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @MaybeNull Generic ownerType) {
&nbsp;                        if (ownerType != null) {
&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;$&#39;);
&nbsp;                            if (ownerType.getSort().isParameterized()) {
&nbsp;                                stringBuilder.append(erasure.getName().replace(ownerType.asErasure().getName() + &quot;$&quot;, &quot;&quot;));
&nbsp;                            } else {
&nbsp;                                stringBuilder.append(erasure.getSimpleName());
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            stringBuilder.append(erasure.getName());
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V8) ? FOR_JAVA_8_CAPABLE_VM : FOR_LEGACY_VM;
&nbsp;
&nbsp;                private RenderingDelegate() {
&nbsp;                }
&nbsp;
&nbsp;                protected abstract void apply(StringBuilder var1, TypeDescription var2, @MaybeNull Generic var3);
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedType extends OfParameterizedType {
&nbsp;                private final ParameterizedType parameterizedType;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(ParameterizedType parameterizedType) {
&nbsp;                    this(parameterizedType, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                protected ForLoadedType(ParameterizedType parameterizedType, AnnotationReader annotationReader) {
&nbsp;                    this.parameterizedType = parameterizedType;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new ParameterArgumentTypeList(this.parameterizedType.getActualTypeArguments(), this.annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Type ownerType = this.parameterizedType.getOwnerType();
&nbsp;                    return ownerType == null ? TypeDescription.Generic.UNDEFINED : Sort.describe(ownerType, this.annotationReader.ofOwnerType());
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of((Class)this.parameterizedType.getRawType());
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
&nbsp;                }
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.parameterizedType == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class ParameterArgumentTypeList extends TypeList.AbstractBase {
&nbsp;                    private final Type[] argumentType;
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected ParameterArgumentTypeList(Type[] argumentType, AnnotationReader annotationReader) {
&nbsp;                        this.argumentType = argumentType;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describeOrNull(this.argumentType[index], this.annotationReader.ofTypeArgument(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.argumentType.length;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class Latent extends OfParameterizedType {
&nbsp;                private final TypeDescription rawType;
&nbsp;                @MaybeNull
&nbsp;                private final Generic ownerType;
&nbsp;                private final List&lt;? extends Generic&gt; parameters;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public Latent(TypeDescription rawType, @MaybeNull Generic ownerType, List&lt;? extends Generic&gt; parameters, AnnotationSource annotationSource) {
&nbsp;                    this.rawType = rawType;
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.parameters = parameters;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.rawType;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    return this.ownerType;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.Explicit(this.parameters);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForReifiedType extends OfParameterizedType {
&nbsp;                private final Generic parameterizedType;
&nbsp;
&nbsp;                protected ForReifiedType(Generic parameterizedType) {
&nbsp;                    this.parameterizedType = parameterizedType;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
&nbsp;                    Generic superClass = super.getSuperClass();
&nbsp;                    return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new LazyProjection.WithResolvedErasure(superClass, TypeDescription.Generic.Visitor.Reifying.INHERITING));
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return new TypeList.ForDetachedTypes.WithResolvedErasure(super.getInterfaces(), TypeDescription.Generic.Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    return new FieldList.TypeSubstituting(this, super.getDeclaredFields(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    return new MethodList.TypeSubstituting(this, super.getDeclaredMethods(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.ForDetachedTypes(this.parameterizedType.getTypeArguments(), TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    Generic ownerType = this.parameterizedType.getOwnerType();
&nbsp;                    return ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(TypeDescription.Generic.Visitor.Reifying.INHERITING);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.parameterizedType.asErasure();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForGenerifiedErasure extends OfParameterizedType {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                protected ForGenerifiedErasure(TypeDescription typeDescription) {
&nbsp;                    this.typeDescription = typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                public static Generic of(TypeDescription typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isGenerified() ? new ForGenerifiedErasure(typeDescription) : new OfNonGenericType.ForErasure(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.typeDescription;
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeArguments() {
&nbsp;                    return new TypeList.ForDetachedTypes(this.typeDescription.getTypeVariables(), TypeDescription.Generic.Visitor.AnnotationStripper.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
&nbsp;                    TypeDescription declaringType = this.typeDescription.getDeclaringType();
&nbsp;                    return declaringType == null ? TypeDescription.Generic.UNDEFINED : of(declaringType);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public AnnotationList getDeclaredAnnotations() {</b>
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public abstract static class OfTypeVariable extends AbstractBase {
&nbsp;            public OfTypeVariable() {
<b class="pc">&nbsp;            }</b>
&nbsp;
&nbsp;            public TypeDefinition.Sort getSort() {
&nbsp;                return Sort.VARIABLE;
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public TypeDescription asErasure() {
&nbsp;                TypeList.Generic upperBounds = this.getUpperBounds();
&nbsp;                return upperBounds.isEmpty() ? TypeDescription.ForLoadedType.of(Object.class) : ((Generic)upperBounds.get(0)).asErasure();
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
<b class="fc">&nbsp;            public Generic getSuperClass() {</b>
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
<b class="pc">&nbsp;</b>
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an interface type definition: &quot; + this);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {</b>
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply field definitions: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply method definitions: &quot; + this);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply record component definitions: &quot; + this);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public Generic getComponentType() {</b>
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a component type: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply lower bounds: &quot; + this);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public Generic getOwnerType() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an owner type: &quot; + this);
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.toString();
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public String getActualName() {</b>
<b class="nc">&nbsp;                return this.getSymbol();</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {</b>
&nbsp;                return visitor.onTypeVariable(this);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public boolean isPrimitive() {</b>
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
&nbsp;                return this.equals(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
&nbsp;                int var1 = this.hashCode;
&nbsp;                int var2 = var1 != 0 ? 0 : this.getTypeVariableSource().hashCode() ^ this.getSymbol().hashCode();
&nbsp;                if (var2 == 0) {
&nbsp;                    var2 = this.hashCode;
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof Generic)) {</b>
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    Generic typeDescription = (Generic)other;
&nbsp;                    return typeDescription.getSort().isTypeVariable() &amp;&amp; this.getSymbol().equals(typeDescription.getSymbol()) &amp;&amp; this.getTypeVariableSource().equals(typeDescription.getTypeVariableSource());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return this.getSymbol();</b>
&nbsp;            }
&nbsp;
&nbsp;            public static class Symbolic extends AbstractBase {
&nbsp;                private final String symbol;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
<b class="nc">&nbsp;                public Symbolic(String symbol, AnnotationSource annotationSource) {</b>
&nbsp;                    this.symbol = symbol;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDefinition.Sort getSort() {
&nbsp;                    return Sort.VARIABLE_SYMBOLIC;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.symbol;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return this.annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an erasure: &quot; + this);
&nbsp;                }
&nbsp;
<b class="pc">&nbsp;                public TypeList.Generic getUpperBounds() {</b>
<b class="pc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an upper type bound: &quot; + this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a variable source: &quot; + this);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                @MaybeNull</b>
&nbsp;                public Generic getSuperClass() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeList.Generic getInterfaces() {</b>
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an interface type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply field definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply method definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply record component definitions: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Generic getComponentType() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a component type: &quot; + this);
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                public TypeList.Generic getTypeArguments() {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getLowerBounds() {
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply lower bounds: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Generic getOwnerType() {
<b class="pc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an owner type: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                public String getTypeName() {
&nbsp;                    return this.toString();
&nbsp;                }
&nbsp;
<b class="pc">&nbsp;                public String getActualName() {</b>
<b class="nc">&nbsp;                    return this.getSymbol();</b>
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {</b>
<b class="fc">&nbsp;                    return visitor.onTypeVariable(this);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public StackSize getStackSize() {
&nbsp;                    return StackSize.SINGLE;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isArray() {
<b class="pc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                public boolean isPrimitive() {</b>
<b class="pc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="fc">&nbsp;                public boolean isRecord() {</b>
<b class="pc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public boolean represents(Type type) {
<b class="fc">&nbsp;                    if (type == null) {</b>
&nbsp;                        throw new NullPointerException();
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {</b>
&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.symbol.hashCode();
&nbsp;                }
&nbsp;
<b class="pc">&nbsp;                public boolean equals(@MaybeNull Object other) {</b>
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof Generic)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic typeDescription = (Generic)other;
&nbsp;                        return typeDescription.getSort().isTypeVariable() &amp;&amp; this.getSymbol().equals(typeDescription.getSymbol());
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                public String toString() {</b>
<b class="nc">&nbsp;                    return this.getSymbol();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public static class ForLoadedType extends OfTypeVariable {</b>
&nbsp;                private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                public ForLoadedType(TypeVariable&lt;?&gt; typeVariable) {
&nbsp;                    this(typeVariable, TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected ForLoadedType(TypeVariable&lt;?&gt; typeVariable, AnnotationReader annotationReader) {</b>
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationReader = annotationReader;
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                    GenericDeclaration genericDeclaration = this.typeVariable.getGenericDeclaration();</b>
&nbsp;                    if (genericDeclaration instanceof Class) {
&nbsp;                        return TypeDescription.ForLoadedType.of((Class)genericDeclaration);
<b class="nc">&nbsp;                    } else if (genericDeclaration instanceof Method) {</b>
&nbsp;                        return new MethodDescription.ForLoadedMethod((Method)genericDeclaration);
&nbsp;                    } else if (genericDeclaration instanceof Constructor) {
&nbsp;                        return new MethodDescription.ForLoadedConstructor((Constructor)genericDeclaration);
&nbsp;                    } else {
&nbsp;                        throw new IllegalStateException(&quot;Unknown declaration: &quot; + genericDeclaration);
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return new TypeVariableBoundList(this.typeVariable.getBounds(), this.annotationReader);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.typeVariable.getName();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationReader.asList();
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public boolean represents(Type type) {
&nbsp;                    return this.typeVariable == type || super.represents(type);
&nbsp;                }
&nbsp;
&nbsp;                protected static class TypeVariableBoundList extends TypeList.AbstractBase {
<b class="nc">&nbsp;                    private final Type[] bound;</b>
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected TypeVariableBoundList(Type[] bound, AnnotationReader annotationReader) {
&nbsp;                        this.bound = bound;
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public Generic get(int index) {
&nbsp;                        return Sort.describeOrNull(this.bound[index], this.annotationReader.ofTypeVariableBoundType(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.bound.length;
<b class="fc">&nbsp;                    }</b>
<b class="pc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public static class WithAnnotationOverlay extends OfTypeVariable {
&nbsp;                private final Generic typeVariable;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public WithAnnotationOverlay(Generic typeVariable, AnnotationSource annotationSource) {
&nbsp;                    this.typeVariable = typeVariable;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getUpperBounds() {
&nbsp;                    return this.typeVariable.getUpperBounds();
&nbsp;                }
&nbsp;
&nbsp;                public TypeVariableSource getTypeVariableSource() {
&nbsp;                    return this.typeVariable.getTypeVariableSource();
&nbsp;                }
&nbsp;
&nbsp;                public String getSymbol() {
&nbsp;                    return this.typeVariable.getSymbol();
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public abstract static class LazyProjection extends AbstractBase {
&nbsp;            public LazyProjection() {
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Generic resolve();
&nbsp;
<b class="nc">&nbsp;            public TypeDefinition.Sort getSort() {</b>
<b class="nc">&nbsp;                return this.resolve().getSort();</b>
&nbsp;            }
&nbsp;
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
&nbsp;                return this.resolve().getDeclaredFields();
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {</b>
&nbsp;                return this.resolve().getDeclaredMethods();
&nbsp;            }
&nbsp;
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
&nbsp;                return this.resolve().getRecordComponents();
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public TypeList.Generic getUpperBounds() {</b>
<b class="fc">&nbsp;                return this.resolve().getUpperBounds();</b>
&nbsp;            }
&nbsp;
&nbsp;            public TypeList.Generic getLowerBounds() {
&nbsp;                return this.resolve().getLowerBounds();
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                return this.resolve().getComponentType();</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public TypeList.Generic getTypeArguments() {</b>
&nbsp;                return this.resolve().getTypeArguments();
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            @MaybeNull</b>
<b class="fc">&nbsp;            public Generic findBindingOf(Generic typeVariable) {</b>
&nbsp;                return this.resolve().findBindingOf(typeVariable);
&nbsp;            }
&nbsp;
&nbsp;            public TypeVariableSource getTypeVariableSource() {
&nbsp;                return this.resolve().getTypeVariableSource();
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            @MaybeNull</b>
<b class="nc">&nbsp;            public Generic getOwnerType() {</b>
&nbsp;                return this.resolve().getOwnerType();
&nbsp;            }
&nbsp;
&nbsp;            public String getTypeName() {
&nbsp;                return this.resolve().getTypeName();
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public String getSymbol() {</b>
<b class="fc">&nbsp;                return this.resolve().getSymbol();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public String getActualName() {
<b class="fc">&nbsp;                return this.resolve().getActualName();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {</b>
&nbsp;                return (T)this.resolve().accept(visitor);
&nbsp;            }
&nbsp;
&nbsp;            public StackSize getStackSize() {
&nbsp;                return this.asErasure().getStackSize();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return this.asErasure().isArray();
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
&nbsp;                return this.asErasure().isPrimitive();
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean isRecord() {
&nbsp;                return this.asErasure().isRecord();
&nbsp;            }
&nbsp;
&nbsp;            public boolean represents(Type type) {
<b class="nc">&nbsp;                return this.resolve().represents(type);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)</b>
<b class="nc">&nbsp;            public int hashCode() {</b>
&nbsp;                int var1 = this.hashCode;
<b class="nc">&nbsp;                int var2 = var1 != 0 ? 0 : this.resolve().hashCode();</b>
&nbsp;                if (var2 == 0) {
<b class="nc">&nbsp;                    var2 = this.hashCode;</b>
&nbsp;                } else {
&nbsp;                    this.hashCode = var2;
&nbsp;                }
&nbsp;
&nbsp;                return var2;
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public boolean equals(@MaybeNull Object other) {</b>
&nbsp;                return this == other || other instanceof TypeDefinition &amp;&amp; this.resolve().equals(other);
&nbsp;            }
&nbsp;
&nbsp;            public String toString() {
&nbsp;                return this.resolve().toString();
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public abstract static class WithLazyNavigation extends LazyProjection {</b>
&nbsp;                public WithLazyNavigation() {
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return TypeDescription.Generic.LazyProjection.WithLazyNavigation.LazySuperClass.of(this);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public TypeList.Generic getInterfaces() {
&nbsp;                    return TypeDescription.Generic.LazyProjection.WithLazyNavigation.LazyInterfaceList.of(this);
&nbsp;                }
&nbsp;
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    return new TypeDefinition.SuperClassIterator(this);
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                protected static class LazySuperClass extends WithLazyNavigation {
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    protected LazySuperClass(LazyProjection delegate) {
&nbsp;                        this.delegate = delegate;
&nbsp;                    }
&nbsp;
&nbsp;                    @MaybeNull
<b class="fc">&nbsp;                    protected static Generic of(LazyProjection delegate) {</b>
&nbsp;                        return (Generic)(delegate.asErasure().getSuperClass() == null ? TypeDescription.Generic.UNDEFINED : new LazySuperClass(delegate));
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.resolve().getDeclaredAnnotations();
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="pc">&nbsp;                    @SuppressFBWarnings(</b>
<b class="nc">&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},</b>
&nbsp;                        justification = &quot;Assuming super class for given instance.&quot;
<b class="fc">&nbsp;                    )</b>
<b class="fc">&nbsp;                    public TypeDescription asErasure() {</b>
<b class="fc">&nbsp;                        return this.delegate.asErasure().getSuperClass().asErasure();</b>
&nbsp;                    }
&nbsp;
<b class="pc">&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)</b>
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
<b class="fc">&nbsp;                        justification = &quot;Assuming super class for given instance.&quot;</b>
&nbsp;                    )
&nbsp;                    protected Generic resolve() {
&nbsp;                        Generic var1 = this.resolved;
&nbsp;                        Generic var2 = var1 != null ? null : this.delegate.resolve().getSuperClass();
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = this.resolved;
&nbsp;                        } else {
&nbsp;                            this.resolved = var2;
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        return var2;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class LazyInterfaceType extends WithLazyNavigation {
&nbsp;                    private final LazyProjection delegate;
<b class="fc">&nbsp;                    private final int index;</b>
&nbsp;                    private final Generic rawInterface;
&nbsp;
&nbsp;                    protected LazyInterfaceType(LazyProjection delegate, int index, Generic rawInterface) {
&nbsp;                        this.delegate = delegate;
&nbsp;                        this.index = index;
&nbsp;                        this.rawInterface = rawInterface;
&nbsp;                    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public AnnotationList getDeclaredAnnotations() {</b>
<b class="fc">&nbsp;                        return this.resolve().getDeclaredAnnotations();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeDescription asErasure() {
&nbsp;                        return this.rawInterface.asErasure();
&nbsp;                    }
&nbsp;
&nbsp;                    @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected Generic resolve() {
&nbsp;                        Generic var1 = this.resolved;
&nbsp;                        Generic var2 = var1 != null ? null : (Generic)this.delegate.resolve().getInterfaces().get(this.index);
&nbsp;                        if (var2 == null) {
&nbsp;                            var2 = this.resolved;
&nbsp;                        } else {
<b class="fc">&nbsp;                            this.resolved = var2;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        return var2;
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                protected static class LazyInterfaceList extends TypeList.AbstractBase {
&nbsp;                    private final LazyProjection delegate;
&nbsp;                    private final TypeList.Generic rawInterfaces;
&nbsp;
<b class="nc">&nbsp;                    protected LazyInterfaceList(LazyProjection delegate, TypeList.Generic rawInterfaces) {</b>
&nbsp;                        this.delegate = delegate;
&nbsp;                        this.rawInterfaces = rawInterfaces;
&nbsp;                    }
&nbsp;
&nbsp;                    protected static TypeList.Generic of(LazyProjection delegate) {
&nbsp;                        return new LazyInterfaceList(delegate, delegate.asErasure().getInterfaces());
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic get(int index) {
&nbsp;                        return new LazyInterfaceType(this.delegate, index, (Generic)this.rawInterfaces.get(index));
&nbsp;                    }
&nbsp;
&nbsp;                    public int size() {
&nbsp;                        return this.rawInterfaces.size();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected abstract static class OfAnnotatedElement extends WithLazyNavigation {
&nbsp;                    protected OfAnnotatedElement() {
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.getAnnotationReader().asList();
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public abstract static class WithEagerNavigation extends LazyProjection {
&nbsp;                public WithEagerNavigation() {
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return this.resolve().getSuperClass();
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public TypeList.Generic getInterfaces() {</b>
&nbsp;                    return this.resolve().getInterfaces();
&nbsp;                }
&nbsp;
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
&nbsp;                    return this.resolve().iterator();
&nbsp;                }
&nbsp;
&nbsp;                protected abstract static class OfAnnotatedElement extends WithEagerNavigation {
&nbsp;                    protected OfAnnotatedElement() {
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
&nbsp;                        return this.getAnnotationReader().asList();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedSuperClass extends WithLazyNavigation.OfAnnotatedElement {
<b class="fc">&nbsp;                private final Class&lt;?&gt; type;</b>
&nbsp;
&nbsp;                protected ForLoadedSuperClass(Class&lt;?&gt; type) {
&nbsp;                    this.type = type;
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
&nbsp;                    return (Generic)(type.getSuperclass() == null ? TypeDescription.Generic.UNDEFINED : new ForLoadedSuperClass(type));
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describe(this.type.getGenericSuperclass(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.type.getSuperclass());
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedSuperClass(this.type);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedFieldType extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Field field;
&nbsp;
&nbsp;                public ForLoadedFieldType(Field field) {
<b class="fc">&nbsp;                    this.field = field;</b>
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    Generic var1 = this.resolved;</b>
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describeOrNull(this.field.getGenericType(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.field.getType());
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedField(this.field);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForLoadedReturnType extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Method method;
&nbsp;
&nbsp;                public ForLoadedReturnType(Method method) {
<b class="fc">&nbsp;                    this.method = method;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describeOrNull(this.method.getGenericReturnType(), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.method.getReturnType());
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedMethodReturnType(this.method);
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public static class OfConstructorParameter extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Constructor&lt;?&gt; constructor;
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;EI_EXPOSE_REP2&quot;},
&nbsp;                    justification = &quot;The array is not modified by class contract.&quot;
&nbsp;                )
&nbsp;                public OfConstructorParameter(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.constructor = constructor;
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.delegate;
&nbsp;                    Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
&nbsp;                    } else {
&nbsp;                        Type[] type = this.constructor.getGenericParameterTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describeOrNull(type[this.index], this.getAnnotationReader()) : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.delegate;
&nbsp;                    } else {
&nbsp;                        this.delegate = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(this.constructor, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfMethodParameter extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Method method;
&nbsp;                private final int index;
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;EI_EXPOSE_REP2&quot;},
&nbsp;                    justification = &quot;The array is not modified by class contract.&quot;
&nbsp;                )
&nbsp;                public OfMethodParameter(Method method, int index, Class&lt;?&gt;[] erasure) {
&nbsp;                    this.method = method;
&nbsp;                    this.index = index;
&nbsp;                    this.erasure = erasure;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var10000;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 = null;
&nbsp;                    } else {
&nbsp;                        Type[] type = this.method.getGenericParameterTypes();
&nbsp;                        var10000 = this.erasure.length == type.length ? Sort.describeOrNull(type[this.index], this.getAnnotationReader()) : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    Generic var2 = var10000;
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(this.erasure[this.index]);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(this.method, this.index);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class OfRecordComponent extends WithEagerNavigation.OfAnnotatedElement {
&nbsp;                private final Object recordComponent;
&nbsp;
&nbsp;                protected OfRecordComponent(Object recordComponent) {
&nbsp;                    this.recordComponent = recordComponent;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : Sort.describeOrNull(net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getGenericType(this.recordComponent), this.getAnnotationReader());
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return TypeDescription.ForLoadedType.of(net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getType(this.recordComponent));
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotationReader getAnnotationReader() {
&nbsp;                    return new AnnotationReader.Delegator.ForLoadedRecordComponent(this.recordComponent);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class WithResolvedErasure extends WithEagerNavigation {
&nbsp;                private final Generic delegate;
&nbsp;                private final Visitor&lt;? extends Generic&gt; visitor;
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor) {
&nbsp;                    this(delegate, visitor, delegate);
&nbsp;                }
&nbsp;
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor, AnnotationSource annotationSource) {
&nbsp;                    this.delegate = delegate;
&nbsp;                    this.visitor = visitor;
&nbsp;                    this.annotationSource = annotationSource;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.annotationSource.getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription asErasure() {
&nbsp;                    return this.delegate.asErasure();
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
&nbsp;                    Generic var1 = this.resolved;
&nbsp;                    Generic var2 = var1 != null ? null : (Generic)this.delegate.accept(this.visitor);
&nbsp;                    if (var2 == null) {
&nbsp;                        var2 = this.resolved;
&nbsp;                    } else {
&nbsp;                        this.resolved = var2;
&nbsp;                    }
&nbsp;
&nbsp;                    return var2;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public abstract static class Builder {
&nbsp;            @AlwaysNull
&nbsp;            private static final Type UNDEFINED = null;
&nbsp;            protected final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;            protected Builder(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                this.annotations = annotations;
&nbsp;            }
&nbsp;
&nbsp;            public static Builder of(Type type) {
&nbsp;                return of(Sort.describe(type));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder of(Generic typeDescription) {
&nbsp;                return (Builder)typeDescription.accept(TypeDescription.Generic.Builder.Visitor.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(Class&lt;?&gt; type) {
&nbsp;                return rawType(TypeDescription.ForLoadedType.of(type));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(TypeDescription type) {
&nbsp;                return new OfNonGenericType(type);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(Class&lt;?&gt; type, @MaybeNull Generic ownerType) {
&nbsp;                return rawType(TypeDescription.ForLoadedType.of(type), ownerType);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder rawType(TypeDescription type, @MaybeNull Generic ownerType) {
&nbsp;                TypeDescription declaringType = type.getDeclaringType();
&nbsp;                if (declaringType == null &amp;&amp; ownerType != null) {
&nbsp;                    throw new IllegalArgumentException(type + &quot; does not have a declaring type: &quot; + ownerType);
&nbsp;                } else if (declaringType == null || ownerType != null &amp;&amp; declaringType.equals(ownerType.asErasure())) {
&nbsp;                    return new OfNonGenericType(type, ownerType);
&nbsp;                } else {
&nbsp;                    throw new IllegalArgumentException(ownerType + &quot; is not the declaring type of &quot; + type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard() {
&nbsp;                return unboundWildcard((Collection)Collections.emptySet());
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(Annotation... annotation) {
&nbsp;                return unboundWildcard(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(List&lt;? extends Annotation&gt; annotations) {
<b class="fc">&nbsp;                return unboundWildcard((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static Generic unboundWildcard(AnnotationDescription... annotation) {
&nbsp;                return unboundWildcard((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public static Generic unboundWildcard(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="pc">&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.unbounded(new AnnotationSource.Explicit(new ArrayList(annotations)));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static Builder typeVariable(String symbol) {
&nbsp;                return new OfTypeVariable(symbol);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, Type... parameter) {
&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, List&lt;? extends Type&gt; parameters) {
&nbsp;                return parameterizedType(rawType, UNDEFINED, parameters);
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, @MaybeNull Type ownerType, List&lt;? extends Type&gt; parameters) {
<b class="pc">&nbsp;                return parameterizedType(TypeDescription.ForLoadedType.of(rawType), (Generic)(ownerType == null ? null : Sort.describe(ownerType)), new TypeList.ForLoadedTypes(parameters));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
&nbsp;                return parameterizedType(rawType, (Collection)Arrays.asList(parameter));
&nbsp;            }
&nbsp;
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                return parameterizedType(rawType, TypeDescription.Generic.UNDEFINED, parameters);
<b class="pc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, @MaybeNull Generic ownerType, Collection&lt;? extends TypeDefinition&gt; parameters) {
&nbsp;                TypeDescription declaringType = rawType.getDeclaringType();
&nbsp;                if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; rawType.isStatic()) {
&nbsp;                    ownerType = declaringType.asGenericType();
&nbsp;                }
&nbsp;
&nbsp;                if (!rawType.represents(TargetType.class)) {
<b class="fc">&nbsp;                    if (!rawType.isGenerified()) {</b>
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; is not a parameterized type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; !rawType.isStatic()) {
&nbsp;                        throw new IllegalArgumentException(rawType + &quot; requires an owner type&quot;);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType != null &amp;&amp; !ownerType.asErasure().equals(declaringType)) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not represent required owner for &quot; + rawType);
&nbsp;                    }
&nbsp;
&nbsp;                    if (ownerType != null &amp;&amp; rawType.isStatic() ^ ownerType.getSort().isNonGeneric()) {
&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not define the correct parameters for owning &quot; + rawType);
&nbsp;                    }
&nbsp;
&nbsp;                    if (rawType.getTypeVariables().size() != parameters.size()) {
&nbsp;                        throw new IllegalArgumentException(parameters + &quot; does not contain number of required parameters for &quot; + rawType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return new OfParameterizedType(rawType, ownerType, new TypeList.Explicit(new ArrayList(parameters)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound() {
&nbsp;                return this.asWildcardUpperBound((Collection)Collections.emptySet());
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public Generic asWildcardUpperBound(Annotation... annotation) {
&nbsp;                return this.asWildcardUpperBound(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.asWildcardUpperBound((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public Generic asWildcardUpperBound(AnnotationDescription... annotation) {</b>
<b class="fc">&nbsp;                return this.asWildcardUpperBound((Collection)Arrays.asList(annotation));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public Generic asWildcardUpperBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.boundedAbove(this.build(), new AnnotationSource.Explicit(new ArrayList(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic asWildcardLowerBound() {
&nbsp;                return this.asWildcardLowerBound((Collection)Collections.emptySet());
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Generic asWildcardLowerBound(Annotation... annotation) {
<b class="nc">&nbsp;                return this.asWildcardLowerBound(Arrays.asList(annotation));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Generic asWildcardLowerBound(List&lt;? extends Annotation&gt; annotations) {</b>
<b class="nc">&nbsp;                return this.asWildcardLowerBound((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Generic asWildcardLowerBound(AnnotationDescription... annotation) {
&nbsp;                return this.asWildcardLowerBound((Collection)Arrays.asList(annotation));
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Generic asWildcardLowerBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return TypeDescription.Generic.OfWildcardType.Latent.boundedBelow(this.build(), new AnnotationSource.Explicit(new ArrayList(annotations)));
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            public Builder asArray() {
&nbsp;                return this.asArray(1);
&nbsp;            }
&nbsp;
&nbsp;            public Builder asArray(int arity) {
&nbsp;                if (arity &lt; 1) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot define an array of a non-positive arity: &quot; + arity);</b>
&nbsp;                } else {
&nbsp;                    Generic typeDescription = this.build();
&nbsp;
&nbsp;                    while(true) {
&nbsp;                        --arity;
&nbsp;                        if (arity &lt;= 0) {
<b class="nc">&nbsp;                            return new OfGenericArrayType(typeDescription);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        typeDescription = new OfGenericArray.Latent(typeDescription, Empty.INSTANCE);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Builder annotate(Annotation... annotation) {</b>
<b class="nc">&nbsp;                return this.annotate(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public Builder annotate(List&lt;? extends Annotation&gt; annotations) {</b>
&nbsp;                return this.annotate((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Builder annotate(AnnotationDescription... annotation) {
&nbsp;                return this.annotate((Collection)Arrays.asList(annotation));
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public Builder annotate(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return this.doAnnotate(new ArrayList(annotations));
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; var1);
&nbsp;
&nbsp;            public Generic build() {
&nbsp;                return this.doBuild();
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(Annotation... annotation) {
&nbsp;                return this.build(Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(List&lt;? extends Annotation&gt; annotations) {
&nbsp;                return this.build((Collection)(new AnnotationList.ForLoadedAnnotations(annotations)));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(AnnotationDescription... annotation) {
&nbsp;                return this.build((Collection)Arrays.asList(annotation));
&nbsp;            }
&nbsp;
&nbsp;            public Generic build(Collection&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                return this.doAnnotate(new ArrayList(annotations)).doBuild();
&nbsp;            }
&nbsp;
&nbsp;            protected abstract Generic doBuild();
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.annotations.equals(((Builder)var1).annotations);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.annotations.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected static enum Visitor implements Visitor&lt;Builder&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Visitor() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Builder onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArrayType(genericArray.getComponentType(), genericArray.getDeclaredAnnotations());
&nbsp;                }
&nbsp;
&nbsp;                public Builder onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot resolve wildcard type &quot; + wildcard + &quot; to builder&quot;);
&nbsp;                }
&nbsp;
&nbsp;                public Builder onParameterizedType(Generic parameterizedType) {
&nbsp;                    return new OfParameterizedType(parameterizedType.asErasure(), parameterizedType.getOwnerType(), parameterizedType.getTypeArguments(), parameterizedType.getDeclaredAnnotations());
&nbsp;                }
&nbsp;
&nbsp;                public Builder onTypeVariable(Generic typeVariable) {
&nbsp;                    return new OfTypeVariable(typeVariable.getSymbol(), typeVariable.getDeclaredAnnotations());
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Builder onNonGenericType(Generic typeDescription) {
&nbsp;                    return (Builder)(typeDescription.isArray() ? ((Builder)typeDescription.getComponentType().accept(this)).asArray().annotate((Collection)typeDescription.getDeclaredAnnotations()) : new OfNonGenericType(typeDescription.asErasure(), typeDescription.getOwnerType(), typeDescription.getDeclaredAnnotations()));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class OfNonGenericType extends Builder {
&nbsp;                private final TypeDescription typeDescription;
&nbsp;                @MaybeNull
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription) {
&nbsp;                    this(typeDescription, typeDescription.getDeclaringType());
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @MaybeNull TypeDescription ownerType) {</b>
&nbsp;                    this(typeDescription, ownerType == null ? TypeDescription.Generic.UNDEFINED : ownerType.asGenericType());
&nbsp;                }
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                    this(typeDescription, ownerType, Collections.emptyList());</b>
&nbsp;                }
&nbsp;
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @MaybeNull Generic ownerType, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
&nbsp;                    this.ownerType = ownerType;
<b class="nc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfNonGenericType(this.typeDescription, this.ownerType, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected Generic doBuild() {</b>
&nbsp;                    if (this.typeDescription.represents(Void.TYPE) &amp;&amp; !this.annotations.isEmpty()) {
&nbsp;                        throw new IllegalArgumentException(&quot;The void non-type cannot be annotated&quot;);
&nbsp;                    } else {
&nbsp;                        return new OfNonGenericType.Latent(this.typeDescription, this.ownerType, new AnnotationSource.Explicit(this.annotations));
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.typeDescription.equals(((OfNonGenericType)var1).typeDescription)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic var2 = ((OfNonGenericType)var1).ownerType;
<b class="nc">&nbsp;                        Generic var3 = this.ownerType;</b>
&nbsp;                        if (var2 != null) {
&nbsp;                            if (var3 == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
&nbsp;                            if (!var3.equals(var2)) {
<b class="nc">&nbsp;                                return false;</b>
&nbsp;                            }
&nbsp;                        } else if (var3 != null) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    int var10000 = (super.hashCode() * 31 + this.typeDescription.hashCode()) * 31;
&nbsp;                    Generic var1 = this.ownerType;
&nbsp;                    if (var1 != null) {
<b class="nc">&nbsp;                        var10000 += var1.hashCode();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            @Enhance</b>
&nbsp;            protected static class OfParameterizedType extends Builder {
&nbsp;                private final TypeDescription rawType;
&nbsp;                @MaybeNull
&nbsp;                @ValueHandling(net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;                private final List&lt;? extends Generic&gt; parameterTypes;
<b class="nc">&nbsp;</b>
&nbsp;                protected OfParameterizedType(TypeDescription rawType, @MaybeNull Generic ownerType, List&lt;? extends Generic&gt; parameterTypes) {
&nbsp;                    this(rawType, ownerType, parameterTypes, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfParameterizedType(TypeDescription rawType, @MaybeNull Generic ownerType, List&lt;? extends Generic&gt; parameterTypes, List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    super(annotations);
<b class="nc">&nbsp;                    this.rawType = rawType;</b>
&nbsp;                    this.ownerType = ownerType;
&nbsp;                    this.parameterTypes = parameterTypes;
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfParameterizedType(this.rawType, this.ownerType, this.parameterTypes, CompoundList.of(this.annotations, annotations));
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new OfParameterizedType.Latent(this.rawType, this.ownerType, this.parameterTypes, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
<b class="nc">&nbsp;                    if (!super.equals(var1)) {</b>
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    } else if (!this.rawType.equals(((OfParameterizedType)var1).rawType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Generic var2 = ((OfParameterizedType)var1).ownerType;
&nbsp;                        Generic var3 = this.ownerType;
&nbsp;                        if (var2 != null) {
&nbsp;                            if (var3 == null) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            if (!var3.equals(var2)) {</b>
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        } else if (var3 != null) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        if (!this.parameterTypes.equals(((OfParameterizedType)var1).parameterTypes)) {</b>
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                public int hashCode() {
&nbsp;                    int var10000 = (super.hashCode() * 31 + this.rawType.hashCode()) * 31;
&nbsp;                    Generic var1 = this.ownerType;
&nbsp;                    if (var1 != null) {
&nbsp;                        var10000 += var1.hashCode();
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    return var10000 * 31 + this.parameterTypes.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class OfGenericArrayType extends Builder {
<b class="fc">&nbsp;                private final Generic componentType;</b>
&nbsp;
&nbsp;                protected OfGenericArrayType(Generic componentType) {
&nbsp;                    this(componentType, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfGenericArrayType(Generic componentType, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                    super(annotations);</b>
&nbsp;                    this.componentType = componentType;
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfGenericArrayType(this.componentType, CompoundList.of(this.annotations, annotations));
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                protected Generic doBuild() {
&nbsp;                    return new OfGenericArray.Latent(this.componentType, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return this.componentType.equals(((OfGenericArrayType)var1).componentType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.componentType.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            protected static class OfTypeVariable extends Builder {
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                protected OfTypeVariable(String symbol) {
&nbsp;                    this(symbol, Collections.emptyList());
&nbsp;                }
&nbsp;
&nbsp;                protected OfTypeVariable(String symbol, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    super(annotations);</b>
<b class="fc">&nbsp;                    this.symbol = symbol;</b>
&nbsp;                }
&nbsp;
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
&nbsp;                    return new OfTypeVariable(this.symbol, CompoundList.of(this.annotations, annotations));
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected Generic doBuild() {</b>
&nbsp;                    return new OfTypeVariable.Symbolic(this.symbol, new AnnotationSource.Explicit(this.annotations));
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.symbol.equals(((OfTypeVariable)var1).symbol);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.symbol.hashCode();
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public interface AnnotationReader {
&nbsp;            AnnotatedElement resolve();
&nbsp;
&nbsp;            AnnotationList asList();
<b class="fc">&nbsp;</b>
&nbsp;            AnnotationReader ofWildcardUpperBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofWildcardLowerBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofTypeVariableBoundType(int var1);
&nbsp;
&nbsp;            AnnotationReader ofTypeArgument(int var1);
&nbsp;
&nbsp;            AnnotationReader ofOwnerType();
&nbsp;
&nbsp;            AnnotationReader ofOuterClass();
&nbsp;
&nbsp;            AnnotationReader ofComponentType();
&nbsp;
&nbsp;            public static enum NoOp implements AnnotationReader, AnnotatedElement {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private NoOp() {
&nbsp;                }
&nbsp;
&nbsp;                public AnnotatedElement resolve() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList asList() {
&nbsp;                    return new AnnotationList.Empty();
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {</b>
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="pc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOwnerType() {
&nbsp;                    return this;
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public AnnotationReader ofOuterClass() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofComponentType() {
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Annotation[] getAnnotations() {
&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                public Annotation[] getDeclaredAnnotations() {
&nbsp;                    return new Annotation[0];
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Delegator implements AnnotationReader {
<b class="fc">&nbsp;                private static final boolean ACCESS_CONTROLLER;</b>
<b class="pc">&nbsp;</b>
&nbsp;                public Delegator() {
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;                static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;                    return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
&nbsp;                    return new ForWildcardUpperBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
&nbsp;                    return new ForWildcardLowerBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
&nbsp;                    return new ForTypeVariableBoundType(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
&nbsp;                    return new ForTypeArgument(this, index);
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofOwnerType() {
&nbsp;                    return new ForOwnerType(this);
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public AnnotationReader ofOuterClass() {</b>
<b class="fc">&nbsp;                    return new ForOwnerType(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationReader ofComponentType() {
&nbsp;                    return new ForComponentType(this);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public AnnotationList asList() {</b>
<b class="pc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(this.resolve().getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    try {
&nbsp;                        Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                        ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;                    } catch (ClassNotFoundException var0) {
&nbsp;                        ACCESS_CONTROLLER = false;
&nbsp;                    } catch (SecurityException var1) {
&nbsp;                        ACCESS_CONTROLLER = true;
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Simple extends Delegator {
&nbsp;                    private final AnnotatedElement annotatedElement;
&nbsp;
&nbsp;                    public Simple(AnnotatedElement annotatedElement) {
&nbsp;                        this.annotatedElement = annotatedElement;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return this.annotatedElement;
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.annotatedElement.equals(((Simple)var1).annotatedElement);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.annotatedElement.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected abstract static class Chained extends Delegator {
&nbsp;                    protected final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    protected Chained(AnnotationReader annotationReader) {
&nbsp;                        this.annotationReader = annotationReader;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return this.resolve(this.annotationReader.resolve());
&nbsp;                    }
&nbsp;
&nbsp;                    protected abstract AnnotatedElement resolve(AnnotatedElement var1);
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
<b class="fc">&nbsp;                            return this.annotationReader.equals(((Chained)var1).annotationReader);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.annotationReader.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForLoadedTypeVariable extends Delegator {
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public ForLoadedTypeVariable(TypeVariable&lt;?&gt; typeVariable) {</b>
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;BC_VACUOUS_INSTANCEOF&quot;},
&nbsp;                        justification = &quot;Cast is required for JVMs before Java 8.&quot;
<b class="fc">&nbsp;                    )</b>
<b class="pc">&nbsp;                    public AnnotatedElement resolve() {</b>
&nbsp;                        return (AnnotatedElement)(this.typeVariable instanceof AnnotatedElement ? this.typeVariable : TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE);
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotationReader ofTypeVariableBoundType(int index) {
&nbsp;                        return new ForTypeVariableBoundType.OfFormalTypeVariable(this.typeVariable, index);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeVariable.equals(((ForLoadedTypeVariable)var1).typeVariable);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeVariable.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedSuperClass extends Delegator {
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                    public ForLoadedSuperClass(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                        this.type = type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = TypeDescription.ForLoadedType.DISPATCHER.getAnnotatedSuperclass(this.type);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.type.equals(((ForLoadedSuperClass)var1).type);
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return this.getClass().hashCode() * 31 + this.type.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
<b class="fc">&nbsp;                )</b>
<b class="pc">&nbsp;                public static class ForLoadedInterface extends Delegator {</b>
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public ForLoadedInterface(Class&lt;?&gt; type, int index) {
&nbsp;                        this.type = type;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement[] element = TypeDescription.ForLoadedType.DISPATCHER.getAnnotatedInterfaces(this.type);
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((ForLoadedInterface)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.type.equals(((ForLoadedInterface)var1).type);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
<b class="fc">&nbsp;                        return (this.getClass().hashCode() * 31 + this.type.hashCode()) * 31 + this.index;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedField extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final Field field;
&nbsp;
&nbsp;                    public ForLoadedField(Field field) {
&nbsp;                        this.field = field;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedType(this.field);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else {</b>
<b class="pc">&nbsp;                            return this.field.equals(((ForLoadedField)var1).field);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.field.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Field&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @MaybeNull
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedType&quot;)
&nbsp;                        AnnotatedElement getAnnotatedType(Field var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedMethodReturnType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final Method method;
&nbsp;
&nbsp;                    public ForLoadedMethodReturnType(Method method) {
&nbsp;                        this.method = method;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedReturnType(this.method);
&nbsp;                        return (AnnotatedElement)(element == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.method.equals(((ForLoadedMethodReturnType)var1).method);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.method.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Method&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @MaybeNull
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedReturnType&quot;)
&nbsp;                        AnnotatedElement getAnnotatedReturnType(Method var1);
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedExecutableParameterType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final AccessibleObject executable;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public ForLoadedExecutableParameterType(AccessibleObject executable, int index) {
&nbsp;                        this.executable = executable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public AnnotatedElement resolve() {</b>
<b class="fc">&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedParameterTypes(this.executable);</b>
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
<b class="pc">&nbsp;                        if (this == var1) {</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else if (this.getClass() != var1.getClass()) {</b>
<b class="pc">&nbsp;                            return false;</b>
&nbsp;                        } else if (this.index != ((ForLoadedExecutableParameterType)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
<b class="nc">&nbsp;                            return this.executable.equals(((ForLoadedExecutableParameterType)var1).executable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.executable.hashCode()) * 31 + this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedParameterTypes&quot;)
&nbsp;                        AnnotatedElement[] getAnnotatedParameterTypes(Object var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance(
&nbsp;                    includeSyntheticFields = true
&nbsp;                )
&nbsp;                public static class ForLoadedExecutableExceptionType extends Delegator {
&nbsp;                    protected static final Dispatcher DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;                    private final AccessibleObject executable;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    public ForLoadedExecutableExceptionType(AccessibleObject executable, int index) {
&nbsp;                        this.executable = executable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedExceptionTypes(this.executable);
&nbsp;                        return (AnnotatedElement)(element.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : element[this.index]);
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((ForLoadedExecutableExceptionType)var1).index) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.executable.equals(((ForLoadedExecutableExceptionType)var1).executable);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.executable.hashCode()) * 31 + this.index;
&nbsp;                    }
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;                        @Defaults
&nbsp;                        @Proxied(&quot;getAnnotatedExceptionTypes&quot;)
&nbsp;                        AnnotatedElement[] getAnnotatedExceptionTypes(Object var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static class ForLoadedRecordComponent extends Delegator {
&nbsp;                    private final Object recordComponent;
&nbsp;
&nbsp;                    public ForLoadedRecordComponent(Object recordComponent) {
&nbsp;                        this.recordComponent = recordComponent;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        return net.bytebuddy.description.type.RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getAnnotatedType(this.recordComponent);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForWildcardUpperBoundType extends Delegator.Chained {
&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = (AnnotatedWildcardType)doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForWildcardUpperBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            AnnotatedElement[] annotatedUpperBound = ANNOTATED_WILDCARD_TYPE.getAnnotatedUpperBounds(annotatedElement);
&nbsp;                            return (AnnotatedElement)(annotatedUpperBound.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedUpperBound[this.index]);
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForWildcardUpperBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)
&nbsp;                protected interface AnnotatedWildcardType {
<b class="fc">&nbsp;                    @Instance</b>
<b class="fc">&nbsp;                    @Proxied(&quot;isInstance&quot;)</b>
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedUpperBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedUpperBounds(AnnotatedElement var1);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
<b class="nc">&nbsp;            public static class ForWildcardLowerBoundType extends Delegator.Chained {</b>
&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = (AnnotatedWildcardType)doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));
<b class="nc">&nbsp;                private final int index;</b>
&nbsp;
&nbsp;                protected ForWildcardLowerBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_WILDCARD_TYPE.getAnnotatedLowerBounds(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForWildcardLowerBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)</b>
&nbsp;                protected interface AnnotatedWildcardType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedLowerBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedLowerBounds(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForTypeVariableBoundType extends Delegator.Chained {
&nbsp;                private static final AnnotatedTypeVariable ANNOTATED_TYPE_VARIABLE = (AnnotatedTypeVariable)doPrivileged(JavaDispatcher.of(AnnotatedTypeVariable.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForTypeVariableBoundType(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_TYPE_VARIABLE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_TYPE_VARIABLE.getAnnotatedBounds(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
<b class="fc">&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;</b>
<b class="pc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForTypeVariableBoundType)var1).index;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class OfFormalTypeVariable extends Delegator {
&nbsp;                    private static final FormalTypeVariable TYPE_VARIABLE = (FormalTypeVariable)doPrivileged(JavaDispatcher.of(FormalTypeVariable.class));
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    protected OfFormalTypeVariable(TypeVariable&lt;?&gt; typeVariable, int index) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                        this.index = index;
&nbsp;                    }
&nbsp;
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        try {
&nbsp;                            AnnotatedElement[] annotatedBound = TYPE_VARIABLE.getAnnotatedBounds(this.typeVariable);
&nbsp;                            return (AnnotatedElement)(annotatedBound.length == 0 ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedBound[this.index]);
<b class="fc">&nbsp;                        } catch (ClassCastException var2) {</b>
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (this.index != ((OfFormalTypeVariable)var1).index) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            return this.typeVariable.equals(((OfFormalTypeVariable)var1).typeVariable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
<b class="pc">&nbsp;                        return (this.getClass().hashCode() * 31 + this.typeVariable.hashCode()) * 31 + this.index;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Proxied(&quot;java.lang.reflect.TypeVariable&quot;)
<b class="fc">&nbsp;                    protected interface FormalTypeVariable {</b>
&nbsp;                        @Defaults
<b class="nc">&nbsp;                        @Proxied(&quot;getAnnotatedBounds&quot;)</b>
&nbsp;                        AnnotatedElement[] getAnnotatedBounds(Object var1);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedTypeVariable&quot;)
&nbsp;                protected interface AnnotatedTypeVariable {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedBounds&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedBounds(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForTypeArgument extends Delegator.Chained {
&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = (AnnotatedParameterizedType)doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));
&nbsp;                private final int index;
&nbsp;
&nbsp;                protected ForTypeArgument(AnnotationReader annotationReader, int index) {
&nbsp;                    super(annotationReader);
&nbsp;                    this.index = index;
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedActualTypeArguments(annotatedElement)[this.index];
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (!super.equals(var1)) {
&nbsp;                        return false;
&nbsp;                    } else if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.index == ((ForTypeArgument)var1).index;
&nbsp;                    }
<b class="pc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public int hashCode() {
&nbsp;                    return super.hashCode() * 31 + this.index;
<b class="fc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedParameterizedType&quot;)</b>
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedActualTypeArguments&quot;)
&nbsp;                    AnnotatedElement[] getAnnotatedActualTypeArguments(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForComponentType extends Delegator.Chained {
&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = (AnnotatedParameterizedType)doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));
&nbsp;
&nbsp;                protected ForComponentType(AnnotationReader annotationReader) {
&nbsp;                    super(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedGenericComponentType(annotatedElement);
&nbsp;                        } catch (ClassCastException var3) {
&nbsp;                            return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedArrayType&quot;)
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;                    @Instance
&nbsp;                    @Proxied(&quot;isInstance&quot;)
&nbsp;                    boolean isInstance(AnnotatedElement var1);
&nbsp;
&nbsp;                    @Proxied(&quot;getAnnotatedGenericComponentType&quot;)
&nbsp;                    AnnotatedElement getAnnotatedGenericComponentType(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForOwnerType extends Delegator.Chained {
&nbsp;                private static final AnnotatedType ANNOTATED_TYPE = (AnnotatedType)doPrivileged(JavaDispatcher.of(AnnotatedType.class));
&nbsp;
&nbsp;                protected ForOwnerType(AnnotationReader annotationReader) {
&nbsp;                    super(annotationReader);
&nbsp;                }
&nbsp;
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
&nbsp;                        AnnotatedElement annotatedOwnerType = ANNOTATED_TYPE.getAnnotatedOwnerType(annotatedElement);
&nbsp;                        return (AnnotatedElement)(annotatedOwnerType == null ? TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE : annotatedOwnerType);
&nbsp;                    } catch (ClassCastException var3) {
&nbsp;                        return TypeDescription.Generic.AnnotationReader.NoOp.INSTANCE;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Proxied(&quot;java.lang.reflect.AnnotatedType&quot;)
&nbsp;                protected interface AnnotatedType {
&nbsp;                    @MaybeNull
&nbsp;                    @Defaults
&nbsp;                    @Proxied(&quot;getAnnotatedOwnerType&quot;)
&nbsp;                    AnnotatedElement getAnnotatedOwnerType(AnnotatedElement var1);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface Visitor&lt;T&gt; {
&nbsp;            T onGenericArray(Generic var1);
&nbsp;
&nbsp;            T onWildcard(Generic var1);
&nbsp;
&nbsp;            T onParameterizedType(Generic var1);
&nbsp;
&nbsp;            T onTypeVariable(Generic var1);
&nbsp;
&nbsp;            T onNonGenericType(Generic var1);
&nbsp;
&nbsp;            public static enum NoOp implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private NoOp() {
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return genericArray;
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public Generic onWildcard(Generic wildcard) {</b>
&nbsp;                    return wildcard;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return parameterizedType;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return typeVariable;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription;
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            public static enum TypeErasing implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private TypeErasing() {
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return genericArray.asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot erase a wildcard type: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return parameterizedType.asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return typeVariable.asRawType();
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription.asRawType();
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public static enum AnnotationStripper implements Visitor&lt;Generic&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private AnnotationStripper() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
<b class="fc">&nbsp;                )</b>
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArray.Latent((Generic)genericArray.getComponentType().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();</b>
&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asErasure(), ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(this), parameterizedType.getTypeArguments().accept(this), Empty.INSTANCE);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                    return new NonAnnotatedTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return (Generic)(typeDescription.isArray() ? new OfGenericArray.Latent(this.onNonGenericType(typeDescription.getComponentType()), Empty.INSTANCE) : new OfNonGenericType.Latent(typeDescription.asErasure(), Empty.INSTANCE));
&nbsp;                }
&nbsp;
&nbsp;                protected static class NonAnnotatedTypeVariable extends OfTypeVariable {
<b class="fc">&nbsp;                    private final Generic typeVariable;</b>
&nbsp;
&nbsp;                    protected NonAnnotatedTypeVariable(Generic typeVariable) {
&nbsp;                        this.typeVariable = typeVariable;
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public TypeList.Generic getUpperBounds() {</b>
&nbsp;                        return this.typeVariable.getUpperBounds();
&nbsp;                    }
&nbsp;
&nbsp;                    public TypeVariableSource getTypeVariableSource() {
&nbsp;                        return this.typeVariable.getTypeVariableSource();
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public String getSymbol() {</b>
<b class="fc">&nbsp;                        return this.typeVariable.getSymbol();</b>
<b class="pc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="pc">&nbsp;                        return new AnnotationList.Empty();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Assigner implements Visitor&lt;Dispatcher&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Assigner() {
<b class="fc">&nbsp;                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                public Dispatcher onGenericArray(Generic genericArray) {</b>
&nbsp;                    return new Dispatcher.ForGenericArray(genericArray);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Dispatcher onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;A wildcard is not a first level type: &quot; + this);
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                    return new Dispatcher.ForParameterizedType(parameterizedType);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Dispatcher onTypeVariable(Generic typeVariable) {
&nbsp;                    return new Dispatcher.ForTypeVariable(typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                    return new Dispatcher.ForNonGenericType(typeDescription.asErasure());
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                public interface Dispatcher {</b>
&nbsp;                    boolean isAssignableFrom(Generic var1);
&nbsp;
&nbsp;                    public abstract static class AbstractBase implements Dispatcher, Visitor&lt;Boolean&gt; {
&nbsp;                        public AbstractBase() {
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                            return (Boolean)typeDescription.accept(this);
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class ForNonGenericType extends AbstractBase {
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        protected ForNonGenericType(TypeDescription typeDescription) {
&nbsp;                            this.typeDescription = typeDescription;
&nbsp;                        }
<b class="nc">&nbsp;</b>
&nbsp;                        @SuppressFBWarnings(
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return this.typeDescription.isArray() ? (Boolean)genericArray.getComponentType().accept(new ForNonGenericType(this.typeDescription.getComponentType())) : this.typeDescription.represents(Object.class) || TypeDescription.ARRAY_INTERFACES.contains(this.typeDescription.asGenericType());
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                            if (this.typeDescription.equals(parameterizedType.asErasure())) {</b>
&nbsp;                                return true;
&nbsp;                            } else {
&nbsp;                                Generic superClass = parameterizedType.getSuperClass();
&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {
&nbsp;                                    return true;
&nbsp;                                } else {
<b class="nc">&nbsp;                                    for(Generic interfaceType : parameterizedType.getInterfaces()) {</b>
&nbsp;                                        if (this.isAssignableFrom(interfaceType)) {
&nbsp;                                            return true;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    return this.typeDescription.represents(Object.class);
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            for(Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                if (this.isAssignableFrom(upperBound)) {
<b class="nc">&nbsp;                                    return true;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {</b>
&nbsp;                            return this.typeDescription.isAssignableFrom(typeDescription.asErasure());
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
<b class="nc">&nbsp;                            } else if (var1 == null) {</b>
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.typeDescription.equals(((ForNonGenericType)var1).typeDescription);
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    @Enhance</b>
&nbsp;                    public static class ForTypeVariable extends AbstractBase {
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected ForTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
<b class="fc">&nbsp;</b>
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
<b class="nc">&nbsp;                            if (typeVariable.equals(this.typeVariable)) {</b>
&nbsp;                                return true;
&nbsp;                            } else {
&nbsp;                                for(Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                    if (this.isAssignableFrom(upperBound)) {
&nbsp;                                        return true;
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
<b class="fc">&nbsp;                            } else if (var1 == null) {</b>
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.typeVariable.equals(((ForTypeVariable)var1).typeVariable);
<b class="pc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.typeVariable.hashCode();
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class ForParameterizedType extends AbstractBase {
&nbsp;                        private final Generic parameterizedType;
&nbsp;
&nbsp;                        protected ForParameterizedType(Generic parameterizedType) {
&nbsp;                            this.parameterizedType = parameterizedType;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                            if (this.parameterizedType.asErasure().equals(parameterizedType.asErasure())) {</b>
<b class="fc">&nbsp;                                Generic fromOwner = this.parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                                Generic toOwner = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                                if (fromOwner != null &amp;&amp; toOwner != null &amp;&amp; !((Dispatcher)fromOwner.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(toOwner)) {</b>
<b class="fc">&nbsp;                                    return false;</b>
<b class="fc">&nbsp;                                } else {</b>
<b class="fc">&nbsp;                                    TypeList.Generic fromArguments = this.parameterizedType.getTypeArguments();</b>
<b class="fc">&nbsp;                                    TypeList.Generic toArguments = parameterizedType.getTypeArguments();</b>
<b class="fc">&nbsp;                                    if (fromArguments.size() == toArguments.size()) {</b>
<b class="fc">&nbsp;                                        for(int index = 0; index &lt; fromArguments.size(); ++index) {</b>
<b class="fc">&nbsp;                                            if (!((Dispatcher)((Generic)fromArguments.get(index)).accept(TypeDescription.Generic.Visitor.Assigner.Dispatcher.ForParameterizedType.ParameterAssigner.INSTANCE)).isAssignableFrom((Generic)toArguments.get(index))) {</b>
<b class="fc">&nbsp;                                                return false;</b>
<b class="fc">&nbsp;                                            }</b>
<b class="fc">&nbsp;                                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                                        return true;</b>
<b class="fc">&nbsp;                                    } else {</b>
<b class="fc">&nbsp;                                        throw new IllegalArgumentException(&quot;Incompatible generic types: &quot; + parameterizedType + &quot; and &quot; + this.parameterizedType);</b>
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                            } else {</b>
&nbsp;                                Generic superClass = parameterizedType.getSuperClass();
&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {
&nbsp;                                    return true;
&nbsp;                                } else {
&nbsp;                                    for(Generic interfaceType : parameterizedType.getInterfaces()) {
&nbsp;                                        if (this.isAssignableFrom(interfaceType)) {
&nbsp;                                            return true;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    return false;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            for(Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                                if (this.isAssignableFrom(upperBound)) {
&nbsp;                                    return true;
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            if (this.parameterizedType.asErasure().equals(typeDescription.asErasure())) {
&nbsp;                                return true;
&nbsp;                            } else {
<b class="fc">&nbsp;                                Generic superClass = typeDescription.getSuperClass();</b>
<b class="fc">&nbsp;                                if (superClass != null &amp;&amp; this.isAssignableFrom(superClass)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                } else {
&nbsp;                                    for(Generic interfaceType : typeDescription.getInterfaces()) {
&nbsp;                                        if (this.isAssignableFrom(interfaceType)) {
&nbsp;                                            return true;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    return false;
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
<b class="fc">&nbsp;                            } else {</b>
&nbsp;                                return this.parameterizedType.equals(((ForParameterizedType)var1).parameterizedType);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.parameterizedType.hashCode();
&nbsp;                        }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                        protected static enum ParameterAssigner implements Visitor&lt;Dispatcher&gt; {</b>
&nbsp;                            INSTANCE;
<b class="nc">&nbsp;</b>
&nbsp;                            private ParameterAssigner() {
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onGenericArray(Generic genericArray) {
&nbsp;                                return new InvariantBinding(genericArray);
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            public Dispatcher onWildcard(Generic wildcard) {</b>
<b class="fc">&nbsp;                                TypeList.Generic lowerBounds = wildcard.getLowerBounds();</b>
&nbsp;                                return (Dispatcher)(lowerBounds.isEmpty() ? new CovariantBinding((Generic)wildcard.getUpperBounds().getOnly()) : new ContravariantBinding((Generic)lowerBounds.getOnly()));
<b class="fc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            public Dispatcher onParameterizedType(Generic parameterizedType) {
&nbsp;                                return new InvariantBinding(parameterizedType);
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                                return new InvariantBinding(typeVariable);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            public Dispatcher onNonGenericType(Generic typeDescription) {
&nbsp;                                return new InvariantBinding(typeDescription);
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            @Enhance</b>
&nbsp;                            protected static class InvariantBinding implements Dispatcher {
&nbsp;                                private final Generic typeDescription;
&nbsp;
&nbsp;                                protected InvariantBinding(Generic typeDescription) {
&nbsp;                                    this.typeDescription = typeDescription;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    return typeDescription.equals(this.typeDescription);
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(@MaybeNull Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.typeDescription.equals(((InvariantBinding)var1).typeDescription);
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                public int hashCode() {
&nbsp;                                    return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;
<b class="fc">&nbsp;                            @Enhance</b>
&nbsp;                            protected static class CovariantBinding implements Dispatcher {
&nbsp;                                private final Generic upperBound;
&nbsp;
&nbsp;                                protected CovariantBinding(Generic upperBound) {
&nbsp;                                    this.upperBound = upperBound;
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {</b>
<b class="pc">&nbsp;                                    if (!typeDescription.getSort().isWildcard()) {</b>
&nbsp;                                        return ((Dispatcher)this.upperBound.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(typeDescription);
<b class="nc">&nbsp;                                    } else {</b>
&nbsp;                                        return typeDescription.getLowerBounds().isEmpty() &amp;&amp; ((Dispatcher)this.upperBound.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom((Generic)typeDescription.getUpperBounds().getOnly());
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(@MaybeNull Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
<b class="fc">&nbsp;                                    } else if (var1 == null) {</b>
<b class="pc">&nbsp;                                        return false;</b>
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
<b class="nc">&nbsp;                                        return false;</b>
&nbsp;                                    } else {
&nbsp;                                        return this.upperBound.equals(((CovariantBinding)var1).upperBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public int hashCode() {
<b class="fc">&nbsp;                                    return this.getClass().hashCode() * 31 + this.upperBound.hashCode();</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            @Enhance
&nbsp;                            protected static class ContravariantBinding implements Dispatcher {
&nbsp;                                private final Generic lowerBound;
&nbsp;
&nbsp;                                protected ContravariantBinding(Generic lowerBound) {
&nbsp;                                    this.lowerBound = lowerBound;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
&nbsp;                                    if (typeDescription.getSort().isWildcard()) {
&nbsp;                                        TypeList.Generic lowerBounds = typeDescription.getLowerBounds();
&nbsp;                                        return !lowerBounds.isEmpty() &amp;&amp; ((Dispatcher)((Generic)lowerBounds.getOnly()).accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(this.lowerBound);
&nbsp;                                    } else {
&nbsp;                                        return typeDescription.getSort().isWildcard() || ((Dispatcher)typeDescription.accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(this.lowerBound);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(@MaybeNull Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.lowerBound.equals(((ContravariantBinding)var1).lowerBound);
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;</b>
&nbsp;                                public int hashCode() {
&nbsp;                                    return this.getClass().hashCode() * 31 + this.lowerBound.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance
&nbsp;                    public static class ForGenericArray extends AbstractBase {
&nbsp;                        private final Generic genericArray;
<b class="pc">&nbsp;</b>
&nbsp;                        protected ForGenericArray(Generic genericArray) {
&nbsp;                            this.genericArray = genericArray;
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        @SuppressFBWarnings(
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
&nbsp;                            return ((Dispatcher)this.genericArray.getComponentType().accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(genericArray.getComponentType());
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {</b>
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        @SuppressFBWarnings(</b>
&nbsp;                            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                            justification = &quot;Assuming component type for array type.&quot;
&nbsp;                        )
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                            return typeDescription.isArray() &amp;&amp; ((Dispatcher)this.genericArray.getComponentType().accept(TypeDescription.Generic.Visitor.Assigner.INSTANCE)).isAssignableFrom(typeDescription.getComponentType());
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;                            if (this == var1) {</b>
&nbsp;                                return true;
<b class="nc">&nbsp;                            } else if (var1 == null) {</b>
&nbsp;                                return false;
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.genericArray.equals(((ForGenericArray)var1).genericArray);
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.getClass().hashCode() * 31 + this.genericArray.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public static enum Validator implements Visitor&lt;Boolean&gt; {
&nbsp;                SUPER_CLASS(false, false, false, false) {
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; !typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return !parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;                INTERFACE(false, false, false, false) {
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; typeDescription.isInterface();
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return parameterizedType.isInterface();
&nbsp;                    }
&nbsp;                },
&nbsp;                TYPE_VARIABLE(false, false, true, false),
&nbsp;                FIELD(true, true, true, false),
&nbsp;                METHOD_RETURN(true, true, true, true),
&nbsp;                METHOD_PARAMETER(true, true, true, false),
&nbsp;                EXCEPTION(false, false, true, false) {
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                        for(Generic bound : typeVariable.getUpperBounds()) {
&nbsp;                            if ((Boolean)bound.accept(this)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return typeDescription.asErasure().isAssignableTo(Throwable.class);
&nbsp;                    }
&nbsp;                },
&nbsp;                RECEIVER(false, false, false, false);
&nbsp;
&nbsp;                private final boolean acceptsArray;
&nbsp;                private final boolean acceptsPrimitive;
&nbsp;                private final boolean acceptsVariable;
&nbsp;                private final boolean acceptsVoid;
&nbsp;
&nbsp;                private Validator(boolean acceptsArray, boolean acceptsPrimitive, boolean acceptsVariable, boolean acceptsVoid) {
&nbsp;                    this.acceptsArray = acceptsArray;
&nbsp;                    this.acceptsPrimitive = acceptsPrimitive;
&nbsp;                    this.acceptsVariable = acceptsVariable;
&nbsp;                    this.acceptsVoid = acceptsVoid;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onGenericArray(Generic genericArray) {
&nbsp;                    return this.acceptsArray;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onWildcard(Generic wildcard) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onParameterizedType(Generic parameterizedType) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onTypeVariable(Generic typeVariable) {
&nbsp;                    return this.acceptsVariable;
&nbsp;                }
&nbsp;
&nbsp;                public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                    return (this.acceptsArray || !typeDescription.isArray()) &amp;&amp; (this.acceptsPrimitive || !typeDescription.isPrimitive()) &amp;&amp; (this.acceptsVoid || !typeDescription.represents(Void.TYPE));
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForTypeAnnotations implements Visitor&lt;Boolean&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private static final String TYPE_USE = &quot;TYPE_USE&quot;;
&nbsp;                    private static final String TYPE_PARAMETER = &quot;TYPE_PARAMETER&quot;;
&nbsp;
&nbsp;                    private ForTypeAnnotations() {
&nbsp;                    }
&nbsp;
&nbsp;                    public static boolean ofFormalTypeVariable(Generic typeVariable) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
&nbsp;
&nbsp;                        for(AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {
&nbsp;                            if (!annotationDescription.isSupportedOn(&quot;TYPE_PARAMETER&quot;) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming component type for array type.&quot;
&nbsp;                    )
&nbsp;                    public Boolean onGenericArray(Generic genericArray) {
&nbsp;                        return this.isValid(genericArray) &amp;&amp; (Boolean)genericArray.getComponentType().accept(this);
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onWildcard(Generic wildcard) {
&nbsp;                        if (!this.isValid(wildcard)) {
&nbsp;                            return false;
<b class="fc">&nbsp;                        } else {</b>
&nbsp;                            TypeList.Generic lowerBounds = wildcard.getLowerBounds();
&nbsp;                            return (Boolean)((Generic)(lowerBounds.isEmpty() ? wildcard.getUpperBounds() : lowerBounds).getOnly()).accept(this);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        if (!this.isValid(parameterizedType)) {</b>
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                            if (ownerType != null &amp;&amp; !(Boolean)ownerType.accept(this)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                for(Generic typeArgument : parameterizedType.getTypeArguments()) {
&nbsp;                                    if (!(Boolean)typeArgument.accept(this)) {
&nbsp;                                        return false;
<b class="fc">&nbsp;                                    }</b>
&nbsp;                                }
&nbsp;
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {</b>
&nbsp;                        return this.isValid(typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                        justification = &quot;Assuming component type for array type.&quot;
<b class="nc">&nbsp;                    )</b>
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
&nbsp;                        return this.isValid(typeDescription) &amp;&amp; (!typeDescription.isArray() || (Boolean)typeDescription.getComponentType().accept(this));
&nbsp;                    }
&nbsp;
&nbsp;                    private boolean isValid(Generic typeDescription) {
&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
<b class="nc">&nbsp;</b>
&nbsp;                        for(AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {
&nbsp;                            if (!annotationDescription.isSupportedOn(&quot;TYPE_USE&quot;) || !annotationTypes.add(annotationDescription.getAnnotationType())) {
&nbsp;                                return false;
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Reifying implements Visitor&lt;Generic&gt; {
&nbsp;                INITIATING {
<b class="nc">&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {</b>
&nbsp;                        return parameterizedType;
&nbsp;                    }
&nbsp;                },
&nbsp;                INHERITING {
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                        return new OfParameterizedType.ForReifiedType(parameterizedType);
<b class="nc">&nbsp;                    }</b>
&nbsp;                };
&nbsp;
&nbsp;                private Reifying() {
&nbsp;                }
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a generic array: &quot; + genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a wildcard: &quot; + wildcard);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public Generic onTypeVariable(Generic typeVariable) {</b>
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a type variable: &quot; + typeVariable);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    TypeDescription erasure = typeDescription.asErasure();
&nbsp;                    return (Generic)(erasure.isGenerified() ? new OfNonGenericType.ForReifiedErasure(erasure) : typeDescription);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class ForSignatureVisitor implements Visitor&lt;SignatureVisitor&gt; {
&nbsp;                private static final int ONLY_CHARACTER = 0;
&nbsp;                protected final SignatureVisitor signatureVisitor;
<b class="nc">&nbsp;</b>
&nbsp;                public ForSignatureVisitor(SignatureVisitor signatureVisitor) {
&nbsp;                    this.signatureVisitor = signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
<b class="nc">&nbsp;                )</b>
&nbsp;                public SignatureVisitor onGenericArray(Generic genericArray) {
&nbsp;                    genericArray.getComponentType().accept(new ForSignatureVisitor(this.signatureVisitor.visitArrayType()));
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onParameterizedType(Generic parameterizedType) {
&nbsp;                    this.onOwnableType(parameterizedType);
&nbsp;                    this.signatureVisitor.visitEnd();
&nbsp;                    return this.signatureVisitor;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                private void onOwnableType(Generic ownableType) {</b>
&nbsp;                    Generic ownerType = ownableType.getOwnerType();
&nbsp;                    if (ownerType != null &amp;&amp; ownerType.getSort().isParameterized()) {
&nbsp;                        this.onOwnableType(ownerType);
&nbsp;                        this.signatureVisitor.visitInnerClassType(ownableType.asErasure().getSimpleName());
&nbsp;                    } else {
&nbsp;                        this.signatureVisitor.visitClassType(ownableType.asErasure().getInternalName());
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    for(Generic typeArgument : ownableType.getTypeArguments()) {</b>
&nbsp;                        typeArgument.accept(new OfTypeArgument(this.signatureVisitor));
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                public SignatureVisitor onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    this.signatureVisitor.visitTypeVariable(typeVariable.getSymbol());</b>
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
<b class="fc">&nbsp;                )</b>
&nbsp;                public SignatureVisitor onNonGenericType(Generic typeDescription) {
&nbsp;                    if (typeDescription.isArray()) {
&nbsp;                        typeDescription.getComponentType().accept(new ForSignatureVisitor(this.signatureVisitor.visitArrayType()));
&nbsp;                    } else if (typeDescription.isPrimitive()) {
&nbsp;                        this.signatureVisitor.visitBaseType(typeDescription.asErasure().getDescriptor().charAt(0));
&nbsp;                    } else {
<b class="nc">&nbsp;                        this.signatureVisitor.visitClassType(typeDescription.asErasure().getInternalName());</b>
&nbsp;                        this.signatureVisitor.visitEnd();
&nbsp;                    }
&nbsp;
&nbsp;                    return this.signatureVisitor;
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        return this.signatureVisitor.equals(((ForSignatureVisitor)var1).signatureVisitor);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.signatureVisitor.hashCode();
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                protected static class OfTypeArgument extends ForSignatureVisitor {</b>
&nbsp;                    protected OfTypeArgument(SignatureVisitor signatureVisitor) {
&nbsp;                        super(signatureVisitor);
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onWildcard(Generic wildcard) {
&nbsp;                        TypeList.Generic upperBounds = wildcard.getUpperBounds();
<b class="nc">&nbsp;                        TypeList.Generic lowerBounds = wildcard.getLowerBounds();</b>
<b class="nc">&nbsp;                        if (lowerBounds.isEmpty() &amp;&amp; ((Generic)upperBounds.getOnly()).represents(Object.class)) {</b>
<b class="nc">&nbsp;                            this.signatureVisitor.visitTypeArgument();</b>
&nbsp;                        } else if (!lowerBounds.isEmpty()) {
&nbsp;                            ((Generic)lowerBounds.getOnly()).accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;-&#39;)));
&nbsp;                        } else {
&nbsp;                            ((Generic)upperBounds.getOnly()).accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;+&#39;)));
&nbsp;                        }
&nbsp;
&nbsp;                        return this.signatureVisitor;
<b class="pc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="pc">&nbsp;                    public SignatureVisitor onGenericArray(Generic genericArray) {</b>
<b class="fc">&nbsp;                        genericArray.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));</b>
&nbsp;                        return this.signatureVisitor;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public SignatureVisitor onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                        parameterizedType.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));</b>
<b class="nc">&nbsp;                        return this.signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public SignatureVisitor onTypeVariable(Generic typeVariable) {
&nbsp;                        typeVariable.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    public SignatureVisitor onNonGenericType(Generic typeDescription) {</b>
&nbsp;                        typeDescription.accept(new ForSignatureVisitor(this.signatureVisitor.visitTypeArgument(&#39;=&#39;)));
&nbsp;                        return this.signatureVisitor;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class Substitutor implements Visitor&lt;Generic&gt; {
&nbsp;                public Substitutor() {
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();
&nbsp;                    List&lt;Generic&gt; typeArguments;
&nbsp;                    if (TypeDescription.AbstractBase.RAW_TYPES) {
&nbsp;                        typeArguments = Collections.emptyList();
&nbsp;                    } else {
&nbsp;                        typeArguments = new ArrayList(parameterizedType.getTypeArguments().size());
&nbsp;
&nbsp;                        for(Generic typeArgument : parameterizedType.getTypeArguments()) {
&nbsp;                            typeArguments.add(typeArgument.accept(this));
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return new OfParameterizedType.Latent(((Generic)parameterizedType.asRawType().accept(this)).asErasure(), ownerType == null ? TypeDescription.Generic.UNDEFINED : (Generic)ownerType.accept(this), typeArguments, parameterizedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return new OfGenericArray.Latent((Generic)genericArray.getComponentType().accept(this), genericArray);
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public Generic onWildcard(Generic wildcard) {</b>
&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard);
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
<b class="fc">&nbsp;                public Generic onNonGenericType(Generic typeDescription) {</b>
&nbsp;                    return (Generic)(typeDescription.isArray() ? new OfGenericArray.Latent((Generic)typeDescription.getComponentType().accept(this), typeDescription) : this.onSimpleType(typeDescription));
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Generic onSimpleType(Generic var1);
&nbsp;
&nbsp;                public abstract static class WithoutTypeSubstitution extends Substitutor {
<b class="fc">&nbsp;                    public WithoutTypeSubstitution() {</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {</b>
&nbsp;                        return typeDescription;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForAttachment extends Substitutor {
&nbsp;                    private final TypeDescription declaringType;
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    protected ForAttachment(TypeDefinition declaringType, TypeVariableSource typeVariableSource) {
&nbsp;                        this(declaringType.asErasure(), typeVariableSource);
&nbsp;                    }
&nbsp;
&nbsp;                    protected ForAttachment(TypeDescription declaringType, TypeVariableSource typeVariableSource) {
&nbsp;                        this.declaringType = declaringType;
&nbsp;                        this.typeVariableSource = typeVariableSource;
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(TypeDescription typeDescription) {
&nbsp;                        return new ForAttachment(typeDescription, typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    @SuppressFBWarnings(
&nbsp;                        value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
<b class="fc">&nbsp;                        justification = &quot;Assuming declaring type for type member.&quot;</b>
<b class="fc">&nbsp;                    )</b>
<b class="fc">&nbsp;                    public static ForAttachment of(FieldDescription fieldDescription) {</b>
&nbsp;                        return new ForAttachment(fieldDescription.getDeclaringType(), fieldDescription.getDeclaringType().asErasure());
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(MethodDescription methodDescription) {
&nbsp;                        return new ForAttachment(methodDescription.getDeclaringType(), methodDescription);
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public static ForAttachment of(ParameterDescription parameterDescription) {
&nbsp;                        return new ForAttachment(parameterDescription.getDeclaringMethod().getDeclaringType(), parameterDescription.getDeclaringMethod());
&nbsp;                    }
&nbsp;
&nbsp;                    public static ForAttachment of(RecordComponentDescription recordComponentDescription) {
&nbsp;                        return new ForAttachment(recordComponentDescription.getDeclaringType(), recordComponentDescription.getDeclaringType().asErasure());
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.WithAnnotationOverlay(this.typeVariableSource.findExpectedVariable(typeVariable.getSymbol()), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(typeDescription.represents(TargetType.class) ? new OfNonGenericType.Latent(this.declaringType, typeDescription) : typeDescription);
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else if (!this.declaringType.equals(((ForAttachment)var1).declaringType)) {
&nbsp;                            return false;
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            return this.typeVariableSource.equals(((ForAttachment)var1).typeVariableSource);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return (this.getClass().hashCode() * 31 + this.declaringType.hashCode()) * 31 + this.typeVariableSource.hashCode();
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForDetachment extends Substitutor {
&nbsp;                    private final ElementMatcher&lt;? super TypeDescription&gt; typeMatcher;
&nbsp;
&nbsp;                    public ForDetachment(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="nc">&nbsp;                        this.typeMatcher = typeMatcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public static Visitor&lt;Generic&gt; of(TypeDefinition typeDefinition) {
&nbsp;                        return new ForDetachment(ElementMatchers.is(typeDefinition));
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {</b>
&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(this.typeMatcher.matches(typeDescription.asErasure()) ? new OfNonGenericType.Latent(TargetType.DESCRIPTION, typeDescription.getOwnerType(), typeDescription) : typeDescription);
&nbsp;                    }
<b class="nc">&nbsp;</b>
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        } else {
&nbsp;                            return this.typeMatcher.equals(((ForDetachment)var1).typeMatcher);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
<b class="nc">&nbsp;                        return this.getClass().hashCode() * 31 + this.typeMatcher.hashCode();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForTypeVariableBinding extends WithoutTypeSubstitution {
&nbsp;                    private final Generic parameterizedType;
<b class="nc">&nbsp;</b>
&nbsp;                    protected ForTypeVariableBinding(Generic parameterizedType) {
&nbsp;                        this.parameterizedType = parameterizedType;
&nbsp;                    }
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return (Generic)typeVariable.getTypeVariableSource().accept(new TypeVariableSubstitutor(typeVariable));
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
<b class="nc">&nbsp;                        } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.parameterizedType.equals(((ForTypeVariableBinding)var1).parameterizedType);
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public int hashCode() {</b>
&nbsp;                        return this.getClass().hashCode() * 31 + this.parameterizedType.hashCode();
&nbsp;                    }
&nbsp;
&nbsp;                    @Enhance(
&nbsp;                        includeSyntheticFields = true
&nbsp;                    )
<b class="nc">&nbsp;                    protected class TypeVariableSubstitutor implements TypeVariableSource.Visitor&lt;Generic&gt; {</b>
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected TypeVariableSubstitutor(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public Generic onType(TypeDescription typeDescription) {</b>
&nbsp;                            Generic typeArgument = ForTypeVariableBinding.this.parameterizedType.findBindingOf(this.typeVariable);
&nbsp;                            return typeArgument == null ? this.typeVariable.asRawType() : typeArgument;
&nbsp;                        }
&nbsp;
&nbsp;                        public Generic onMethod(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                            return ForTypeVariableBinding.this.new RetainedMethodTypeVariable(this.typeVariable);
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
&nbsp;                                return false;
<b class="nc">&nbsp;                            } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                                return false;
&nbsp;                            } else if (!this.typeVariable.equals(((TypeVariableSubstitutor)var1).typeVariable)) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return ForTypeVariableBinding.this.equals(ForTypeVariableBinding.this);
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return (this.getClass().hashCode() * 31 + this.typeVariable.hashCode()) * 31 + ForTypeVariableBinding.this.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    protected class RetainedMethodTypeVariable extends OfTypeVariable {</b>
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        protected RetainedMethodTypeVariable(Generic typeVariable) {
&nbsp;                            this.typeVariable = typeVariable;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public TypeList.Generic getUpperBounds() {</b>
&nbsp;                            return this.typeVariable.getUpperBounds().accept(ForTypeVariableBinding.this);
&nbsp;                        }
&nbsp;
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
&nbsp;                            return this.typeVariable.getTypeVariableSource();
&nbsp;                        }
<b class="nc">&nbsp;</b>
&nbsp;                        public String getSymbol() {
&nbsp;                            return this.typeVariable.getSymbol();
&nbsp;                        }
&nbsp;
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
&nbsp;                            return this.typeVariable.getDeclaredAnnotations();
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class ForTokenNormalization extends Substitutor {
&nbsp;                    private final TypeDescription typeDescription;
<b class="fc">&nbsp;</b>
&nbsp;                    public ForTokenNormalization(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
&nbsp;                        return (Generic)(typeDescription.represents(TargetType.class) ? new OfNonGenericType.Latent(this.typeDescription, typeDescription) : typeDescription);
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;                        if (this == var1) {</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        } else if (var1 == null) {
<b class="nc">&nbsp;                            return false;</b>
<b class="nc">&nbsp;                        } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                            return false;
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            return this.typeDescription.equals(((ForTokenNormalization)var1).typeDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public int hashCode() {</b>
<b class="nc">&nbsp;                        return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                @Enhance</b>
<b class="nc">&nbsp;                public static class ForReplacement extends Substitutor {</b>
<b class="nc">&nbsp;                    private final TypeDescription typeDescription;</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public ForReplacement(TypeDescription typeDescription) {
&nbsp;                        this.typeDescription = typeDescription;
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {</b>
<b class="nc">&nbsp;                        return typeVariable;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="nc">&nbsp;                        return (Generic)(typeDescription.asErasure().equals(this.typeDescription) ? new OfNonGenericType.Latent(this.typeDescription, typeDescription) : typeDescription);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
<b class="nc">&nbsp;                        if (this == var1) {</b>
&nbsp;                            return true;
<b class="nc">&nbsp;                        } else if (var1 == null) {</b>
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.typeDescription.equals(((ForReplacement)var1).typeDescription);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.typeDescription.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static class ForRawType implements Visitor&lt;Generic&gt; {
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                public ForRawType(TypeDescription declaringType) {
&nbsp;                    this.declaringType = declaringType;
&nbsp;                }
&nbsp;
&nbsp;                public Generic onGenericArray(Generic genericArray) {
&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(genericArray.asErasure(), genericArray) : genericArray);
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                public Generic onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;Did not expect wildcard on top-level: &quot; + wildcard);
&nbsp;                }
&nbsp;
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(parameterizedType.asErasure(), parameterizedType) : parameterizedType);
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public Generic onTypeVariable(Generic typeVariable) {</b>
<b class="fc">&nbsp;                    return (Generic)(this.declaringType.isGenerified() ? new OfNonGenericType.Latent(typeVariable.asErasure(), typeVariable) : typeVariable);</b>
&nbsp;                }
&nbsp;
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
&nbsp;                    return typeDescription;
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            @Enhance
&nbsp;            public static class Reducing implements Visitor&lt;TypeDescription&gt; {
&nbsp;                private final TypeDescription declaringType;
&nbsp;                private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;                public Reducing(TypeDescription declaringType, TypeVariableToken... typeVariableToken) {
<b class="fc">&nbsp;                    this(declaringType, Arrays.asList(typeVariableToken));</b>
&nbsp;                }
&nbsp;
&nbsp;                public Reducing(TypeDescription declaringType, List&lt;? extends TypeVariableToken&gt; typeVariableTokens) {
&nbsp;                    this.declaringType = declaringType;
&nbsp;                    this.typeVariableTokens = typeVariableTokens;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Assuming component type for array type.&quot;
&nbsp;                )
&nbsp;                public TypeDescription onGenericArray(Generic genericArray) {
&nbsp;                    Generic targetType = genericArray;
<b class="nc">&nbsp;                    int arity = 0;</b>
&nbsp;
&nbsp;                    do {
&nbsp;                        targetType = targetType.getComponentType();
&nbsp;                        ++arity;
&nbsp;                    } while(targetType.isArray());
&nbsp;
&nbsp;                    if (targetType.getSort().isTypeVariable()) {
&nbsp;                        for(TypeVariableToken typeVariableToken : this.typeVariableTokens) {
&nbsp;                            if (targetType.getSymbol().equals(typeVariableToken.getSymbol())) {
&nbsp;                                return TypeDescription.ArrayProjection.of((TypeDescription)((Generic)typeVariableToken.getBounds().get(0)).accept(this), arity);
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        return TargetType.resolve(TypeDescription.ArrayProjection.of(this.declaringType.findExpectedVariable(targetType.getSymbol()).asErasure(), arity), this.declaringType);
&nbsp;                    } else {
&nbsp;                        return TargetType.resolve(genericArray.asErasure(), this.declaringType);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription onWildcard(Generic wildcard) {
&nbsp;                    throw new IllegalStateException(&quot;A wildcard cannot be a top-level type: &quot; + wildcard);
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeDescription onParameterizedType(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                    return TargetType.resolve(parameterizedType.asErasure(), this.declaringType);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeDescription onTypeVariable(Generic typeVariable) {
&nbsp;                    for(TypeVariableToken typeVariableToken : this.typeVariableTokens) {
&nbsp;                        if (typeVariable.getSymbol().equals(typeVariableToken.getSymbol())) {
&nbsp;                            return (TypeDescription)((Generic)typeVariableToken.getBounds().get(0)).accept(this);
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    return TargetType.resolve(this.declaringType.findExpectedVariable(typeVariable.getSymbol()).asErasure(), this.declaringType);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription onNonGenericType(Generic typeDescription) {
&nbsp;                    return TargetType.resolve(typeDescription.asErasure(), this.declaringType);
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.declaringType.equals(((Reducing)var1).declaringType)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.typeVariableTokens.equals(((Reducing)var1).typeVariableTokens);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.declaringType.hashCode()) * 31 + this.typeVariableTokens.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public abstract static class AbstractBase extends TypeVariableSource.AbstractBase implements TypeDescription {
&nbsp;        public static final boolean RAW_TYPES;
<b class="fc">&nbsp;        private static final boolean ACCESS_CONTROLLER;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public AbstractBase() {</b>
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        private static boolean isAssignable(TypeDescription sourceType, TypeDescription targetType) {
&nbsp;            if (sourceType.equals(targetType)) {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            } else if (targetType.isArray()) {
&nbsp;                return sourceType.isArray() ? isAssignable(sourceType.getComponentType(), targetType.getComponentType()) : sourceType.represents(Object.class) || ARRAY_INTERFACES.contains(sourceType.asGenericType());
&nbsp;            } else if (sourceType.represents(Object.class)) {
&nbsp;                return !targetType.isPrimitive();
&nbsp;            } else {
&nbsp;                Generic superClass = targetType.getSuperClass();
&nbsp;                if (superClass != null &amp;&amp; sourceType.isAssignableFrom(superClass.asErasure())) {
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    if (sourceType.isInterface()) {
&nbsp;                        for(TypeDescription interfaceType : targetType.getInterfaces().asErasures()) {
&nbsp;                            if (sourceType.isAssignableFrom(interfaceType)) {
&nbsp;                                return true;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
&nbsp;            return this.isAssignableFrom(TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
&nbsp;            return isAssignable(this, typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return this.isAssignableTo(TypeDescription.ForLoadedType.of(type));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {</b>
&nbsp;            return isAssignable(typeDescription, this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
&nbsp;            return this.isAssignableTo(type) || this.isAssignableFrom(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {
&nbsp;            return this.isAssignableTo(typeDescription) || this.isAssignableFrom(typeDescription);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public TypeDescription asErasure() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public Generic asGenericType() {
&nbsp;            return new Generic.OfNonGenericType.ForErasure(this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDefinition.Sort getSort() {
<b class="nc">&nbsp;            return Sort.NON_GENERIC;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInstance(Object value) {
&nbsp;            return this.isAssignableFrom(value.getClass());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnnotationValue(Object value) {
&nbsp;            if ((!this.represents(Class.class) || !(value instanceof TypeDescription)) &amp;&amp; (!(value instanceof AnnotationDescription) || !((AnnotationDescription)value).getAnnotationType().equals(this)) &amp;&amp; (!(value instanceof EnumerationDescription) || !((EnumerationDescription)value).getEnumerationType().equals(this)) &amp;&amp; (!this.represents(String.class) || !(value instanceof String)) &amp;&amp; (!this.represents(Boolean.TYPE) || !(value instanceof Boolean)) &amp;&amp; (!this.represents(Byte.TYPE) || !(value instanceof Byte)) &amp;&amp; (!this.represents(Short.TYPE) || !(value instanceof Short)) &amp;&amp; (!this.represents(Character.TYPE) || !(value instanceof Character)) &amp;&amp; (!this.represents(Integer.TYPE) || !(value instanceof Integer)) &amp;&amp; (!this.represents(Long.TYPE) || !(value instanceof Long)) &amp;&amp; (!this.represents(Float.TYPE) || !(value instanceof Float)) &amp;&amp; (!this.represents(Double.TYPE) || !(value instanceof Double)) &amp;&amp; (!this.represents(String[].class) || !(value instanceof String[])) &amp;&amp; (!this.represents(boolean[].class) || !(value instanceof boolean[])) &amp;&amp; (!this.represents(byte[].class) || !(value instanceof byte[])) &amp;&amp; (!this.represents(short[].class) || !(value instanceof short[])) &amp;&amp; (!this.represents(char[].class) || !(value instanceof char[])) &amp;&amp; (!this.represents(int[].class) || !(value instanceof int[])) &amp;&amp; (!this.represents(long[].class) || !(value instanceof long[])) &amp;&amp; (!this.represents(float[].class) || !(value instanceof float[])) &amp;&amp; (!this.represents(double[].class) || !(value instanceof double[])) &amp;&amp; (!this.represents(Class[].class) || !(value instanceof TypeDescription[]))) {
&nbsp;                if (this.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[]) {
&nbsp;                    for(AnnotationDescription annotationDescription : (AnnotationDescription[])value) {
<b class="nc">&nbsp;                        if (!annotationDescription.getAnnotationType().equals(this.getComponentType())) {</b>
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                } else if (this.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[]) {
<b class="fc">&nbsp;                    for(EnumerationDescription enumerationDescription : (EnumerationDescription[])value) {</b>
&nbsp;                        if (!enumerationDescription.getEnumerationType().equals(this.getComponentType())) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    return false;
&nbsp;                }
&nbsp;            } else {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public String getInternalName() {
&nbsp;            return this.getName().replace(&#39;.&#39;, &#39;/&#39;);
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean superFlag) {
&nbsp;            int actualModifiers = this.getModifiers() | (this.getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? 131072 : 0) | (this.isRecord() ? 65536 : 0) | (superFlag ? 32 : 0);
&nbsp;            if (this.isPrivate()) {
<b class="fc">&nbsp;                return actualModifiers &amp; -11;</b>
&nbsp;            } else {
&nbsp;                return this.isProtected() ? actualModifiers &amp; -13 | 1 : actualModifiers &amp; -9;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @MaybeNull</b>
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();
&nbsp;                boolean generic = false;
&nbsp;
&nbsp;                for(Generic typeVariable : this.getTypeVariables()) {
&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    for(Generic upperBound : typeVariable.getUpperBounds()) {</b>
&nbsp;                        upperBound.accept(new Generic.Visitor.ForSignatureVisitor(upperBound.asErasure().isInterface() ? signatureWriter.visitInterfaceBound() : signatureWriter.visitClassBound()));
&nbsp;                    }
&nbsp;
&nbsp;                    generic = true;
&nbsp;                }
&nbsp;
&nbsp;                Generic superClass = this.getSuperClass();
&nbsp;                if (superClass == null) {
<b class="nc">&nbsp;                    superClass = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;                }
&nbsp;
&nbsp;                superClass.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitSuperclass()));
&nbsp;                generic = generic || !superClass.getSort().isNonGeneric();
&nbsp;
&nbsp;                for(Generic interfaceType : this.getInterfaces()) {
<b class="nc">&nbsp;                    interfaceType.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitInterface()));</b>
&nbsp;                    generic = generic || !interfaceType.getSort().isNonGeneric();
&nbsp;                }
&nbsp;
&nbsp;                return generic ? signatureWriter.toString() : NON_GENERIC_SIGNATURE;
&nbsp;            } catch (GenericSignatureFormatError var7) {
&nbsp;                return NON_GENERIC_SIGNATURE;
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSamePackage(TypeDescription typeDescription) {
&nbsp;            PackageDescription thisPackage = this.getPackage();
&nbsp;            PackageDescription otherPackage = typeDescription.getPackage();
&nbsp;            return thisPackage != null &amp;&amp; otherPackage != null ? thisPackage.equals(otherPackage) : thisPackage == otherPackage;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
&nbsp;            boolean var10000;
<b class="nc">&nbsp;            if (!this.isPrimitive()) {</b>
&nbsp;                label36: {
<b class="nc">&nbsp;                    if (this.isArray()) {</b>
<b class="nc">&nbsp;                        if (this.getComponentType().isVisibleTo(typeDescription)) {</b>
<b class="nc">&nbsp;                            break label36;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } else if (this.isPublic() || this.isProtected() || this.isSamePackage(typeDescription)) {
&nbsp;                        break label36;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    var10000 = false;</b>
&nbsp;                    return var10000;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="nc">&nbsp;            boolean var10000;</b>
&nbsp;            if (!this.isPrimitive()) {
&nbsp;                label32: {
&nbsp;                    if (this.isArray()) {
&nbsp;                        if (this.getComponentType().isVisibleTo(typeDescription)) {
&nbsp;                            break label32;
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (this.isPublic() || this.isSamePackage(typeDescription)) {</b>
&nbsp;                        break label32;
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = false;
&nbsp;                    return var10000;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getInheritedAnnotations() {
<b class="nc">&nbsp;            Generic superClass = this.getSuperClass();</b>
&nbsp;            AnnotationList declaredAnnotations = this.getDeclaredAnnotations();
&nbsp;            if (superClass == null) {
&nbsp;                return declaredAnnotations;
&nbsp;            } else {
&nbsp;                Set&lt;TypeDescription&gt; annotationTypes = new HashSet();
&nbsp;
<b class="nc">&nbsp;                for(AnnotationDescription annotationDescription : declaredAnnotations) {</b>
&nbsp;                    annotationTypes.add(annotationDescription.getAnnotationType());
&nbsp;                }
&nbsp;
&nbsp;                return new AnnotationList.Explicit(CompoundList.of(declaredAnnotations, superClass.asErasure().getInheritedAnnotations().inherited(annotationTypes)));
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public String getActualName() {
&nbsp;            if (!this.isArray()) {
<b class="fc">&nbsp;                return this.getName();</b>
&nbsp;            } else {
&nbsp;                TypeDescription typeDescription = this;
&nbsp;                int dimensions = 0;
&nbsp;
&nbsp;                do {
&nbsp;                    ++dimensions;
<b class="nc">&nbsp;                    typeDescription = typeDescription.getComponentType();</b>
&nbsp;                } while(typeDescription.isArray());
&nbsp;
&nbsp;                StringBuilder stringBuilder = new StringBuilder();
&nbsp;                stringBuilder.append(typeDescription.getActualName());
&nbsp;
&nbsp;                for(int i = 0; i &lt; dimensions; ++i) {
<b class="nc">&nbsp;                    stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                return stringBuilder.toString();
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public String getLongSimpleName() {</b>
&nbsp;            TypeDescription declaringType = this.getDeclaringType();
&nbsp;            return declaringType == null ? this.getSimpleName() : declaringType.getLongSimpleName() + &quot;.&quot; + this.getSimpleName();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitiveWrapper() {
&nbsp;            return this.represents(Boolean.class) || this.represents(Byte.class) || this.represents(Short.class) || this.represents(Character.class) || this.represents(Integer.class) || this.represents(Long.class) || this.represents(Float.class) || this.represents(Double.class);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public boolean isAnnotationReturnType() {
<b class="fc">&nbsp;            return this.isPrimitive() || this.represents(String.class) || this.isAssignableTo(Enum.class) &amp;&amp; !this.represents(Enum.class) || this.isAssignableTo(Annotation.class) &amp;&amp; !this.represents(Annotation.class) || this.represents(Class.class) || this.isArray() &amp;&amp; !this.getComponentType().isArray() &amp;&amp; this.getComponentType().isAnnotationReturnType();</b>
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
<b class="fc">&nbsp;        public boolean isAnnotationValue() {</b>
&nbsp;            return this.isPrimitive() || this.represents(String.class) || this.isAssignableTo(TypeDescription.class) || this.isAssignableTo(AnnotationDescription.class) || this.isAssignableTo(EnumerationDescription.class) || this.isArray() &amp;&amp; !this.getComponentType().isArray() &amp;&amp; this.getComponentType().isAnnotationValue();
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;EC_UNRELATED_CLASS_AND_INTERFACE&quot;},
<b class="nc">&nbsp;            justification = &quot;Fits equality contract for type definitions.&quot;</b>
<b class="nc">&nbsp;        )</b>
<b class="nc">&nbsp;        public boolean represents(Type type) {</b>
&nbsp;            return this.equals(Sort.describe(type));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public String getTypeName() {</b>
<b class="nc">&nbsp;            return this.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeVariableSource getEnclosingSource() {
<b class="pc">&nbsp;            MethodDescription enclosingMethod = this.getEnclosingMethod();</b>
<b class="nc">&nbsp;            return (TypeVariableSource)(enclosingMethod == null ? (this.isStatic() ? TypeVariableSource.UNDEFINED : this.getEnclosingType()) : enclosingMethod);</b>
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public boolean isInferrable() {
<b class="fc">&nbsp;            return false;</b>
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return (T)visitor.onType(this);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isPackageType() {</b>
&nbsp;            return this.getSimpleName().equals(&quot;package-info&quot;);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isGenerified() {
<b class="nc">&nbsp;            if (!this.getTypeVariables().isEmpty()) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                if (!this.isStatic()) {</b>
<b class="nc">&nbsp;                    TypeDescription declaringType = this.getDeclaringType();</b>
<b class="nc">&nbsp;                    if (declaringType != null &amp;&amp; declaringType.isGenerified()) {</b>
<b class="nc">&nbsp;                        return true;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    MethodDescription.InDefinedShape enclosingMethod = this.getEnclosingMethod();</b>
&nbsp;                    return enclosingMethod != null &amp;&amp; enclosingMethod.isGenerified();
<b class="nc">&nbsp;                } catch (Throwable var2) {</b>
&nbsp;                    return false;
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int getInnerClassCount() {
&nbsp;            if (this.isStatic()) {
&nbsp;                return 0;
&nbsp;            } else {
&nbsp;                TypeDescription declaringType = this.getDeclaringType();
&nbsp;                return declaringType == null ? 0 : declaringType.getInnerClassCount() + 1;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInnerClass() {
&nbsp;            return !this.isStatic() &amp;&amp; this.isNestedClass();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestedClass() {
&nbsp;            return this.getDeclaringType() != null;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription asBoxed() {
&nbsp;            if (this.represents(Boolean.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Boolean.class);
&nbsp;            } else if (this.represents(Byte.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Byte.class);
&nbsp;            } else if (this.represents(Short.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Short.class);
&nbsp;            } else if (this.represents(Character.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Character.class);
&nbsp;            } else if (this.represents(Integer.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Integer.class);
&nbsp;            } else if (this.represents(Long.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Long.class);
&nbsp;            } else if (this.represents(Float.TYPE)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Float.class);
&nbsp;            } else {
&nbsp;                return (TypeDescription)(this.represents(Double.TYPE) ? TypeDescription.ForLoadedType.of(Double.class) : this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription asUnboxed() {
&nbsp;            if (this.represents(Boolean.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Boolean.TYPE);
&nbsp;            } else if (this.represents(Byte.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Byte.TYPE);
&nbsp;            } else if (this.represents(Short.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Short.TYPE);
&nbsp;            } else if (this.represents(Character.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Character.TYPE);
&nbsp;            } else if (this.represents(Integer.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Integer.TYPE);
&nbsp;            } else if (this.represents(Long.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Long.TYPE);
&nbsp;            } else if (this.represents(Float.class)) {
&nbsp;                return TypeDescription.ForLoadedType.of(Float.TYPE);
&nbsp;            } else {
&nbsp;                return (TypeDescription)(this.represents(Double.class) ? TypeDescription.ForLoadedType.of(Double.TYPE) : this);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public Object getDefaultValue() {
&nbsp;            if (this.represents(Boolean.TYPE)) {
&nbsp;                return false;
&nbsp;            } else if (this.represents(Byte.TYPE)) {
&nbsp;                return 0;
&nbsp;            } else if (this.represents(Short.TYPE)) {
&nbsp;                return Short.valueOf((short)0);
&nbsp;            } else if (this.represents(Character.TYPE)) {
&nbsp;                return &#39;\u0000&#39;;
&nbsp;            } else if (this.represents(Integer.TYPE)) {
&nbsp;                return 0;
&nbsp;            } else if (this.represents(Long.TYPE)) {
&nbsp;                return 0L;
&nbsp;            } else if (this.represents(Float.TYPE)) {
&nbsp;                return 0.0F;
&nbsp;            } else {
&nbsp;                return this.represents(Double.TYPE) ? (double)0.0F : null;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public boolean isNestHost() {</b>
&nbsp;            return this.equals(this.getNestHost());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
&nbsp;            return this.isNestMateOf(TypeDescription.ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this.getNestHost().equals(typeDescription.getNestHost());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isMemberType() {
&nbsp;            return !this.isLocalType() &amp;&amp; !this.isAnonymousType() &amp;&amp; this.getDeclaringType() != null;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isCompileTimeConstant() {
&nbsp;            return this.represents(Integer.TYPE) || this.represents(Long.TYPE) || this.represents(Float.TYPE) || this.represents(Double.TYPE) || this.represents(String.class) || this.represents(Class.class) || this.equals(JavaType.METHOD_TYPE.getTypeStub()) || this.equals(JavaType.METHOD_HANDLE.getTypeStub());
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return !this.isPrimitive() &amp;&amp; !this.isArray() &amp;&amp; !this.getPermittedSubtypes().isEmpty();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public ClassFileVersion getClassFileVersion() {
<b class="fc">&nbsp;            return null;</b>
<b class="pc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Iterator&lt;TypeDefinition&gt; iterator() {</b>
&nbsp;            return new TypeDefinition.SuperClassIterator(this);
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
<b class="fc">&nbsp;            int var2 = var1 != 0 ? 0 : this.getName().hashCode();</b>
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return var2;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof TypeDefinition)) {
<b class="pc">&nbsp;                return false;</b>
&nbsp;            } else {
&nbsp;                TypeDefinition typeDefinition = (TypeDefinition)other;
&nbsp;                return typeDefinition.getSort().isNonGeneric() &amp;&amp; this.getName().equals(typeDefinition.asErasure().getName());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return (this.isPrimitive() ? &quot;&quot; : (this.isInterface() ? &quot;interface&quot; : &quot;class&quot;) + &quot; &quot;) + this.getName();
&nbsp;        }
&nbsp;
&nbsp;        protected String toSafeString() {
&nbsp;            return this.toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var3) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var4) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            boolean rawTypes;</b>
<b class="fc">&nbsp;            try {</b>
&nbsp;                rawTypes = Boolean.parseBoolean((String)doPrivileged(new GetSystemPropertyAction(&quot;net.bytebuddy.raw&quot;)));
&nbsp;            } catch (Exception var2) {
&nbsp;                rawTypes = false;
&nbsp;            }
&nbsp;
&nbsp;            RAW_TYPES = rawTypes;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public abstract static class OfSimpleType extends AbstractBase {
&nbsp;            public OfSimpleType() {
&nbsp;            }
&nbsp;
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            public boolean isArray() {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public TypeDescription getComponentType() {
&nbsp;                return TypeDescription.UNDEFINED;
&nbsp;            }
&nbsp;
&nbsp;            public String getDescriptor() {
&nbsp;                return &quot;L&quot; + this.getInternalName() + &quot;;&quot;;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            public String getCanonicalName() {
&nbsp;                if (!this.isAnonymousType() &amp;&amp; !this.isLocalType()) {
&nbsp;                    String internalName = this.getInternalName();
&nbsp;                    TypeDescription enclosingType = this.getEnclosingType();
&nbsp;                    return enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;) ? enclosingType.getCanonicalName() + &quot;.&quot; + internalName.substring(enclosingType.getInternalName().length() + 1) : this.getName();
&nbsp;                } else {
&nbsp;                    return NO_NAME;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public String getSimpleName() {
&nbsp;                String internalName = this.getInternalName();
&nbsp;                TypeDescription enclosingType = this.getEnclosingType();
&nbsp;                int simpleNameIndex;
&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {
&nbsp;                    simpleNameIndex = enclosingType.getInternalName().length() + 1;
&nbsp;                } else {
&nbsp;                    simpleNameIndex = internalName.lastIndexOf(47);
&nbsp;                    if (simpleNameIndex == -1) {
&nbsp;                        return internalName;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                while(simpleNameIndex &lt; internalName.length() &amp;&amp; !Character.isJavaIdentifierStart(internalName.charAt(simpleNameIndex))) {
&nbsp;                    ++simpleNameIndex;
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                return internalName.substring(simpleNameIndex);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public StackSize getStackSize() {
&nbsp;                return StackSize.SINGLE;
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class WithDelegation extends OfSimpleType {
&nbsp;                public WithDelegation() {
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                protected abstract TypeDescription delegate();
&nbsp;
&nbsp;                public Generic getSuperClass() {
&nbsp;                    return this.delegate().getSuperClass();
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                public TypeList.Generic getInterfaces() {</b>
&nbsp;                    return this.delegate().getInterfaces();
&nbsp;                }
&nbsp;
&nbsp;                public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;                    return this.delegate().getDeclaredFields();
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;                    return this.delegate().getDeclaredMethods();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return this.delegate().getDeclaringType();</b>
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;                    return this.delegate().getEnclosingMethod();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public TypeDescription getEnclosingType() {
&nbsp;                    return this.delegate().getEnclosingType();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList getDeclaredTypes() {
&nbsp;                    return this.delegate().getDeclaredTypes();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAnonymousType() {
&nbsp;                    return this.delegate().isAnonymousType();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isLocalType() {
&nbsp;                    return this.delegate().isLocalType();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public PackageDescription getPackage() {
&nbsp;                    return this.delegate().getPackage();
&nbsp;                }
&nbsp;
&nbsp;                public AnnotationList getDeclaredAnnotations() {
&nbsp;                    return this.delegate().getDeclaredAnnotations();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList.Generic getTypeVariables() {
&nbsp;                    return this.delegate().getTypeVariables();
&nbsp;                }
&nbsp;
&nbsp;                public int getModifiers() {
&nbsp;                    return this.delegate().getModifiers();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public String getGenericSignature() {
&nbsp;                    return this.delegate().getGenericSignature();
&nbsp;                }
&nbsp;
&nbsp;                public int getActualModifiers(boolean superFlag) {
&nbsp;                    return this.delegate().getActualModifiers(superFlag);
&nbsp;                }
&nbsp;
&nbsp;                public TypeDescription getNestHost() {
&nbsp;                    return this.delegate().getNestHost();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList getNestMembers() {
&nbsp;                    return this.delegate().getNestMembers();
&nbsp;                }
&nbsp;
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;                    return this.delegate().getRecordComponents();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isRecord() {
&nbsp;                    return this.delegate().isRecord();
&nbsp;                }
&nbsp;
&nbsp;                public boolean isSealed() {
&nbsp;                    return this.delegate().isSealed();
&nbsp;                }
&nbsp;
&nbsp;                public TypeList getPermittedSubtypes() {
&nbsp;                    return this.delegate().getPermittedSubtypes();
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public ClassFileVersion getClassFileVersion() {
&nbsp;                    return this.delegate().getClassFileVersion();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class LazyProxy implements InvocationHandler {
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;        protected LazyProxy(Class&lt;?&gt; type) {
&nbsp;            this.type = type;
&nbsp;        }
&nbsp;
&nbsp;        protected static TypeDescription of(Class&lt;?&gt; type) {
&nbsp;            return (TypeDescription)Proxy.newProxyInstance(TypeDescription.class.getClassLoader(), new Class[]{TypeDescription.class}, new LazyProxy(type));
&nbsp;        }
&nbsp;
&nbsp;        public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) throws Throwable {
&nbsp;            try {
&nbsp;                return method.invoke(TypeDescription.ForLoadedType.of(this.type), argument);
&nbsp;            } catch (InvocationTargetException exception) {
&nbsp;                throw exception.getTargetException();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (var1 == null) {</b>
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.type.equals(((LazyProxy)var1).type);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
<b class="pc">&nbsp;            return this.getClass().hashCode() * 31 + this.type.hashCode();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;SE_TRANSIENT_FIELD_NOT_RESTORED&quot;},
&nbsp;        justification = &quot;Field is only used as a cache store and is implicitly recomputed&quot;
&nbsp;    )
&nbsp;    public static class ForLoadedType extends AbstractBase implements Serializable {
<b class="nc">&nbsp;        private static final long serialVersionUID = 1L;</b>
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;        private static final Map&lt;Class&lt;?&gt;, TypeDescription&gt; TYPE_CACHE;
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public ForLoadedType(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public static String getName(Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;            String name = type.getName();</b>
&nbsp;            int anonymousLoaderIndex = name.indexOf(47);
<b class="nc">&nbsp;            return anonymousLoaderIndex == -1 ? name : name.substring(0, anonymousLoaderIndex);</b>
&nbsp;        }
&nbsp;
&nbsp;        public static TypeDescription of(Class&lt;?&gt; type) {
&nbsp;            TypeDescription typeDescription = (TypeDescription)TYPE_CACHE.get(type);
&nbsp;            return (TypeDescription)(typeDescription == null ? new ForLoadedType(type) : typeDescription);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
&nbsp;            return this.type.isAssignableFrom(type) || super.isAssignableFrom(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; this.type.isAssignableFrom(((ForLoadedType)typeDescription).type) || super.isAssignableFrom(typeDescription);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
&nbsp;            return type.isAssignableFrom(this.type) || super.isAssignableTo(type);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; ((ForLoadedType)typeDescription).type.isAssignableFrom(this.type) || super.isAssignableTo(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
&nbsp;            return type.isAssignableFrom(this.type) || this.type.isAssignableFrom(type) || super.isInHierarchyWith(type);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {</b>
<b class="pc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; (((ForLoadedType)typeDescription).type.isAssignableFrom(this.type) || this.type.isAssignableFrom(((ForLoadedType)typeDescription).type)) || super.isInHierarchyWith(typeDescription);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public boolean represents(Type type) {
&nbsp;            return type == this.type || super.represents(type);
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            Class&lt;?&gt; componentType = this.type.getComponentType();
<b class="nc">&nbsp;            return componentType == null ? TypeDescription.UNDEFINED : of(componentType);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isArray() {
&nbsp;            return this.type.isArray();
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public boolean isPrimitive() {</b>
&nbsp;            return this.type.isPrimitive();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnnotation() {
&nbsp;            return this.type.isAnnotation();
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
&nbsp;            if (RAW_TYPES) {
&nbsp;                return this.type.getSuperclass() == null ? TypeDescription.Generic.UNDEFINED : TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.type.getSuperclass());
&nbsp;            } else {
&nbsp;                return TypeDescription.Generic.LazyProjection.ForLoadedSuperClass.of(this.type);
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            if (RAW_TYPES) {
&nbsp;                return (TypeList.Generic)(this.isArray() ? ARRAY_INTERFACES : new TypeList.Generic.ForLoadedTypes(this.type.getInterfaces()));
&nbsp;            } else {
<b class="nc">&nbsp;                return (TypeList.Generic)(this.isArray() ? ARRAY_INTERFACES : new TypeList.Generic.OfLoadedInterfaceTypes(this.type));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            Class&lt;?&gt; declaringType = this.type.getDeclaringClass();
<b class="nc">&nbsp;            return declaringType == null ? TypeDescription.UNDEFINED : of(declaringType);</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            Method enclosingMethod = this.type.getEnclosingMethod();
&nbsp;            Constructor&lt;?&gt; enclosingConstructor = this.type.getEnclosingConstructor();
<b class="nc">&nbsp;            if (enclosingMethod != null) {</b>
&nbsp;                return new MethodDescription.ForLoadedMethod(enclosingMethod);
&nbsp;            } else {
&nbsp;                return (MethodDescription.InDefinedShape)(enclosingConstructor != null ? new MethodDescription.ForLoadedConstructor(enclosingConstructor) : MethodDescription.UNDEFINED);
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TypeDescription getEnclosingType() {</b>
&nbsp;            Class&lt;?&gt; enclosingType = this.type.getEnclosingClass();
&nbsp;            return enclosingType == null ? TypeDescription.UNDEFINED : of(enclosingType);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.ForLoadedTypes(this.type.getDeclaredClasses());
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            String simpleName = this.type.getSimpleName();
&nbsp;            int anonymousLoaderIndex = simpleName.indexOf(47);
&nbsp;            if (anonymousLoaderIndex == -1) {
&nbsp;                return simpleName;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                StringBuilder normalized = new StringBuilder(simpleName.substring(0, anonymousLoaderIndex));
&nbsp;
&nbsp;                for(Class&lt;?&gt; type = this.type; type.isArray(); type = type.getComponentType()) {
&nbsp;                    normalized.append(&quot;[]&quot;);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return normalized.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return this.type.isAnonymousClass();
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isLocalType() {
&nbsp;            return this.type.isLocalClass();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMemberType() {
&nbsp;            return this.type.isMemberClass();
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;declaredFields&quot;)
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            FieldList var1 = this.declaredFields;
&nbsp;            Object var2 = var1 != null ? null : new FieldList.ForLoadedFields((Field[])GraalImageCode.getCurrent().sorted(this.type.getDeclaredFields(), FieldComparator.INSTANCE));
&nbsp;            if (var2 == null) {
<b class="nc">&nbsp;                var2 = this.declaredFields;</b>
&nbsp;            } else {
&nbsp;                this.declaredFields = (FieldList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (FieldList&lt;FieldDescription.InDefinedShape&gt;)var2;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;declaredMethods&quot;)
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            MethodList var1 = this.declaredMethods;
&nbsp;            Object var2 = var1 != null ? null : new MethodList.ForLoadedMethods(this.type);
&nbsp;            if (var2 == null) {
&nbsp;                var2 = this.declaredMethods;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                this.declaredMethods = (MethodList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (MethodList&lt;MethodDescription.InDefinedShape&gt;)var2;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        @MaybeNull</b>
&nbsp;        public PackageDescription getPackage() {
&nbsp;            if (!this.type.isArray() &amp;&amp; !this.type.isPrimitive()) {
&nbsp;                Package aPackage = this.type.getPackage();
&nbsp;                if (aPackage == null) {
&nbsp;                    String name = this.type.getName();
&nbsp;                    int index = name.lastIndexOf(46);
<b class="nc">&nbsp;                    return (PackageDescription)(index == -1 ? PackageDescription.DEFAULT : new PackageDescription.Simple(name.substring(0, index)));</b>
&nbsp;                } else {
&nbsp;                    return new PackageDescription.ForLoadedPackage(aPackage);
&nbsp;                }
&nbsp;            } else {
&nbsp;                return PackageDescription.UNDEFINED;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public StackSize getStackSize() {
&nbsp;            return StackSize.of(this.type);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public String getName() {</b>
&nbsp;            return getName(this.type);
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
<b class="nc">&nbsp;        public String getCanonicalName() {</b>
<b class="nc">&nbsp;            String canonicalName = this.type.getCanonicalName();</b>
<b class="nc">&nbsp;            if (canonicalName == null) {</b>
<b class="nc">&nbsp;                return NO_NAME;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                int anonymousLoaderIndex = canonicalName.indexOf(47);</b>
<b class="nc">&nbsp;                if (anonymousLoaderIndex == -1) {</b>
<b class="nc">&nbsp;                    return canonicalName;</b>
<b class="nc">&nbsp;                } else {</b>
&nbsp;                    StringBuilder normalized = new StringBuilder(canonicalName.substring(0, anonymousLoaderIndex));
&nbsp;
&nbsp;                    for(Class&lt;?&gt; type = this.type; type.isArray(); type = type.getComponentType()) {
&nbsp;                        normalized.append(&quot;[]&quot;);
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    return normalized.toString();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            String name = this.type.getName();
&nbsp;            int anonymousLoaderIndex = name.indexOf(47);
&nbsp;            return anonymousLoaderIndex == -1 ? net.bytebuddy.jar.asm.Type.getDescriptor(this.type) : &quot;L&quot; + name.substring(0, anonymousLoaderIndex).replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.type.getModifiers();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return (TypeList.Generic)(RAW_TYPES ? new TypeList.Generic.Empty() : OfTypeVariables.of(this.type));
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            AnnotationList var1 = this.declaredAnnotations;
<b class="fc">&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(this.type.getDeclaredAnnotations());</b>
<b class="fc">&nbsp;            if (var2 == null) {</b>
<b class="fc">&nbsp;                var2 = this.declaredAnnotations;</b>
&nbsp;            } else {
&nbsp;                this.declaredAnnotations = (AnnotationList)var2;
&nbsp;            }
&nbsp;
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public Generic asGenericType() {
&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(this.type);
<b class="fc">&nbsp;            return (TypeDescription)(host == null ? this : of(host));</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            Class&lt;?&gt;[] member = DISPATCHER.getNestMembers(this.type);
&nbsp;            return new TypeList.ForLoadedTypes(member.length == 0 ? new Class[]{this.type} : member);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isNestHost() {
&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(this.type);
&nbsp;            return host == null || host == this.type;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return DISPATCHER.isNestmateOf(this.type, type) || super.isNestMateOf(of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; DISPATCHER.isNestmateOf(this.type, ((ForLoadedType)typeDescription).type) || super.isNestMateOf(typeDescription);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {</b>
&nbsp;            Object[] recordComponent = DISPATCHER.getRecordComponents(this.type);
&nbsp;            return (RecordComponentList)(recordComponent == null ? new RecordComponentList.Empty() : new RecordComponentList.ForLoadedRecordComponents(recordComponent));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return DISPATCHER.isRecord(this.type);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return DISPATCHER.isSealed(this.type);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            Class&lt;?&gt;[] permittedSubclass = DISPATCHER.getPermittedSubclasses(this.type);
<b class="nc">&nbsp;            return (TypeList)(permittedSubclass == null ? new TypeList.Empty() : new TypeList.ForLoadedTypes(permittedSubclass));</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;classFileVersion&quot;)
&nbsp;        public ClassFileVersion getClassFileVersion() {
&nbsp;            ClassFileVersion var1 = this.classFileVersion;
<b class="nc">&nbsp;            ClassFileVersion var10000;</b>
&nbsp;            if (var1 != null) {
&nbsp;                var10000 = null;
&nbsp;            } else {
&nbsp;                ForLoadedType var2 = this;
&nbsp;
&nbsp;                try {
<b class="nc">&nbsp;                    var10000 = ClassFileVersion.of(var2.type);</b>
&nbsp;                } catch (Throwable var5) {
&nbsp;                    var10000 = null;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            ClassFileVersion var6 = var10000;
<b class="nc">&nbsp;            if (var6 == null) {</b>
&nbsp;                var6 = this.classFileVersion;
&nbsp;            } else {
&nbsp;                this.classFileVersion = var6;
&nbsp;            }
&nbsp;
&nbsp;            return var6;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
<b class="nc">&nbsp;                ACCESS_CONTROLLER = false;</b>
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;            TYPE_CACHE = new HashMap();
<b class="nc">&nbsp;            TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));</b>
&nbsp;            TYPE_CACHE.put(Class.class, new ForLoadedType(Class.class));
&nbsp;            TYPE_CACHE.put(Throwable.class, new ForLoadedType(Throwable.class));
&nbsp;            TYPE_CACHE.put(Annotation.class, new ForLoadedType(Annotation.class));
&nbsp;            TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));
&nbsp;            TYPE_CACHE.put(String.class, new ForLoadedType(String.class));
&nbsp;            TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));
<b class="nc">&nbsp;            TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));</b>
&nbsp;            TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));
&nbsp;            TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));
&nbsp;            TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));
&nbsp;            TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));
&nbsp;            TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));
&nbsp;            TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));
<b class="nc">&nbsp;            TYPE_CACHE.put(Void.TYPE, new ForLoadedType(Void.TYPE));</b>
&nbsp;            TYPE_CACHE.put(Boolean.TYPE, new ForLoadedType(Boolean.TYPE));
&nbsp;            TYPE_CACHE.put(Byte.TYPE, new ForLoadedType(Byte.TYPE));
&nbsp;            TYPE_CACHE.put(Short.TYPE, new ForLoadedType(Short.TYPE));
&nbsp;            TYPE_CACHE.put(Character.TYPE, new ForLoadedType(Character.TYPE));
&nbsp;            TYPE_CACHE.put(Integer.TYPE, new ForLoadedType(Integer.TYPE));
&nbsp;            TYPE_CACHE.put(Long.TYPE, new ForLoadedType(Long.TYPE));
<b class="nc">&nbsp;            TYPE_CACHE.put(Float.TYPE, new ForLoadedType(Float.TYPE));</b>
&nbsp;            TYPE_CACHE.put(Double.TYPE, new ForLoadedType(Double.TYPE));
&nbsp;        }
&nbsp;
&nbsp;        @Defaults
&nbsp;        @Proxied(&quot;java.lang.Class&quot;)
&nbsp;        protected interface Dispatcher {
<b class="nc">&nbsp;            @MaybeNull</b>
&nbsp;            @Proxied(&quot;getAnnotatedSuperclass&quot;)
&nbsp;            AnnotatedElement getAnnotatedSuperclass(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;getAnnotatedInterfaces&quot;)
&nbsp;            AnnotatedElement[] getAnnotatedInterfaces(Class&lt;?&gt; var1);
&nbsp;
<b class="nc">&nbsp;            @MaybeNull</b>
&nbsp;            @Proxied(&quot;getNestHost&quot;)
&nbsp;            Class&lt;?&gt; getNestHost(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;getNestMembers&quot;)
&nbsp;            Class&lt;?&gt;[] getNestMembers(Class&lt;?&gt; var1);
&nbsp;
<b class="fc">&nbsp;            @Proxied(&quot;isNestmateOf&quot;)</b>
&nbsp;            boolean isNestmateOf(Class&lt;?&gt; var1, Class&lt;?&gt; var2);
&nbsp;
&nbsp;            @Proxied(&quot;isSealed&quot;)
&nbsp;            boolean isSealed(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @MaybeNull
<b class="nc">&nbsp;            @Proxied(&quot;getPermittedSubclasses&quot;)</b>
&nbsp;            Class&lt;?&gt;[] getPermittedSubclasses(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @Proxied(&quot;isRecord&quot;)
&nbsp;            boolean isRecord(Class&lt;?&gt; var1);
&nbsp;
&nbsp;            @MaybeNull
<b class="nc">&nbsp;            @Proxied(&quot;getRecordComponents&quot;)</b>
&nbsp;            Object[] getRecordComponents(Class&lt;?&gt; var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class ArrayProjection extends AbstractBase {
&nbsp;        private static final int ARRAY_IMPLIED = 1040;
<b class="nc">&nbsp;        private static final int ARRAY_EXCLUDED = 8712;</b>
&nbsp;        private final TypeDescription componentType;
&nbsp;        private final int arity;
&nbsp;
&nbsp;        protected ArrayProjection(TypeDescription componentType, int arity) {
&nbsp;            this.componentType = componentType;
&nbsp;            this.arity = arity;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static TypeDescription of(TypeDescription componentType) {
&nbsp;            return of(componentType, 1);
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
<b class="nc">&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},</b>
<b class="nc">&nbsp;            justification = &quot;Assuming component type for array type.&quot;</b>
&nbsp;        )
<b class="nc">&nbsp;        public static TypeDescription of(TypeDescription componentType, int arity) {</b>
&nbsp;            if (arity &lt; 0) {
&nbsp;                throw new IllegalArgumentException(&quot;Arrays cannot have a negative arity&quot;);
&nbsp;            } else {
&nbsp;                while(componentType.isArray()) {
&nbsp;                    componentType = componentType.getComponentType();
&nbsp;                    ++arity;
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                return (TypeDescription)(arity == 0 ? componentType : new ArrayProjection(componentType, arity));
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public boolean isArray() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        @MaybeNull</b>
<b class="nc">&nbsp;        public TypeDescription getComponentType() {</b>
<b class="nc">&nbsp;            return (TypeDescription)(this.arity == 1 ? this.componentType : new ArrayProjection(this.componentType, this.arity - 1));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public boolean isPrimitive() {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="nc">&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return ARRAY_INTERFACES;
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return MethodDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder(this.componentType.getSimpleName());
&nbsp;
&nbsp;            for(int i = 0; i &lt; this.arity; ++i) {
<b class="nc">&nbsp;                stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public String getCanonicalName() {
&nbsp;            String canonicalName = this.componentType.getCanonicalName();
<b class="fc">&nbsp;            if (canonicalName == null) {</b>
<b class="fc">&nbsp;                return NO_NAME;</b>
<b class="fc">&nbsp;            } else {</b>
&nbsp;                StringBuilder stringBuilder = new StringBuilder(canonicalName);
&nbsp;
&nbsp;                for(int i = 0; i &lt; this.arity; ++i) {
&nbsp;                    stringBuilder.append(&quot;[]&quot;);
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return stringBuilder.toString();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isAnonymousType() {</b>
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public boolean isLocalType() {</b>
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMemberType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {</b>
&nbsp;            return new FieldList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return new MethodList.Empty();
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public StackSize getStackSize() {
&nbsp;            return StackSize.SINGLE;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return new AnnotationList.Empty();
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public AnnotationList getInheritedAnnotations() {
&nbsp;            return new AnnotationList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
<b class="nc">&nbsp;        public PackageDescription getPackage() {</b>
&nbsp;            return PackageDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            String descriptor = this.componentType.getDescriptor();
&nbsp;            StringBuilder stringBuilder = new StringBuilder(descriptor.length() + this.arity);
&nbsp;
&nbsp;            for(int index = 0; index &lt; this.arity; ++index) {
&nbsp;                stringBuilder.append(&#39;[&#39;);
&nbsp;            }
&nbsp;
&nbsp;            for(int index = 0; index &lt; descriptor.length(); ++index) {
&nbsp;                char character = descriptor.charAt(index);
&nbsp;                stringBuilder.append(character == &#39;/&#39; ? &#39;.&#39; : character);
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder();
&nbsp;
&nbsp;            for(int i = 0; i &lt; this.arity; ++i) {
<b class="fc">&nbsp;                stringBuilder.append(&#39;[&#39;);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            return stringBuilder.append(this.componentType.getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        @AlwaysNull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return TypeDescription.UNDEFINED;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return this.getComponentType().getModifiers() &amp; -8713 | 1040;</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return new TypeList.Explicit(new TypeDescription[]{this});
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return new RecordComponentList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static class Latent extends AbstractBase.OfSimpleType {</b>
&nbsp;        private final String name;
&nbsp;        private final int modifiers;
&nbsp;        @MaybeNull
&nbsp;        private final Generic superClass;
&nbsp;        private final List&lt;? extends Generic&gt; interfaces;
&nbsp;
<b class="fc">&nbsp;        public Latent(String name, int modifiers, @MaybeNull Generic superClass, Generic... anInterface) {</b>
&nbsp;            this(name, modifiers, superClass, Arrays.asList(anInterface));
&nbsp;        }
&nbsp;
&nbsp;        public Latent(String name, int modifiers, @MaybeNull Generic superClass, List&lt;? extends Generic&gt; interfaces) {
&nbsp;            this.name = name;
&nbsp;            this.modifiers = modifiers;
<b class="fc">&nbsp;            this.superClass = superClass;</b>
&nbsp;            this.interfaces = interfaces;
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
&nbsp;            return this.superClass;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new TypeList.Generic.Explicit(this.interfaces);
&nbsp;        }
&nbsp;
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing method of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve inner types of a latent type description: &quot; + this);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isAnonymousType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve anonymous type property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve local class property of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared fields of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {</b>
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared methods of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
&nbsp;            String name = this.getName();
<b class="nc">&nbsp;            int index = name.lastIndexOf(46);</b>
&nbsp;            return (PackageDescription)(index == -1 ? PackageDescription.DEFAULT : new PackageDescription.Simple(name.substring(0, index)));
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared annotations of a latent type description: &quot; + this);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared type of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.modifiers;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve type variables of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest host of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TypeList getNestMembers() {</b>
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest mates of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record components of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public boolean isRecord() {</b>
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record attribute of a latent type description: &quot; + this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            throw new IllegalStateException(&quot;Cannot resolve permitted subclasses of a latent type description: &quot; + this);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static class ForPackageDescription extends AbstractBase.OfSimpleType {
&nbsp;        private final PackageDescription packageDescription;
&nbsp;
&nbsp;        public ForPackageDescription(PackageDescription packageDescription) {
&nbsp;            this.packageDescription = packageDescription;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return MethodDescription.UNDEFINED;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        @MaybeNull</b>
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return TypeDescription.UNDEFINED;
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return false;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
<b class="nc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return new FieldList.Empty();
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {</b>
&nbsp;            return new MethodList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return this.packageDescription;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return this.packageDescription.getDeclaredAnnotations();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return new TypeList.Generic.Empty();
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public int getModifiers() {</b>
&nbsp;            return 5632;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.packageDescription.getName() + &quot;.&quot; + &quot;package-info&quot;;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return new TypeList.Explicit(new TypeDescription[]{this});
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return new RecordComponentList.Empty();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return new TypeList.Empty();
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static class SuperTypeLoading extends AbstractBase {
&nbsp;        private final TypeDescription delegate;
&nbsp;        @MaybeNull
<b class="pc">&nbsp;        private final ClassLoader classLoader;</b>
&nbsp;        private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;        public SuperTypeLoading(TypeDescription delegate, @MaybeNull ClassLoader classLoader) {
&nbsp;            this(delegate, classLoader, TypeDescription.SuperTypeLoading.ClassLoadingDelegate.Simple.INSTANCE);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public SuperTypeLoading(TypeDescription delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;            this.delegate = delegate;
&nbsp;            this.classLoader = classLoader;
&nbsp;            this.classLoadingDelegate = classLoadingDelegate;
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return this.delegate.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.delegate.getModifiers();
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TypeList.Generic getTypeVariables() {</b>
&nbsp;            return this.delegate.getTypeVariables();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return this.delegate.getDescriptor();
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public String getName() {
&nbsp;            return this.delegate.getName();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="nc">&nbsp;            Generic superClass = this.delegate.getSuperClass();</b>
&nbsp;            return (Generic)(superClass == null ? TypeDescription.Generic.UNDEFINED : new ClassLoadingTypeProjection(superClass, this.classLoader, this.classLoadingDelegate));
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getInterfaces() {
&nbsp;            return new ClassLoadingTypeList(this.delegate.getInterfaces(), this.classLoader, this.classLoadingDelegate);
&nbsp;        }
&nbsp;
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
&nbsp;            return this.delegate.getDeclaredFields();
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
&nbsp;            return this.delegate.getDeclaredMethods();
&nbsp;        }
&nbsp;
&nbsp;        public StackSize getStackSize() {
&nbsp;            return this.delegate.getStackSize();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isArray() {
&nbsp;            return this.delegate.isArray();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isPrimitive() {
&nbsp;            return this.delegate.isPrimitive();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getComponentType() {
&nbsp;            return this.delegate.getComponentType();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return this.delegate.getDeclaringType();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getDeclaredTypes() {
&nbsp;            return this.delegate.getDeclaredTypes();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
&nbsp;            return this.delegate.getEnclosingMethod();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getEnclosingType() {
&nbsp;            return this.delegate.getEnclosingType();
&nbsp;        }
&nbsp;
&nbsp;        public String getSimpleName() {
&nbsp;            return this.delegate.getSimpleName();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public String getCanonicalName() {
&nbsp;            return this.delegate.getCanonicalName();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAnonymousType() {
&nbsp;            return this.delegate.isAnonymousType();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isLocalType() {
&nbsp;            return this.delegate.isLocalType();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
&nbsp;            return this.delegate.getPackage();
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getNestHost() {
&nbsp;            return this.delegate.getNestHost();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getNestMembers() {
&nbsp;            return this.delegate.getNestMembers();
&nbsp;        }
&nbsp;
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
&nbsp;            return this.delegate.getRecordComponents();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isRecord() {
&nbsp;            return this.delegate.isRecord();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSealed() {
&nbsp;            return this.delegate.isSealed();
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getPermittedSubtypes() {
&nbsp;            return this.delegate.getPermittedSubtypes();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public ClassFileVersion getClassFileVersion() {
&nbsp;            return this.delegate.getClassFileVersion();
&nbsp;        }
&nbsp;
&nbsp;        protected static class ClassLoadingTypeProjection extends Generic.LazyProjection {
&nbsp;            private final Generic delegate;
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            protected ClassLoadingTypeProjection(Generic delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return this.delegate.getDeclaredAnnotations();
&nbsp;            }
&nbsp;
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;erasure&quot;)
&nbsp;            public TypeDescription asErasure() {
&nbsp;                TypeDescription var1 = this.erasure;
&nbsp;                TypeDescription var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
&nbsp;                    ClassLoadingTypeProjection var2 = this;
&nbsp;
&nbsp;                    try {
&nbsp;                        var10000 = TypeDescription.ForLoadedType.of(var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader));
&nbsp;                    } catch (ClassNotFoundException var5) {
&nbsp;                        var10000 = this.delegate.asErasure();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription var6 = var10000;
&nbsp;                if (var6 == null) {
&nbsp;                    var6 = this.erasure;
&nbsp;                } else {
&nbsp;                    this.erasure = var6;
&nbsp;                }
&nbsp;
&nbsp;                return var6;
&nbsp;            }
&nbsp;
&nbsp;            protected Generic resolve() {
&nbsp;                return this.delegate;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;superClass&quot;)
&nbsp;            public Generic getSuperClass() {
&nbsp;                Generic var1 = this.superClass;
&nbsp;                Object var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
&nbsp;                    ClassLoadingTypeProjection var2 = this;
&nbsp;                    Generic superClass = this.delegate.getSuperClass();
&nbsp;                    if (superClass == null) {
&nbsp;                        var10000 = TypeDescription.Generic.UNDEFINED;
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            var10000 = new ClassLoadingTypeProjection(superClass, var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader).getClassLoader(), var2.classLoadingDelegate);
&nbsp;                        } catch (ClassNotFoundException var6) {
&nbsp;                            var10000 = superClass;
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                Object var7 = var10000;
&nbsp;                if (var7 == null) {
&nbsp;                    var7 = this.superClass;
&nbsp;                } else {
&nbsp;                    this.superClass = (Generic)var7;
&nbsp;                }
&nbsp;
&nbsp;                return (Generic)var7;
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            @net.bytebuddy.build.CachedReturnPlugin.Enhance(&quot;interfaces&quot;)
&nbsp;            public TypeList.Generic getInterfaces() {
&nbsp;                TypeList.Generic var1 = this.interfaces;
&nbsp;                Object var10000;
&nbsp;                if (var1 != null) {
&nbsp;                    var10000 = null;
&nbsp;                } else {
<b class="fc">&nbsp;                    ClassLoadingTypeProjection var2 = this;</b>
&nbsp;                    TypeList.Generic interfaces = this.delegate.getInterfaces();
&nbsp;
&nbsp;                    try {
&nbsp;                        var10000 = new ClassLoadingTypeList(interfaces, var2.classLoadingDelegate.load(var2.delegate.asErasure().getName(), var2.classLoader).getClassLoader(), var2.classLoadingDelegate);
&nbsp;                    } catch (ClassNotFoundException var6) {
&nbsp;                        var10000 = interfaces;
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                Object var7 = var10000;
&nbsp;                if (var7 == null) {
&nbsp;                    var7 = this.interfaces;
&nbsp;                } else {
<b class="nc">&nbsp;                    this.interfaces = (TypeList.Generic)var7;</b>
&nbsp;                }
&nbsp;
&nbsp;                return (TypeList.Generic)var7;
&nbsp;            }
&nbsp;
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new TypeDefinition.SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected static class ClassLoadingTypeList extends TypeList.Generic.AbstractBase {
&nbsp;            private final TypeList.Generic delegate;
<b class="fc">&nbsp;            @MaybeNull</b>
&nbsp;            private final ClassLoader classLoader;
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            protected ClassLoadingTypeList(TypeList.Generic delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {
&nbsp;                this.delegate = delegate;
&nbsp;                this.classLoader = classLoader;
&nbsp;                this.classLoadingDelegate = classLoadingDelegate;
&nbsp;            }
&nbsp;
&nbsp;            public Generic get(int index) {
&nbsp;                return new ClassLoadingTypeProjection((Generic)this.delegate.get(index), this.classLoader, this.classLoadingDelegate);
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public int size() {
&nbsp;                return this.delegate.size();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public interface ClassLoadingDelegate {
&nbsp;            Class&lt;?&gt; load(String var1, @MaybeNull ClassLoader var2) throws ClassNotFoundException;
&nbsp;
&nbsp;            public static enum Simple implements ClassLoadingDelegate {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Simple() {
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; load(String name, @MaybeNull ClassLoader classLoader) throws ClassNotFoundException {
&nbsp;                    return Class.forName(name, false, classLoader);
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
