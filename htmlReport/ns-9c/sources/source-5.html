


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > InlineDelegateByteBuddyMockMaker</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.creation.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: InlineDelegateByteBuddyMockMaker (org.mockito.internal.creation.bytebuddy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InlineDelegateByteBuddyMockMaker</td>
<td class="coverageStat">
  <span class="percent">
    45%
  </span>
  <span class="absValue">
    (9/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.7%
  </span>
  <span class="absValue">
    (13/134)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.9%
  </span>
  <span class="absValue">
    (73/244)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InlineDelegateByteBuddyMockMaker$1</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    12.5%
  </span>
  <span class="absValue">
    (1/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    47.8%
  </span>
  <span class="absValue">
    (11/23)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.9%
  </span>
  <span class="absValue">
    (14/142)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.6%
  </span>
  <span class="absValue">
    (75/253)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.creation.bytebuddy;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.WeakHashMap;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.BiConsumer;
&nbsp;import java.util.function.Function;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import org.mockito.MockedConstruction;
&nbsp;import org.mockito.creation.instance.InstantiationException;
&nbsp;import org.mockito.creation.instance.Instantiator;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.exceptions.base.MockitoInitializationException;
&nbsp;import org.mockito.exceptions.misusing.MockitoConfigurationException;
&nbsp;import org.mockito.internal.PremainAttachAccess;
&nbsp;import org.mockito.internal.SuppressSignatureCheck;
&nbsp;import org.mockito.internal.configuration.plugins.Plugins;
&nbsp;import org.mockito.internal.creation.instance.ConstructorInstantiator;
&nbsp;import org.mockito.internal.framework.DisabledMockHandler;
&nbsp;import org.mockito.internal.util.Platform;
&nbsp;import org.mockito.internal.util.StringUtil;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal;
&nbsp;import org.mockito.internal.util.concurrent.WeakConcurrentMap;
&nbsp;import org.mockito.internal.util.concurrent.DetachedThreadLocal.Cleaner;
&nbsp;import org.mockito.invocation.MockHandler;
&nbsp;import org.mockito.mock.MockCreationSettings;
&nbsp;import org.mockito.plugins.InlineMockMaker;
&nbsp;import org.mockito.plugins.MemberAccessor;
&nbsp;import org.mockito.plugins.MockMaker;
&nbsp;
&nbsp;@SuppressSignatureCheck
&nbsp;class InlineDelegateByteBuddyMockMaker implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
&nbsp;    private static final Instrumentation INSTRUMENTATION;
&nbsp;    private static final Throwable INITIALIZATION_ERROR;
&nbsp;    private final BytecodeGenerator bytecodeGenerator;
&nbsp;    private final WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; mocks = new WeakConcurrentMap(false);
&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics;
&nbsp;    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt;&gt; mockedConstruction;
&nbsp;    private final ThreadLocal&lt;Class&lt;?&gt;&gt; currentMocking;
&nbsp;    private final ThreadLocal&lt;Object&gt; currentSpied;
&nbsp;
&nbsp;    InlineDelegateByteBuddyMockMaker() {
&nbsp;        this.mockedStatics = new DetachedThreadLocal(Cleaner.MANUAL);
&nbsp;        this.mockedConstruction = new DetachedThreadLocal(Cleaner.MANUAL);
&nbsp;        this.currentMocking = ThreadLocal.withInitial(() -&gt; null);
&nbsp;        this.currentSpied = new ThreadLocal();
&nbsp;        if (INITIALIZATION_ERROR == null) {
&nbsp;            ThreadLocal&lt;Class&lt;?&gt;&gt; currentConstruction = new ThreadLocal();
&nbsp;            ThreadLocal&lt;Boolean&gt; isSuspended = ThreadLocal.withInitial(() -&gt; false);
&nbsp;            Predicate&lt;Class&lt;?&gt;&gt; isCallFromSubclassConstructor = StackWalkerChecker.orFallback();
&nbsp;            Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction = (type) -&gt; {
&nbsp;                if ((Boolean)isSuspended.get()) {
&nbsp;                    return false;
&nbsp;                } else if ((this.currentMocking.get() == null || !type.isAssignableFrom((Class)this.currentMocking.get())) &amp;&amp; currentConstruction.get() == null) {
&nbsp;                    Map&lt;Class&lt;?&gt;, ?&gt; interceptors = (Map)this.mockedConstruction.get();
&nbsp;                    if (interceptors != null &amp;&amp; interceptors.containsKey(type)) {
&nbsp;                        if (isCallFromSubclassConstructor.test(type)) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            currentConstruction.set(type);
&nbsp;                            return true;
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return true;
&nbsp;                }
&nbsp;            };
&nbsp;            ConstructionCallback onConstruction = (type, object, arguments, parameterTypeNames) -&gt; {
&nbsp;                if (this.currentMocking.get() != null) {
&nbsp;                    Object spy = this.currentSpied.get();
&nbsp;                    if (spy == null) {
&nbsp;                        return null;
&nbsp;                    } else if (type.isInstance(spy)) {
&nbsp;                        return spy;
&nbsp;                    } else {
&nbsp;                        isSuspended.set(true);
&nbsp;
&nbsp;                        try {
&nbsp;                            String var10002 = type.getName();
&nbsp;                            throw new MockitoException(&quot;Unexpected spy for &quot; + var10002 + &quot; on instance of &quot; + object.getClass().getName(), object instanceof Throwable ? (Throwable)object : null);
&nbsp;                        } finally {
&nbsp;                            isSuspended.set(false);
&nbsp;                        }
&nbsp;                    }
&nbsp;                } else if (currentConstruction.get() != type) {
&nbsp;                    return null;
&nbsp;                } else {
&nbsp;                    currentConstruction.remove();
&nbsp;                    isSuspended.set(true);
&nbsp;
<b class="fc">&nbsp;                    try {</b>
&nbsp;                        Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors = (Map)this.mockedConstruction.get();
&nbsp;                        if (interceptors != null) {
&nbsp;                            BiConsumer&lt;Object, MockedConstruction.Context&gt; interceptor = (BiConsumer)interceptors.get(type);
&nbsp;                            if (interceptor != null) {
&nbsp;                                interceptor.accept(object, new InlineConstructionMockContext(arguments, object.getClass(), parameterTypeNames));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } finally {
&nbsp;                        isSuspended.set(false);
&nbsp;                    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                    return null;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            };
&nbsp;            this.bytecodeGenerator = new TypeCachingBytecodeGenerator(new InlineBytecodeGenerator(INSTRUMENTATION, this.mocks, this.mockedStatics, isMockConstruction, onConstruction), true);
&nbsp;        } else {
&nbsp;            String detail;
&nbsp;            if (!PlatformUtils.isAndroidPlatform() &amp;&amp; !PlatformUtils.isProbablyTermuxEnvironment()) {
&nbsp;                try {
&nbsp;                    if (INITIALIZATION_ERROR instanceof NoClassDefFoundError &amp;&amp; INITIALIZATION_ERROR.getMessage() != null &amp;&amp; INITIALIZATION_ERROR.getMessage().startsWith(&quot;net/bytebuddy/agent/&quot;)) {
&nbsp;                        detail = StringUtil.join(new Object[]{&quot;It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy Agent could not be loaded.&quot;, &quot;&quot;, &quot;Byte Buddy Agent is available on Maven Central as &#39;net.bytebuddy:byte-buddy-agent&#39; with the module name &#39;net.bytebuddy.agent&#39;.&quot;, &quot;Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but &quot;});
&nbsp;                    } else if (Class.forName(&quot;javax.tools.ToolProvider&quot;).getMethod(&quot;getSystemJavaCompiler&quot;).invoke((Object)null) == null) {
&nbsp;                        detail = &quot;It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.&quot;;
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        detail = &quot;It appears as if your JDK does not supply a working agent attachment mechanism.&quot;;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                } catch (Throwable var6) {</b>
&nbsp;                    detail = &quot;It appears as if you are running an incomplete JVM installation that might not support all tooling APIs&quot;;
<b class="fc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                detail = &quot;It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.&quot;;</b>
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            throw new MockitoInitializationException(StringUtil.join(new Object[]{&quot;Could not initialize inline Byte Buddy mock maker.&quot;, &quot;&quot;, detail, Platform.describe()}), INITIALIZATION_ERROR);</b>
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public &lt;T&gt; T createMock(MockCreationSettings&lt;T&gt; settings, MockHandler handler) {
&nbsp;        return (T)this.doCreateMock(settings, handler, false);
&nbsp;    }
&nbsp;
&nbsp;    public &lt;T&gt; Optional&lt;T&gt; createSpy(MockCreationSettings&lt;T&gt; settings, MockHandler handler, T object) {
&nbsp;        if (object == null) {
<b class="nc">&nbsp;            throw new MockitoConfigurationException(&quot;Spy instance must not be null&quot;);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            this.currentSpied.set(object);</b>
<b class="fc">&nbsp;</b>
&nbsp;            Optional var4;
<b class="fc">&nbsp;            try {</b>
<b class="fc">&nbsp;                var4 = Optional.ofNullable(this.doCreateMock(settings, handler, true));</b>
<b class="fc">&nbsp;            } finally {</b>
&nbsp;                this.currentSpied.remove();
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            return var4;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private &lt;T&gt; T doCreateMock(MockCreationSettings&lt;T&gt; settings, MockHandler handler, boolean nullOnNonInlineConstruction) {
<b class="fc">&nbsp;        Class&lt;? extends T&gt; type = this.&lt;T&gt;createMockType(settings);</b>
&nbsp;
&nbsp;        try {
&nbsp;            T instance;
&nbsp;            if (settings.isUsingConstructor()) {
<b class="nc">&nbsp;                instance = (T)(new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs())).newInstance(type);</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                try {
&nbsp;                    instance = (T)this.newInstance(type);
&nbsp;                } catch (InstantiationException var8) {
&nbsp;                    if (nullOnNonInlineConstruction) {
&nbsp;                        return null;
&nbsp;                    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                    Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(settings);</b>
&nbsp;                    instance = (T)instantiator.newInstance(type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(handler, settings);
&nbsp;            this.mocks.put(instance, mockMethodInterceptor);
&nbsp;            if (instance instanceof MockAccess) {
&nbsp;                ((MockAccess)instance).setMockitoInterceptor(mockMethodInterceptor);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            this.mocks.expungeStaleEntries();
<b class="fc">&nbsp;            return instance;</b>
<b class="fc">&nbsp;        } catch (InstantiationException e) {</b>
&nbsp;            throw new MockitoException(&quot;Unable to create mock instance of type &#39;&quot; + type.getSimpleName() + &quot;&#39;&quot;, e);
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public &lt;T&gt; Class&lt;? extends T&gt; createMockType(MockCreationSettings&lt;T&gt; settings) {</b>
&nbsp;        try {
&nbsp;            return this.bytecodeGenerator.mockClass(MockFeatures.withMockFeatures(settings.getTypeToMock(), settings.getExtraInterfaces(), settings.getSerializableMode(), settings.isStripAnnotations(), settings.getDefaultAnswer()));
<b class="fc">&nbsp;        } catch (Exception bytecodeGenerationFailed) {</b>
&nbsp;            throw this.prettifyFailure(settings, bytecodeGenerationFailed);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    private &lt;T&gt; RuntimeException prettifyFailure(MockCreationSettings&lt;T&gt; mockFeatures, Exception generationFailed) {
<b class="fc">&nbsp;        Class&lt;T&gt; typeToMock = mockFeatures.getTypeToMock();</b>
&nbsp;        if (typeToMock.isArray()) {
<b class="fc">&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Arrays cannot be mocked: &quot; + String.valueOf(typeToMock) + &quot;.&quot;, &quot;&quot;}), generationFailed);</b>
&nbsp;        } else if (Modifier.isFinal(typeToMock.getModifiers())) {
<b class="fc">&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + String.valueOf(typeToMock) + &quot;.&quot;, &quot;Can not mock final classes with the following settings :&quot;, &quot; - explicit serialization (e.g. withSettings().serializable())&quot;, &quot; - extra interfaces (e.g. withSettings().extraInterfaces(...))&quot;, &quot;&quot;, &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;, &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;, &quot;&quot;, &quot;Underlying exception : &quot; + String.valueOf(generationFailed)}), generationFailed);</b>
<b class="pc">&nbsp;        } else if (TypeSupport.INSTANCE.isSealed(typeToMock) &amp;&amp; typeToMock.isEnum()) {</b>
&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + String.valueOf(typeToMock) + &quot;.&quot;, &quot;Sealed abstract enums can&#39;t be mocked. Since Java 15 abstract enums are declared sealed, which prevents mocking.&quot;, &quot;You can still return an existing enum literal from a stubbed method call.&quot;}), generationFailed);
<b class="nc">&nbsp;        } else if (Modifier.isPrivate(typeToMock.getModifiers())) {</b>
<b class="nc">&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + String.valueOf(typeToMock) + &quot;.&quot;, &quot;Most likely it is a private class that is not visible by Mockito&quot;, &quot;&quot;, &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;, &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;, &quot;&quot;}), generationFailed);</b>
&nbsp;        } else {
&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Mockito cannot mock this class: &quot; + String.valueOf(typeToMock) + &quot;.&quot;, &quot;&quot;, &quot;If you&#39;re not sure why you&#39;re getting this error, please open an issue on GitHub.&quot;, &quot;&quot;, Platform.warnForVM(&quot;IBM J9 VM&quot;, &quot;Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n&quot;, &quot;Hotspot&quot;, &quot;&quot;), Platform.describe(), &quot;&quot;, &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;, &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;, &quot;&quot;, &quot;Underlying exception : &quot; + String.valueOf(generationFailed)}), generationFailed);
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public MockHandler getHandler(Object mock) {
<b class="nc">&nbsp;        MockMethodInterceptor interceptor;</b>
<b class="nc">&nbsp;        if (mock instanceof Class) {</b>
<b class="nc">&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();</b>
<b class="nc">&nbsp;            interceptor = interceptors != null ? (MockMethodInterceptor)interceptors.get(mock) : null;</b>
&nbsp;        } else {
&nbsp;            interceptor = (MockMethodInterceptor)this.mocks.get(mock);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return interceptor == null ? null : interceptor.handler;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
<b class="nc">&nbsp;        MockMethodInterceptor mockMethodInterceptor = new MockMethodInterceptor(newHandler, settings);</b>
&nbsp;        if (mock instanceof Class) {
&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();
<b class="nc">&nbsp;            if (interceptors == null || !interceptors.containsKey(mock)) {</b>
&nbsp;                throw new MockitoException(&quot;Cannot reset &quot; + String.valueOf(mock) + &quot; which is not currently registered as a static mock&quot;);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            interceptors.put((Class)mock, mockMethodInterceptor);</b>
&nbsp;        } else {
&nbsp;            if (!this.mocks.containsKey(mock)) {
&nbsp;                throw new MockitoException(&quot;Cannot reset &quot; + String.valueOf(mock) + &quot; which is not currently registered as a mock&quot;);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            this.mocks.put(mock, mockMethodInterceptor);
&nbsp;            if (mock instanceof MockAccess) {
&nbsp;                ((MockAccess)mock).setMockitoInterceptor(mockMethodInterceptor);
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            this.mocks.expungeStaleEntries();
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public void clearAllCaches() {</b>
&nbsp;        this.clearAllMocks();
<b class="nc">&nbsp;        this.bytecodeGenerator.clearAllCaches();</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public void clearMock(Object mock) {</b>
<b class="nc">&nbsp;        if (mock instanceof Class) {</b>
<b class="nc">&nbsp;            for(Map&lt;Class&lt;?&gt;, ?&gt; entry : this.mockedStatics.getBackingMap().target.values()) {</b>
&nbsp;                entry.remove(mock);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            this.mocks.remove(mock);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    public void clearAllMocks() {</b>
<b class="nc">&nbsp;        this.mockedStatics.getBackingMap().clear();</b>
&nbsp;
<b class="nc">&nbsp;        for(Map.Entry&lt;Object, MockMethodInterceptor&gt; entry : this.mocks) {</b>
&nbsp;            MockCreationSettings settings = ((MockMethodInterceptor)entry.getValue()).getMockHandler().getMockSettings();
&nbsp;            entry.setValue(new MockMethodInterceptor(DisabledMockHandler.HANDLER, settings));
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public MockMaker.TypeMockability isTypeMockable(final Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;        return new MockMaker.TypeMockability() {</b>
<b class="nc">&nbsp;            public boolean mockable() {</b>
<b class="nc">&nbsp;                return InlineDelegateByteBuddyMockMaker.INSTRUMENTATION.isModifiableClass(type) &amp;&amp; !InlineBytecodeGenerator.EXCLUDES.contains(type);</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public String nonMockableReason() {
&nbsp;                if (this.mockable()) {
<b class="nc">&nbsp;                    return &quot;&quot;;</b>
&nbsp;                } else if (type.isPrimitive()) {
<b class="nc">&nbsp;                    return &quot;primitive type&quot;;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return InlineBytecodeGenerator.EXCLUDES.contains(type) ? &quot;Cannot mock wrapper types, String.class or Class.class&quot; : &quot;VM does not support modification of given type&quot;;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        };</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public &lt;T&gt; MockMaker.StaticMockControl&lt;T&gt; createStaticMock(Class&lt;T&gt; type, MockCreationSettings&lt;T&gt; settings, MockHandler handler) {</b>
<b class="nc">&nbsp;        if (type == ConcurrentHashMap.class) {</b>
&nbsp;            throw new MockitoException(&quot;It is not possible to mock static methods of ConcurrentHashMap to avoid infinitive loops within Mockito&#39;s implementation of static mock handling&quot;);
<b class="nc">&nbsp;        } else if (type != Thread.class &amp;&amp; type != System.class &amp;&amp; type != Arrays.class &amp;&amp; !ClassLoader.class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;            this.bytecodeGenerator.mockClassStatic(type);</b>
&nbsp;            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = (Map)this.mockedStatics.get();
<b class="nc">&nbsp;            if (interceptors == null) {</b>
<b class="nc">&nbsp;                interceptors = new WeakHashMap();</b>
<b class="nc">&nbsp;                this.mockedStatics.set(interceptors);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            this.mockedStatics.getBackingMap().expungeStaleEntries();</b>
<b class="nc">&nbsp;            return new InlineStaticMockControl&lt;T&gt;(type, interceptors, settings, handler);</b>
&nbsp;        } else {
&nbsp;            throw new MockitoException(&quot;It is not possible to mock static methods of &quot; + type.getName() + &quot; to avoid interfering with class loading what leads to infinite loops&quot;);
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public &lt;T&gt; MockMaker.ConstructionMockControl&lt;T&gt; createConstructionMock(Class&lt;T&gt; type, Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory, Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer) {
<b class="nc">&nbsp;        if (type == Object.class) {</b>
&nbsp;            throw new MockitoException(&quot;It is not possible to mock construction of the Object class to avoid inference with default object constructor chains&quot;);
<b class="nc">&nbsp;        } else if (!type.isPrimitive() &amp;&amp; !Modifier.isAbstract(type.getModifiers())) {</b>
&nbsp;            this.bytecodeGenerator.mockClassConstruction(type);
&nbsp;            Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors = (Map)this.mockedConstruction.get();
<b class="fc">&nbsp;            if (interceptors == null) {</b>
&nbsp;                interceptors = new WeakHashMap();
&nbsp;                this.mockedConstruction.set(interceptors);
&nbsp;            }
&nbsp;
&nbsp;            this.mockedConstruction.getBackingMap().expungeStaleEntries();
&nbsp;            return new InlineConstructionMockControl&lt;T&gt;(type, settingsFactory, handlerFactory, mockInitializer, interceptors);
&nbsp;        } else {
&nbsp;            throw new MockitoException(&quot;It is not possible to construct primitive types or abstract types: &quot; + type.getName());
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public &lt;T&gt; T newInstance(Class&lt;T&gt; cls) throws InstantiationException {
<b class="fc">&nbsp;        Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();</b>
&nbsp;        if (constructors.length == 0) {
&nbsp;            throw new InstantiationException(cls.getName() + &quot; does not define a constructor&quot;);
&nbsp;        } else {
&nbsp;            Constructor&lt;?&gt; selected = constructors[0];
&nbsp;
<b class="nc">&nbsp;            for(Constructor&lt;?&gt; constructor : constructors) {</b>
<b class="nc">&nbsp;                if (Modifier.isPublic(constructor.getModifiers())) {</b>
&nbsp;                    selected = constructor;
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            Class&lt;?&gt;[] types = selected.getParameterTypes();</b>
&nbsp;            Object[] arguments = new Object[types.length];
&nbsp;            int index = 0;
&nbsp;
&nbsp;            for(Class&lt;?&gt; type : types) {
&nbsp;                arguments[index++] = this.makeStandardArgument(type);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            MemberAccessor accessor = Plugins.getMemberAccessor();</b>
&nbsp;
&nbsp;            try {
&nbsp;                return (T)accessor.newInstance(selected, (callback) -&gt; {
<b class="pc">&nbsp;                    this.currentMocking.set(cls);</b>
<b class="nc">&nbsp;</b>
&nbsp;                    Object var3;
<b class="nc">&nbsp;                    try {</b>
<b class="nc">&nbsp;                        var3 = callback.newInstance();</b>
<b class="nc">&nbsp;                    } finally {</b>
&nbsp;                        this.currentMocking.remove();
&nbsp;                    }
&nbsp;
&nbsp;                    return var3;
<b class="fc">&nbsp;                }, arguments);</b>
&nbsp;            } catch (Exception e) {
<b class="nc">&nbsp;                throw new InstantiationException(&quot;Could not instantiate &quot; + cls.getName(), e);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private Object makeStandardArgument(Class&lt;?&gt; type) {</b>
&nbsp;        if (type == Boolean.TYPE) {
&nbsp;            return false;
<b class="fc">&nbsp;        } else if (type == Byte.TYPE) {</b>
&nbsp;            return 0;
<b class="fc">&nbsp;        } else if (type == Short.TYPE) {</b>
<b class="pc">&nbsp;            return Short.valueOf((short)0);</b>
<b class="fc">&nbsp;        } else if (type == Character.TYPE) {</b>
&nbsp;            return &#39;\u0000&#39;;
<b class="fc">&nbsp;        } else if (type == Integer.TYPE) {</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        } else if (type == Long.TYPE) {
<b class="nc">&nbsp;            return 0L;</b>
<b class="nc">&nbsp;        } else if (type == Float.TYPE) {</b>
&nbsp;            return 0.0F;
&nbsp;        } else {
&nbsp;            return type == Double.TYPE ? (double)0.0F : null;
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    static {</b>
<b class="fc">&nbsp;        Throwable initializationError = null;</b>
<b class="fc">&nbsp;        if (System.getProperty(&quot;os.name&quot;) == null) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(StringUtil.join(new Object[]{&quot;The Byte Buddy agent cannot be loaded.&quot;, &quot;&quot;, &quot;To initialise the Byte Buddy agent, a subprocess may need to be created. To do this, the JVM requires knowledge of the &#39;os.name&#39; System property in most JRE implementations. This property is not present, which means this operation will fail to complete. Please first make sure you are not clearing this property anywhere, and failing that, raise a bug with your JVM vendor.&quot;}));</b>
<b class="fc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            Instrumentation instrumentation;</b>
<b class="fc">&nbsp;            try {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    instrumentation = PremainAttachAccess.getInstrumentation();</b>
&nbsp;                    File boot = File.createTempFile(&quot;mockitoboot&quot;, &quot;.jar&quot;);
&nbsp;                    boot.deleteOnExit();
&nbsp;
&nbsp;                    try (JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot))) {
&nbsp;                        String source = &quot;org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher&quot;;
<b class="nc">&nbsp;                        InputStream inputStream = InlineDelegateByteBuddyMockMaker.class.getClassLoader().getResourceAsStream(source + &quot;.raw&quot;);</b>
<b class="nc">&nbsp;                        if (inputStream == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(StringUtil.join(new Object[]{&quot;The MockMethodDispatcher class file is not locatable: &quot; + source + &quot;.raw&quot;, &quot;&quot;, &quot;The class loader responsible for looking up the resource: &quot; + String.valueOf(InlineDelegateByteBuddyMockMaker.class.getClassLoader())}));</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
<b class="nc">&nbsp;                        InputStream var6 = inputStream;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                        try {</b>
&nbsp;                            outputStream.putNextEntry(new JarEntry(source + &quot;.class&quot;));
&nbsp;                            byte[] buffer = new byte[1024];
&nbsp;
&nbsp;                            int length;
&nbsp;                            while((length = inputStream.read(buffer)) != -1) {
&nbsp;                                outputStream.write(buffer, 0, length);
&nbsp;                            }
&nbsp;                        } catch (Throwable var14) {
&nbsp;                            if (inputStream != null) {
&nbsp;                                try {
&nbsp;                                    var6.close();
<b class="nc">&nbsp;                                } catch (Throwable var11) {</b>
<b class="nc">&nbsp;                                    var14.addSuppressed(var11);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
&nbsp;                            throw var14;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        if (inputStream != null) {</b>
<b class="nc">&nbsp;                            inputStream.close();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        outputStream.closeEntry();
&nbsp;                    }
&nbsp;
&nbsp;                    try (JarFile var18 = new JarFile(boot)) {
&nbsp;                        instrumentation.appendToBootstrapClassLoaderSearch(var18);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    try {</b>
<b class="nc">&nbsp;                        Class.forName(&quot;org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher&quot;, false, (ClassLoader)null);</b>
&nbsp;                    } catch (ClassNotFoundException cnfe) {
&nbsp;                        throw new IllegalStateException(StringUtil.join(new Object[]{&quot;Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader&quot;, &quot;&quot;, &quot;It seems like your current VM does not support the instrumentation API correctly.&quot;}), cnfe);
&nbsp;                    }
&nbsp;                } catch (IOException ioe) {
<b class="nc">&nbsp;                    throw new IllegalStateException(StringUtil.join(new Object[]{&quot;Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.&quot;, &quot;This error occured due to an I/O error during the creation of this agent: &quot; + String.valueOf(ioe), &quot;&quot;, &quot;Potentially, the current VM does not support the instrumentation API correctly&quot;}), ioe);</b>
&nbsp;                }
&nbsp;            } catch (Throwable throwable) {
&nbsp;                instrumentation = null;
&nbsp;                initializationError = throwable;
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            INSTRUMENTATION = instrumentation;
&nbsp;            INITIALIZATION_ERROR = initializationError;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class InlineStaticMockControl&lt;T&gt; implements MockMaker.StaticMockControl&lt;T&gt; {
&nbsp;        private final Class&lt;T&gt; type;
&nbsp;        private final Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors;
&nbsp;        private final MockCreationSettings&lt;T&gt; settings;
&nbsp;        private final MockHandler handler;
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;        private InlineStaticMockControl(Class&lt;T&gt; type, Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors, MockCreationSettings&lt;T&gt; settings, MockHandler handler) {</b>
<b class="nc">&nbsp;            this.type = type;</b>
&nbsp;            this.interceptors = interceptors;
<b class="fc">&nbsp;            this.settings = settings;</b>
&nbsp;            this.handler = handler;
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public Class&lt;T&gt; getType() {
<b class="fc">&nbsp;            return this.type;</b>
&nbsp;        }
&nbsp;
&nbsp;        public void enable() {
&nbsp;            if (this.interceptors.putIfAbsent(this.type, new MockMethodInterceptor(this.handler, this.settings)) != null) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;For &quot; + this.type.getName() + &quot;, static mocking is already registered in the current thread&quot;, &quot;&quot;, &quot;To create a new mock, the existing static mock registration must be deregistered&quot;}));
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public void disable() {</b>
<b class="nc">&nbsp;            if (this.interceptors.remove(this.type) == null) {</b>
<b class="nc">&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not deregister &quot; + this.type.getName() + &quot; as a static mock since it is not currently registered&quot;, &quot;&quot;, &quot;To register a static mock, use Mockito.mockStatic(&quot; + this.type.getSimpleName() + &quot;.class)&quot;}));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private class InlineConstructionMockControl&lt;T&gt; implements MockMaker.ConstructionMockControl&lt;T&gt; {</b>
&nbsp;        private final Class&lt;T&gt; type;
<b class="nc">&nbsp;        private final Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory;</b>
<b class="nc">&nbsp;        private final Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory;</b>
&nbsp;        private final MockedConstruction.MockInitializer&lt;T&gt; mockInitializer;
&nbsp;        private final Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors;
<b class="nc">&nbsp;        private final List&lt;Object&gt; all = new ArrayList();</b>
<b class="nc">&nbsp;        private int count;</b>
<b class="nc">&nbsp;</b>
&nbsp;        private InlineConstructionMockControl(Class&lt;T&gt; type, Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory, Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory, MockedConstruction.MockInitializer&lt;T&gt; mockInitializer, Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors) {
<b class="nc">&nbsp;            this.type = type;</b>
&nbsp;            this.settingsFactory = settingsFactory;
&nbsp;            this.handlerFactory = handlerFactory;
&nbsp;            this.mockInitializer = mockInitializer;
&nbsp;            this.interceptors = interceptors;
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Class&lt;T&gt; getType() {</b>
&nbsp;            return this.type;
&nbsp;        }
&nbsp;
&nbsp;        public void enable() {
<b class="nc">&nbsp;            if (this.interceptors.putIfAbsent(this.type, (BiConsumer)(object, context) -&gt; {</b>
<b class="nc">&nbsp;                ((InlineConstructionMockContext)context).count = ++this.count;</b>
<b class="nc">&nbsp;                MockMethodInterceptor interceptor = new MockMethodInterceptor((MockHandler)this.handlerFactory.apply(context), (MockCreationSettings)this.settingsFactory.apply(context));</b>
&nbsp;                InlineDelegateByteBuddyMockMaker.this.mocks.put(object, interceptor);
&nbsp;
<b class="nc">&nbsp;                try {</b>
&nbsp;                    this.mockInitializer.prepare(object, context);
&nbsp;                } catch (Throwable t) {
&nbsp;                    InlineDelegateByteBuddyMockMaker.this.mocks.remove(object);
&nbsp;                    throw new MockitoException(&quot;Could not initialize mocked construction&quot;, t);
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                this.all.add(object);
<b class="nc">&nbsp;            }) != null) {</b>
<b class="nc">&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;For &quot; + this.type.getName() + &quot;, static mocking is already registered in the current thread&quot;, &quot;&quot;, &quot;To create a new mock, the existing static mock registration must be deregistered&quot;}));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public void disable() {
&nbsp;            if (this.interceptors.remove(this.type) == null) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not deregister &quot; + this.type.getName() + &quot; as a static mock since it is not currently registered&quot;, &quot;&quot;, &quot;To register a static mock, use Mockito.mockStatic(&quot; + this.type.getSimpleName() + &quot;.class)&quot;}));
<b class="fc">&nbsp;            } else {</b>
&nbsp;                this.all.clear();
&nbsp;            }
<b class="pc">&nbsp;        }</b>
&nbsp;
&nbsp;        public List&lt;T&gt; getMocks() {
&nbsp;            return this.all;
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private static class InlineConstructionMockContext implements MockedConstruction.Context {
<b class="nc">&nbsp;        private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVES = new HashMap();</b>
<b class="nc">&nbsp;        private int count;</b>
&nbsp;        private final Object[] arguments;
<b class="nc">&nbsp;        private final Class&lt;?&gt; type;</b>
<b class="nc">&nbsp;        private final String[] parameterTypeNames;</b>
&nbsp;
<b class="nc">&nbsp;        private InlineConstructionMockContext(Object[] arguments, Class&lt;?&gt; type, String[] parameterTypeNames) {</b>
&nbsp;            this.arguments = arguments;
&nbsp;            this.type = type;
&nbsp;            this.parameterTypeNames = parameterTypeNames;
&nbsp;        }
&nbsp;
&nbsp;        public int getCount() {
&nbsp;            if (this.count == 0) {
<b class="nc">&nbsp;                throw new MockitoConfigurationException(&quot;mocked construction context is not initialized&quot;);</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                return this.count;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Constructor&lt;?&gt; constructor() {
<b class="nc">&nbsp;            Class&lt;?&gt;[] parameterTypes = new Class[this.parameterTypeNames.length];</b>
<b class="nc">&nbsp;            int index = 0;</b>
&nbsp;
<b class="nc">&nbsp;            for(String parameterTypeName : this.parameterTypeNames) {</b>
&nbsp;                if (PRIMITIVES.containsKey(parameterTypeName)) {
&nbsp;                    parameterTypes[index++] = (Class)PRIMITIVES.get(parameterTypeName);
&nbsp;                } else {
<b class="nc">&nbsp;                    try {</b>
&nbsp;                        parameterTypes[index++] = Class.forName(parameterTypeName, false, this.type.getClassLoader());
<b class="nc">&nbsp;                    } catch (ClassNotFoundException e) {</b>
<b class="nc">&nbsp;                        throw new MockitoException(&quot;Could not find parameter of type &quot; + parameterTypeName, e);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            try {
<b class="nc">&nbsp;                return this.type.getDeclaredConstructor(parameterTypes);</b>
&nbsp;            } catch (NoSuchMethodException e) {
&nbsp;                throw new MockitoException(StringUtil.join(new Object[]{&quot;Could not resolve constructor of type&quot;, &quot;&quot;, this.type.getName(), &quot;&quot;, &quot;with arguments of types&quot;, Arrays.toString(parameterTypes)}), e);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;?&gt; arguments() {
&nbsp;            return Collections.unmodifiableList(Arrays.asList(this.arguments));
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        static {</b>
&nbsp;            PRIMITIVES.put(Boolean.TYPE.getName(), Boolean.TYPE);
&nbsp;            PRIMITIVES.put(Byte.TYPE.getName(), Byte.TYPE);
<b class="nc">&nbsp;            PRIMITIVES.put(Short.TYPE.getName(), Short.TYPE);</b>
<b class="nc">&nbsp;            PRIMITIVES.put(Character.TYPE.getName(), Character.TYPE);</b>
&nbsp;            PRIMITIVES.put(Integer.TYPE.getName(), Integer.TYPE);
<b class="nc">&nbsp;            PRIMITIVES.put(Long.TYPE.getName(), Long.TYPE);</b>
&nbsp;            PRIMITIVES.put(Float.TYPE.getName(), Float.TYPE);
&nbsp;            PRIMITIVES.put(Double.TYPE.getName(), Double.TYPE);
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:43</div>
</div>
</body>
</html>
