


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ClassUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.util</a>
</div>

<h1>Coverage Summary for Class: ClassUtils (org.springframework.util)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassUtils</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.7%
  </span>
  <span class="absValue">
    (6/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.4%
  </span>
  <span class="absValue">
    (19/298)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.4%
  </span>
  <span class="absValue">
    (59/383)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.springframework.util;
&nbsp;
&nbsp;import java.io.Closeable;
&nbsp;import java.io.Externalizable;
&nbsp;import java.io.File;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.net.InetAddress;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.nio.charset.Charset;
&nbsp;import java.nio.file.Path;
&nbsp;import java.time.ZoneId;
&nbsp;import java.time.temporal.Temporal;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Currency;
&nbsp;import java.util.Date;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.StringJoiner;
&nbsp;import java.util.TimeZone;
&nbsp;import java.util.UUID;
&nbsp;import java.util.regex.Pattern;
&nbsp;import org.springframework.lang.Nullable;
&nbsp;
&nbsp;public abstract class ClassUtils {
&nbsp;    public static final String ARRAY_SUFFIX = &quot;[]&quot;;
&nbsp;    private static final String INTERNAL_ARRAY_PREFIX = &quot;[&quot;;
&nbsp;    private static final String NON_PRIMITIVE_ARRAY_PREFIX = &quot;[L&quot;;
&nbsp;    private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0];
&nbsp;    private static final char PACKAGE_SEPARATOR = &#39;.&#39;;
&nbsp;    private static final char PATH_SEPARATOR = &#39;/&#39;;
&nbsp;    private static final char NESTED_CLASS_SEPARATOR = &#39;$&#39;;
&nbsp;    public static final String CGLIB_CLASS_SEPARATOR = &quot;$$&quot;;
&nbsp;    public static final String CLASS_FILE_SUFFIX = &quot;.class&quot;;
&nbsp;    private static final int NON_OVERRIDABLE_MODIFIER = 26;
&nbsp;    private static final int OVERRIDABLE_MODIFIER = 5;
&nbsp;    private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitiveWrapperTypeMap = new IdentityHashMap(9);
&nbsp;    private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitiveTypeToWrapperMap = new IdentityHashMap(9);
&nbsp;    private static final Map&lt;String, Class&lt;?&gt;&gt; primitiveTypeNameMap = new HashMap(32);
&nbsp;    private static final Map&lt;String, Class&lt;?&gt;&gt; commonClassCache = new HashMap(64);
&nbsp;    private static final Set&lt;Class&lt;?&gt;&gt; javaLanguageInterfaces;
&nbsp;    private static final Map&lt;Method, Method&gt; interfaceMethodCache = new ConcurrentReferenceHashMap(256);
&nbsp;    private static final Map&lt;Method, Method&gt; publicInterfaceMethodCache = new ConcurrentReferenceHashMap(256);
&nbsp;    private static final Map&lt;Method, Method&gt; publiclyAccessibleMethodCache = new ConcurrentReferenceHashMap(256);
&nbsp;
&nbsp;    public ClassUtils() {
&nbsp;    }
&nbsp;
&nbsp;    private static void registerCommonClasses(Class&lt;?&gt;... commonClasses) {
&nbsp;        for(Class&lt;?&gt; clazz : commonClasses) {
&nbsp;            commonClassCache.put(clazz.getName(), clazz);
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public static ClassLoader getDefaultClassLoader() {
&nbsp;        ClassLoader cl = null;
&nbsp;
&nbsp;        try {
&nbsp;            cl = Thread.currentThread().getContextClassLoader();
&nbsp;        } catch (Throwable var3) {
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        if (cl == null) {
&nbsp;            cl = ClassUtils.class.getClassLoader();
&nbsp;            if (cl == null) {
&nbsp;                try {
&nbsp;                    cl = ClassLoader.getSystemClassLoader();
&nbsp;                } catch (Throwable var2) {
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return cl;
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public static ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {
&nbsp;        Thread currentThread = Thread.currentThread();
&nbsp;        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
&nbsp;        if (classLoaderToUse != null &amp;&amp; !classLoaderToUse.equals(threadContextClassLoader)) {
&nbsp;            currentThread.setContextClassLoader(classLoaderToUse);
&nbsp;            return threadContextClassLoader;
&nbsp;        } else {
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt; forName(String name, @Nullable ClassLoader classLoader) throws ClassNotFoundException, LinkageError {
&nbsp;        Assert.notNull(name, &quot;Name must not be null&quot;);
<b class="fc">&nbsp;        Class&lt;?&gt; clazz = resolvePrimitiveClassName(name);</b>
&nbsp;        if (clazz == null) {
&nbsp;            clazz = (Class)commonClassCache.get(name);
&nbsp;        }
&nbsp;
&nbsp;        if (clazz != null) {
<b class="fc">&nbsp;            return clazz;</b>
&nbsp;        } else if (name.endsWith(&quot;[]&quot;)) {
&nbsp;            String elementClassName = name.substring(0, name.length() - &quot;[]&quot;.length());
&nbsp;            Class&lt;?&gt; elementClass = forName(elementClassName, classLoader);
&nbsp;            return elementClass.arrayType();
&nbsp;        } else if (name.startsWith(&quot;[L&quot;) &amp;&amp; name.endsWith(&quot;;&quot;)) {
<b class="fc">&nbsp;            String elementName = name.substring(&quot;[L&quot;.length(), name.length() - 1);</b>
&nbsp;            Class&lt;?&gt; elementClass = forName(elementName, classLoader);
&nbsp;            return elementClass.arrayType();
&nbsp;        } else if (name.startsWith(&quot;[&quot;)) {
&nbsp;            String elementName = name.substring(&quot;[&quot;.length());
&nbsp;            Class&lt;?&gt; elementClass = forName(elementName, classLoader);
<b class="fc">&nbsp;            return elementClass.arrayType();</b>
&nbsp;        } else {
&nbsp;            ClassLoader clToUse = classLoader;
&nbsp;            if (classLoader == null) {
&nbsp;                clToUse = getDefaultClassLoader();
&nbsp;            }
&nbsp;
&nbsp;            try {
&nbsp;                return Class.forName(name, false, clToUse);
&nbsp;            } catch (ClassNotFoundException ex) {
&nbsp;                int lastDotIndex = name.lastIndexOf(46);
&nbsp;                int previousDotIndex = name.lastIndexOf(46, lastDotIndex - 1);
<b class="fc">&nbsp;                if (lastDotIndex != -1 &amp;&amp; previousDotIndex != -1 &amp;&amp; Character.isUpperCase(name.charAt(previousDotIndex + 1))) {</b>
&nbsp;                    String var10000 = name.substring(0, lastDotIndex);
&nbsp;                    String nestedClassName = var10000 + &quot;$&quot; + name.substring(lastDotIndex + 1);
&nbsp;
&nbsp;                    try {
&nbsp;                        return Class.forName(nestedClassName, false, clToUse);
&nbsp;                    } catch (ClassNotFoundException var9) {
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                throw ex;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static Class&lt;?&gt; resolveClassName(String className, @Nullable ClassLoader classLoader) throws IllegalArgumentException {</b>
&nbsp;        try {
&nbsp;            return forName(className, classLoader);
&nbsp;        } catch (IllegalAccessError err) {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Readability mismatch in inheritance hierarchy of class [&quot; + className + &quot;]: &quot; + err.getMessage(), err);</b>
<b class="fc">&nbsp;        } catch (LinkageError err) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Unresolvable class definition for class [&quot; + className + &quot;]&quot;, err);</b>
<b class="fc">&nbsp;        } catch (ClassNotFoundException ex) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Could not find class [&quot; + className + &quot;]&quot;, ex);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static boolean isPresent(String className, @Nullable ClassLoader classLoader) {</b>
&nbsp;        try {
&nbsp;            forName(className, classLoader);
<b class="fc">&nbsp;            return true;</b>
<b class="fc">&nbsp;        } catch (IllegalAccessError err) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Readability mismatch in inheritance hierarchy of class [&quot; + className + &quot;]: &quot; + err.getMessage(), err);</b>
&nbsp;        } catch (Throwable var4) {
&nbsp;            return false;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    public static boolean isVisible(Class&lt;?&gt; clazz, @Nullable ClassLoader classLoader) {
<b class="fc">&nbsp;        if (classLoader == null) {</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        } else {
&nbsp;            try {
<b class="fc">&nbsp;                if (clazz.getClassLoader() == classLoader) {</b>
&nbsp;                    return true;
<b class="fc">&nbsp;                }</b>
&nbsp;            } catch (SecurityException var3) {
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return isLoadable(clazz, classLoader);</b>
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static boolean isCacheSafe(Class&lt;?&gt; clazz, @Nullable ClassLoader classLoader) {
<b class="fc">&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);</b>
<b class="fc">&nbsp;</b>
&nbsp;        try {
&nbsp;            ClassLoader target = clazz.getClassLoader();
&nbsp;            if (target == classLoader || target == null) {
&nbsp;                return true;
&nbsp;            }
&nbsp;
&nbsp;            if (classLoader == null) {
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            ClassLoader current = classLoader;
&nbsp;
&nbsp;            while(current != null) {
&nbsp;                current = current.getParent();
&nbsp;                if (current == target) {
&nbsp;                    return true;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            while(target != null) {
&nbsp;                target = target.getParent();
&nbsp;                if (target == classLoader) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;        } catch (SecurityException var4) {
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return classLoader != null &amp;&amp; isLoadable(clazz, classLoader);</b>
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    private static boolean isLoadable(Class&lt;?&gt; clazz, ClassLoader classLoader) {
&nbsp;        try {
&nbsp;            return clazz == classLoader.loadClass(clazz.getName());
&nbsp;        } catch (ClassNotFoundException var3) {
<b class="pc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    @Nullable
&nbsp;    public static Class&lt;?&gt; resolvePrimitiveClassName(@Nullable String name) {
<b class="nc">&nbsp;        Class&lt;?&gt; result = null;</b>
&nbsp;        if (name != null &amp;&amp; name.length() &lt;= 7) {
&nbsp;            result = (Class)primitiveTypeNameMap.get(name);
&nbsp;        }
&nbsp;
&nbsp;        return result;
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static boolean isPrimitiveWrapper(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return primitiveWrapperTypeMap.containsKey(clazz);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrimitiveOrWrapper(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return clazz.isPrimitive() || isPrimitiveWrapper(clazz);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrimitiveArray(Class&lt;?&gt; clazz) {
<b class="nc">&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);</b>
<b class="nc">&nbsp;        return clazz.isArray() &amp;&amp; clazz.componentType().isPrimitive();</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static boolean isPrimitiveWrapperArray(Class&lt;?&gt; clazz) {</b>
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return clazz.isArray() &amp;&amp; isPrimitiveWrapper(clazz.componentType());
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static Class&lt;?&gt; resolvePrimitiveIfNecessary(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return clazz.isPrimitive() &amp;&amp; clazz != Void.TYPE ? (Class)primitiveTypeToWrapperMap.get(clazz) : clazz;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isVoidType(@Nullable Class&lt;?&gt; type) {
&nbsp;        return type == Void.TYPE || type == Void.class;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isSimpleValueType(Class&lt;?&gt; type) {
&nbsp;        return !isVoidType(type) &amp;&amp; (isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || ZoneId.class.isAssignableFrom(type) || TimeZone.class.isAssignableFrom(type) || File.class.isAssignableFrom(type) || Path.class.isAssignableFrom(type) || Charset.class.isAssignableFrom(type) || Currency.class.isAssignableFrom(type) || InetAddress.class.isAssignableFrom(type) || URI.class == type || URL.class == type || UUID.class == type || Locale.class == type || Pattern.class == type || Class.class == type);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAssignable(Class&lt;?&gt; lhsType, Class&lt;?&gt; rhsType) {
&nbsp;        Assert.notNull(lhsType, &quot;Left-hand side type must not be null&quot;);
&nbsp;        Assert.notNull(rhsType, &quot;Right-hand side type must not be null&quot;);
&nbsp;        if (lhsType.isAssignableFrom(rhsType)) {
&nbsp;            return true;
<b class="fc">&nbsp;        } else if (lhsType.isPrimitive()) {</b>
&nbsp;            Class&lt;?&gt; resolvedPrimitive = (Class)primitiveWrapperTypeMap.get(rhsType);
<b class="fc">&nbsp;            return lhsType == resolvedPrimitive;</b>
<b class="pc">&nbsp;        } else {</b>
<b class="fc">&nbsp;            Class&lt;?&gt; resolvedWrapper = (Class)primitiveTypeToWrapperMap.get(rhsType);</b>
&nbsp;            return resolvedWrapper != null &amp;&amp; lhsType.isAssignableFrom(resolvedWrapper);
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static boolean isAssignableValue(Class&lt;?&gt; type, @Nullable Object value) {
&nbsp;        Assert.notNull(type, &quot;Type must not be null&quot;);
<b class="pc">&nbsp;        return value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive();</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static String convertResourcePathToClassName(String resourcePath) {</b>
&nbsp;        Assert.notNull(resourcePath, &quot;Resource path must not be null&quot;);
&nbsp;        return resourcePath.replace(&#39;/&#39;, &#39;.&#39;);
&nbsp;    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;    public static String convertClassNameToResourcePath(String className) {</b>
<b class="nc">&nbsp;        Assert.notNull(className, &quot;Class name must not be null&quot;);</b>
<b class="nc">&nbsp;        return className.replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String addResourcePathToPackagePath(Class&lt;?&gt; clazz, String resourceName) {
<b class="pc">&nbsp;        Assert.notNull(resourceName, &quot;Resource name must not be null&quot;);</b>
<b class="nc">&nbsp;        if (!resourceName.startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;            String var2 = classPackageAsResourcePath(clazz);</b>
<b class="nc">&nbsp;            return var2 + &quot;/&quot; + resourceName;</b>
&nbsp;        } else {
&nbsp;            String var10000 = classPackageAsResourcePath(clazz);
<b class="fc">&nbsp;            return var10000 + resourceName;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static String classPackageAsResourcePath(@Nullable Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;        if (clazz == null) {</b>
&nbsp;            return &quot;&quot;;
&nbsp;        } else {
<b class="fc">&nbsp;            String className = clazz.getName();</b>
<b class="fc">&nbsp;            int packageEndIndex = className.lastIndexOf(46);</b>
<b class="pc">&nbsp;            if (packageEndIndex == -1) {</b>
<b class="nc">&nbsp;                return &quot;&quot;;</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                String packageName = className.substring(0, packageEndIndex);
<b class="nc">&nbsp;                return packageName.replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static String classNamesToString(Class&lt;?&gt;... classes) {
&nbsp;        return classNamesToString(Arrays.asList(classes));
&nbsp;    }
&nbsp;
&nbsp;    public static String classNamesToString(@Nullable Collection&lt;Class&lt;?&gt;&gt; classes) {
&nbsp;        if (CollectionUtils.isEmpty(classes)) {
&nbsp;            return &quot;[]&quot;;
&nbsp;        } else {
&nbsp;            StringJoiner stringJoiner = new StringJoiner(&quot;, &quot;, &quot;[&quot;, &quot;]&quot;);
&nbsp;
&nbsp;            for(Class&lt;?&gt; clazz : classes) {
&nbsp;                stringJoiner.add(clazz.getName());
&nbsp;            }
&nbsp;
&nbsp;            return stringJoiner.toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt;[] toClassArray(@Nullable Collection&lt;Class&lt;?&gt;&gt; collection) {
&nbsp;        return !CollectionUtils.isEmpty(collection) ? (Class[])collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY;
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt;[] getAllInterfaces(Object instance) {
&nbsp;        Assert.notNull(instance, &quot;Instance must not be null&quot;);
&nbsp;        return getAllInterfacesForClass(instance.getClass());
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Class&lt;?&gt;[] getAllInterfacesForClass(Class&lt;?&gt; clazz) {</b>
&nbsp;        return getAllInterfacesForClass(clazz, (ClassLoader)null);
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static Class&lt;?&gt;[] getAllInterfacesForClass(Class&lt;?&gt; clazz, @Nullable ClassLoader classLoader) {</b>
&nbsp;        return toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static Set&lt;Class&lt;?&gt;&gt; getAllInterfacesAsSet(Object instance) {
&nbsp;        Assert.notNull(instance, &quot;Instance must not be null&quot;);
<b class="nc">&nbsp;        return getAllInterfacesForClassAsSet(instance.getClass());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Set&lt;Class&lt;?&gt;&gt; getAllInterfacesForClassAsSet(Class&lt;?&gt; clazz) {
&nbsp;        return getAllInterfacesForClassAsSet(clazz, (ClassLoader)null);
&nbsp;    }
&nbsp;
&nbsp;    public static Set&lt;Class&lt;?&gt;&gt; getAllInterfacesForClassAsSet(Class&lt;?&gt; clazz, @Nullable ClassLoader classLoader) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        if (clazz.isInterface() &amp;&amp; isVisible(clazz, classLoader)) {
&nbsp;            return Collections.singleton(clazz);
&nbsp;        } else {
&nbsp;            Set&lt;Class&lt;?&gt;&gt; interfaces = new LinkedHashSet();
&nbsp;
&nbsp;            for(Class&lt;?&gt; current = clazz; current != null; current = current.getSuperclass()) {
&nbsp;                Class&lt;?&gt;[] ifcs = current.getInterfaces();
&nbsp;
&nbsp;                for(Class&lt;?&gt; ifc : ifcs) {
&nbsp;                    if (isVisible(ifc, classLoader)) {
&nbsp;                        interfaces.add(ifc);
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return interfaces;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt; createCompositeInterface(Class&lt;?&gt;[] interfaces, @Nullable ClassLoader classLoader) {
<b class="fc">&nbsp;        Assert.notEmpty(interfaces, &quot;Interface array must not be empty&quot;);</b>
&nbsp;        return Proxy.getProxyClass(classLoader, interfaces);
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public static Class&lt;?&gt; determineCommonAncestor(@Nullable Class&lt;?&gt; clazz1, @Nullable Class&lt;?&gt; clazz2) {
&nbsp;        if (clazz1 == null) {
&nbsp;            return clazz2;
&nbsp;        } else if (clazz2 == null) {
&nbsp;            return clazz1;
&nbsp;        } else if (clazz1.isAssignableFrom(clazz2)) {
<b class="nc">&nbsp;            return clazz1;</b>
<b class="nc">&nbsp;        } else if (clazz2.isAssignableFrom(clazz1)) {</b>
&nbsp;            return clazz2;
&nbsp;        } else {
<b class="nc">&nbsp;            Class&lt;?&gt; ancestor = clazz1;</b>
<b class="nc">&nbsp;</b>
&nbsp;            do {
&nbsp;                ancestor = ancestor.getSuperclass();
&nbsp;                if (ancestor == null || Object.class == ancestor) {
&nbsp;                    return null;
&nbsp;                }
&nbsp;            } while(!ancestor.isAssignableFrom(clazz2));
&nbsp;
<b class="nc">&nbsp;            return ancestor;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isJavaLanguageInterface(Class&lt;?&gt; ifc) {
&nbsp;        return javaLanguageInterfaces.contains(ifc);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isStaticClass(Class&lt;?&gt; clazz) {
&nbsp;        return Modifier.isStatic(clazz.getModifiers());
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static boolean isInnerClass(Class&lt;?&gt; clazz) {
<b class="nc">&nbsp;        return clazz.isMemberClass() &amp;&amp; !isStaticClass(clazz);</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static boolean isLambdaClass(Class&lt;?&gt; clazz) {</b>
&nbsp;        return clazz.isSynthetic() &amp;&amp; clazz.getSuperclass() == Object.class &amp;&amp; clazz.getInterfaces().length &gt; 0 &amp;&amp; clazz.getName().contains(&quot;$$Lambda&quot;);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    /** @deprecated */
&nbsp;    @Deprecated
<b class="nc">&nbsp;    public static boolean isCglibProxy(Object object) {</b>
<b class="nc">&nbsp;        return isCglibProxyClass(object.getClass());</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /** @deprecated */</b>
&nbsp;    @Deprecated
&nbsp;    public static boolean isCglibProxyClass(@Nullable Class&lt;?&gt; clazz) {
&nbsp;        return clazz != null &amp;&amp; isCglibProxyClassName(clazz.getName());
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    /** @deprecated */</b>
<b class="nc">&nbsp;    @Deprecated</b>
&nbsp;    public static boolean isCglibProxyClassName(@Nullable String className) {
&nbsp;        return className != null &amp;&amp; className.contains(&quot;$$&quot;);
&nbsp;    }
&nbsp;
&nbsp;    public static Class&lt;?&gt; getUserClass(Object instance) {
&nbsp;        Assert.notNull(instance, &quot;Instance must not be null&quot;);
&nbsp;        return getUserClass(instance.getClass());
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Class&lt;?&gt; getUserClass(Class&lt;?&gt; clazz) {</b>
&nbsp;        if (clazz.getName().contains(&quot;$$&quot;)) {
&nbsp;            Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;            if (superclass != null &amp;&amp; superclass != Object.class) {
&nbsp;                return superclass;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return clazz;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Nullable</b>
&nbsp;    public static String getDescriptiveType(@Nullable Object value) {
&nbsp;        if (value == null) {
&nbsp;            return null;
&nbsp;        } else {
<b class="nc">&nbsp;            Class&lt;?&gt; clazz = value.getClass();</b>
&nbsp;            if (!Proxy.isProxyClass(clazz)) {
&nbsp;                return clazz.getTypeName();
&nbsp;            } else {
&nbsp;                String prefix = clazz.getTypeName() + &quot; implementing &quot;;
&nbsp;                StringJoiner result = new StringJoiner(&quot;,&quot;, prefix, &quot;&quot;);
&nbsp;
&nbsp;                for(Class&lt;?&gt; ifc : clazz.getInterfaces()) {
&nbsp;                    result.add(ifc.getTypeName());
&nbsp;                }
&nbsp;
&nbsp;                return result.toString();
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public static boolean matchesTypeName(Class&lt;?&gt; clazz, @Nullable String typeName) {</b>
&nbsp;        return typeName != null &amp;&amp; (typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName()));
&nbsp;    }
<b class="pc">&nbsp;</b>
&nbsp;    public static String getShortName(String className) {
<b class="nc">&nbsp;        Assert.hasLength(className, &quot;Class name must not be empty&quot;);</b>
&nbsp;        int lastDotIndex = className.lastIndexOf(46);
<b class="fc">&nbsp;        int nameEndIndex = className.indexOf(&quot;$$&quot;);</b>
&nbsp;        if (nameEndIndex == -1) {
&nbsp;            nameEndIndex = className.length();
&nbsp;        }
&nbsp;
&nbsp;        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);
&nbsp;        shortName = shortName.replace(&#39;$&#39;, &#39;.&#39;);
&nbsp;        return shortName;
&nbsp;    }
&nbsp;
&nbsp;    public static String getShortName(Class&lt;?&gt; clazz) {
<b class="nc">&nbsp;        return getShortName(getQualifiedName(clazz));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static String getShortNameAsProperty(Class&lt;?&gt; clazz) {
&nbsp;        String shortName = getShortName(clazz);
&nbsp;        int dotIndex = shortName.lastIndexOf(46);
&nbsp;        shortName = dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName;
&nbsp;        return StringUtils.uncapitalizeAsProperty(shortName);
&nbsp;    }
&nbsp;
&nbsp;    public static String getClassFileName(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        String className = clazz.getName();
&nbsp;        int lastDotIndex = className.lastIndexOf(46);
<b class="nc">&nbsp;        String var10000 = className.substring(lastDotIndex + 1);</b>
<b class="nc">&nbsp;        return var10000 + &quot;.class&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String getPackageName(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return getPackageName(clazz.getName());
&nbsp;    }
&nbsp;
&nbsp;    public static String getPackageName(String fqClassName) {
&nbsp;        Assert.notNull(fqClassName, &quot;Class name must not be null&quot;);
<b class="nc">&nbsp;        int lastDotIndex = fqClassName.lastIndexOf(46);</b>
<b class="nc">&nbsp;        return lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    public static String getQualifiedName(Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return clazz.getTypeName();
&nbsp;    }
&nbsp;
&nbsp;    public static String getQualifiedMethodName(Method method) {
&nbsp;        return getQualifiedMethodName(method, (Class)null);
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public static String getQualifiedMethodName(Method method, @Nullable Class&lt;?&gt; clazz) {
&nbsp;        Assert.notNull(method, &quot;Method must not be null&quot;);
&nbsp;        String var10000 = (clazz != null ? clazz : method.getDeclaringClass()).getName();
&nbsp;        return var10000 + &quot;.&quot; + method.getName();
&nbsp;    }
&nbsp;
&nbsp;    public static boolean hasConstructor(Class&lt;?&gt; clazz, Class&lt;?&gt;... paramTypes) {
&nbsp;        return getConstructorIfAvailable(clazz, paramTypes) != null;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Nullable</b>
<b class="nc">&nbsp;    public static &lt;T&gt; Constructor&lt;T&gt; getConstructorIfAvailable(Class&lt;T&gt; clazz, Class&lt;?&gt;... paramTypes) {</b>
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            return clazz.getConstructor(paramTypes);
&nbsp;        } catch (NoSuchMethodException var3) {
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean hasMethod(Class&lt;?&gt; clazz, Method method) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
<b class="nc">&nbsp;        Assert.notNull(method, &quot;Method must not be null&quot;);</b>
&nbsp;        if (clazz == method.getDeclaringClass()) {
&nbsp;            return true;
&nbsp;        } else {
&nbsp;            String methodName = method.getName();
&nbsp;            Class&lt;?&gt;[] paramTypes = method.getParameterTypes();
&nbsp;            return getMethodOrNull(clazz, methodName, paramTypes) != null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean hasMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... paramTypes) {
&nbsp;        return getMethodIfAvailable(clazz, methodName, paramTypes) != null;
&nbsp;    }
&nbsp;
&nbsp;    public static Method getMethod(Class&lt;?&gt; clazz, String methodName, @Nullable Class&lt;?&gt;... paramTypes) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Assert.notNull(methodName, &quot;Method name must not be null&quot;);
&nbsp;        if (paramTypes != null) {
&nbsp;            try {
<b class="nc">&nbsp;                return clazz.getMethod(methodName, paramTypes);</b>
<b class="nc">&nbsp;            } catch (NoSuchMethodException ex) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Expected method not found: &quot; + String.valueOf(ex));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Set&lt;Method&gt; candidates = findMethodCandidatesByName(clazz, methodName);</b>
<b class="nc">&nbsp;            if (candidates.size() == 1) {</b>
<b class="nc">&nbsp;                return (Method)candidates.iterator().next();</b>
<b class="nc">&nbsp;            } else if (candidates.isEmpty()) {</b>
<b class="nc">&nbsp;                String var5 = clazz.getName();</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Expected method not found: &quot; + var5 + &quot;.&quot; + methodName);</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                String var10002 = clazz.getName();</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;No unique method found: &quot; + var10002 + &quot;.&quot; + methodName);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public static Method getMethodIfAvailable(Class&lt;?&gt; clazz, String methodName, @Nullable Class&lt;?&gt;... paramTypes) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Assert.notNull(methodName, &quot;Method name must not be null&quot;);
&nbsp;        if (paramTypes != null) {
&nbsp;            return getMethodOrNull(clazz, methodName, paramTypes);
&nbsp;        } else {
&nbsp;            Set&lt;Method&gt; candidates = findMethodCandidatesByName(clazz, methodName);
&nbsp;            return candidates.size() == 1 ? (Method)candidates.iterator().next() : null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static int getMethodCountForName(Class&lt;?&gt; clazz, String methodName) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Assert.notNull(methodName, &quot;Method name must not be null&quot;);
<b class="nc">&nbsp;        int count = 0;</b>
<b class="nc">&nbsp;        Method[] declaredMethods = clazz.getDeclaredMethods();</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        for(Method method : declaredMethods) {</b>
&nbsp;            if (methodName.equals(method.getName())) {
<b class="nc">&nbsp;                ++count;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        Class&lt;?&gt;[] ifcs = clazz.getInterfaces();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        for(Class&lt;?&gt; ifc : ifcs) {</b>
&nbsp;            count += getMethodCountForName(ifc, methodName);
&nbsp;        }
&nbsp;
&nbsp;        if (clazz.getSuperclass() != null) {
&nbsp;            count += getMethodCountForName(clazz.getSuperclass(), methodName);
&nbsp;        }
&nbsp;
&nbsp;        return count;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean hasAtLeastOneMethodWithName(Class&lt;?&gt; clazz, String methodName) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
<b class="nc">&nbsp;        Assert.notNull(methodName, &quot;Method name must not be null&quot;);</b>
<b class="nc">&nbsp;        Method[] declaredMethods = clazz.getDeclaredMethods();</b>
&nbsp;
&nbsp;        for(Method method : declaredMethods) {
&nbsp;            if (method.getName().equals(methodName)) {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        Class&lt;?&gt;[] ifcs = clazz.getInterfaces();
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        for(Class&lt;?&gt; ifc : ifcs) {</b>
&nbsp;            if (hasAtLeastOneMethodWithName(ifc, methodName)) {
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return clazz.getSuperclass() != null &amp;&amp; hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Method getMostSpecificMethod(Method method, @Nullable Class&lt;?&gt; targetClass) {</b>
<b class="nc">&nbsp;        if (targetClass != null &amp;&amp; targetClass != method.getDeclaringClass() &amp;&amp; (isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {</b>
&nbsp;            try {
&nbsp;                if (Modifier.isPublic(method.getModifiers())) {
&nbsp;                    try {
&nbsp;                        return targetClass.getMethod(method.getName(), method.getParameterTypes());
&nbsp;                    } catch (NoSuchMethodException var3) {
&nbsp;                        return method;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());
&nbsp;                return specificMethod != null ? specificMethod : method;
&nbsp;            } catch (SecurityException var4) {
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return method;
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
<b class="nc">&nbsp;    @Deprecated</b>
<b class="nc">&nbsp;    public static Method getInterfaceMethodIfPossible(Method method) {</b>
<b class="nc">&nbsp;        return getInterfaceMethodIfPossible(method, (Class)null);</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static Method getInterfaceMethodIfPossible(Method method, @Nullable Class&lt;?&gt; targetClass) {
&nbsp;        return getInterfaceMethodIfPossible(method, targetClass, false);
&nbsp;    }
&nbsp;
&nbsp;    private static Method getInterfaceMethodIfPossible(Method method, @Nullable Class&lt;?&gt; targetClass, boolean requirePublicInterface) {
&nbsp;        Class&lt;?&gt; declaringClass = method.getDeclaringClass();
&nbsp;        if (Modifier.isPublic(method.getModifiers()) &amp;&amp; (!declaringClass.isInterface() || requirePublicInterface &amp;&amp; !Modifier.isPublic(declaringClass.getModifiers()))) {
&nbsp;            String methodName = method.getName();
&nbsp;            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
&nbsp;            Map&lt;Method, Method&gt; methodCache = requirePublicInterface ? publicInterfaceMethodCache : interfaceMethodCache;
&nbsp;            Method result = (Method)methodCache.computeIfAbsent(method, (key) -&gt; findInterfaceMethodIfPossible(methodName, parameterTypes, declaringClass, Object.class, requirePublicInterface));
&nbsp;            if (result == null &amp;&amp; targetClass != null) {
&nbsp;                result = findInterfaceMethodIfPossible(methodName, parameterTypes, targetClass, declaringClass, requirePublicInterface);
&nbsp;            }
&nbsp;
&nbsp;            return result != null ? result : method;
&nbsp;        } else {
<b class="nc">&nbsp;            return method;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @Nullable</b>
<b class="nc">&nbsp;    private static Method findInterfaceMethodIfPossible(String methodName, Class&lt;?&gt;[] parameterTypes, Class&lt;?&gt; startClass, Class&lt;?&gt; endClass, boolean requirePublicInterface) {</b>
<b class="nc">&nbsp;        for(Class&lt;?&gt; current = startClass; current != null &amp;&amp; current != endClass; current = current.getSuperclass()) {</b>
&nbsp;            for(Class&lt;?&gt; ifc : current.getInterfaces()) {
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    if (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {</b>
&nbsp;                        return ifc.getMethod(methodName, parameterTypes);
&nbsp;                    }
&nbsp;                } catch (NoSuchMethodException var11) {
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return null;
&nbsp;    }
&nbsp;
&nbsp;    public static Method getPubliclyAccessibleMethodIfPossible(Method method, @Nullable Class&lt;?&gt; targetClass) {
&nbsp;        Class&lt;?&gt; declaringClass = method.getDeclaringClass();
<b class="nc">&nbsp;        if (Modifier.isPublic(method.getModifiers()) &amp;&amp; !Modifier.isPublic(declaringClass.getModifiers())) {</b>
&nbsp;            Method interfaceMethod = getInterfaceMethodIfPossible(method, targetClass, true);
&nbsp;            if (!interfaceMethod.equals(method)) {
&nbsp;                return interfaceMethod;
&nbsp;            } else {
&nbsp;                Method result = (Method)publiclyAccessibleMethodCache.computeIfAbsent(method, (key) -&gt; findPubliclyAccessibleMethodIfPossible(key.getName(), key.getParameterTypes(), declaringClass));
&nbsp;                return result != null ? result : method;
&nbsp;            }
&nbsp;        } else {
&nbsp;            return method;
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Nullable</b>
<b class="nc">&nbsp;    private static Method findPubliclyAccessibleMethodIfPossible(String methodName, Class&lt;?&gt;[] parameterTypes, Class&lt;?&gt; declaringClass) {</b>
&nbsp;        for(Class&lt;?&gt; current = declaringClass.getSuperclass(); current != null; current = current.getSuperclass()) {
<b class="nc">&nbsp;            if (Modifier.isPublic(current.getModifiers())) {</b>
<b class="nc">&nbsp;                try {</b>
<b class="nc">&nbsp;                    return current.getDeclaredMethod(methodName, parameterTypes);</b>
&nbsp;                } catch (NoSuchMethodException var5) {
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return null;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isUserLevelMethod(Method method) {
&nbsp;        Assert.notNull(method, &quot;Method must not be null&quot;);
&nbsp;        return method.isBridge() || !method.isSynthetic() &amp;&amp; !isGroovyObjectMethod(method);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private static boolean isGroovyObjectMethod(Method method) {</b>
&nbsp;        return method.getDeclaringClass().getName().equals(&quot;groovy.lang.GroovyObject&quot;);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isOverridable(Method method, @Nullable Class&lt;?&gt; targetClass) {
&nbsp;        if ((method.getModifiers() &amp; 26) != 0) {
&nbsp;            return false;
&nbsp;        } else if ((method.getModifiers() &amp; 5) != 0) {
&nbsp;            return true;
&nbsp;        } else {
<b class="nc">&nbsp;            return targetClass == null || getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public static Method getStaticMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... args) {
&nbsp;        Assert.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Assert.notNull(methodName, &quot;Method name must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            Method method = clazz.getMethod(methodName, args);
&nbsp;            return Modifier.isStatic(method.getModifiers()) ? method : null;
<b class="nc">&nbsp;        } catch (NoSuchMethodException var4) {</b>
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    private static Method getMethodOrNull(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;[] paramTypes) {
&nbsp;        try {
&nbsp;            return clazz.getMethod(methodName, paramTypes);
&nbsp;        } catch (NoSuchMethodException var4) {
&nbsp;            return null;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private static Set&lt;Method&gt; findMethodCandidatesByName(Class&lt;?&gt; clazz, String methodName) {
&nbsp;        Set&lt;Method&gt; candidates = new HashSet(1);
&nbsp;        Method[] methods = clazz.getMethods();
&nbsp;
&nbsp;        for(Method method : methods) {
&nbsp;            if (methodName.equals(method.getName())) {
&nbsp;                candidates.add(method);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        return candidates;</b>
&nbsp;    }
&nbsp;
&nbsp;    static {
&nbsp;        primitiveWrapperTypeMap.put(Boolean.class, Boolean.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Byte.class, Byte.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Character.class, Character.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Double.class, Double.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Float.class, Float.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Integer.class, Integer.TYPE);
&nbsp;        primitiveWrapperTypeMap.put(Long.class, Long.TYPE);
<b class="nc">&nbsp;        primitiveWrapperTypeMap.put(Short.class, Short.TYPE);</b>
&nbsp;        primitiveWrapperTypeMap.put(Void.class, Void.TYPE);
&nbsp;
&nbsp;        for(Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry : primitiveWrapperTypeMap.entrySet()) {
&nbsp;            primitiveTypeToWrapperMap.put((Class)entry.getValue(), (Class)entry.getKey());
&nbsp;            registerCommonClasses((Class)entry.getKey());
&nbsp;        }
&nbsp;
&nbsp;        Set&lt;Class&lt;?&gt;&gt; primitiveTypes = new HashSet(32);
&nbsp;        primitiveTypes.addAll(primitiveWrapperTypeMap.values());
&nbsp;        Collections.addAll(primitiveTypes, new Class[]{boolean[].class, byte[].class, char[].class, double[].class, float[].class, int[].class, long[].class, short[].class});
&nbsp;
&nbsp;        for(Class&lt;?&gt; primitiveType : primitiveTypes) {
<b class="nc">&nbsp;            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class, Float[].class, Integer[].class, Long[].class, Short[].class);
<b class="nc">&nbsp;        registerCommonClasses(Number.class, Number[].class, String.class, String[].class, Class.class, Class[].class, Object.class, Object[].class);</b>
<b class="nc">&nbsp;        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class, Error.class, StackTraceElement.class, StackTraceElement[].class);</b>
<b class="nc">&nbsp;        registerCommonClasses(Enum.class, Iterable.class, Iterator.class, Enumeration.class, Collection.class, List.class, Set.class, Map.class, Map.Entry.class, Optional.class);</b>
<b class="nc">&nbsp;        Class&lt;?&gt;[] javaLanguageInterfaceArray = new Class[]{Serializable.class, Externalizable.class, Closeable.class, AutoCloseable.class, Cloneable.class, Comparable.class};</b>
<b class="nc">&nbsp;        registerCommonClasses(javaLanguageInterfaceArray);</b>
<b class="nc">&nbsp;        javaLanguageInterfaces = Set.of(javaLanguageInterfaceArray);</b>
<b class="nc">&nbsp;    }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
