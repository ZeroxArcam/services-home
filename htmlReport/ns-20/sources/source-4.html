


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MethodGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: MethodGraph (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MethodGraph$Compiler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.8%
  </span>
  <span class="absValue">
    (11/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85%
  </span>
  <span class="absValue">
    (34/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod$Token</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Detached</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Harmonized</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.7%
  </span>
  <span class="absValue">
    (21/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (21/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (36/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Initial</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (4/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    14.3%
  </span>
  <span class="absValue">
    (2/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.9%
  </span>
  <span class="absValue">
    (15/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Graph</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$Directional</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$ForDeclaredMethods</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Empty</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (2/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$Delegation</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Simple</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Sort</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Simple</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    64.6%
  </span>
  <span class="absValue">
    (73/113)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.4%
  </span>
  <span class="absValue">
    (49/108)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    67.1%
  </span>
  <span class="absValue">
    (196/292)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.Visitor.Reifying;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.matcher.FilterableList;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public interface MethodGraph {
&nbsp;    Node locate(MethodDescription.SignatureToken var1);
&nbsp;
&nbsp;    NodeList listNodes();
&nbsp;
&nbsp;    public static enum Empty implements Linked, Compiler {
&nbsp;        INSTANCE;
&nbsp;
&nbsp;        private Empty() {
&nbsp;        }
&nbsp;
&nbsp;        public Node locate(MethodDescription.SignatureToken token) {
&nbsp;            return MethodGraph.Node.Unresolved.INSTANCE;
&nbsp;        }
&nbsp;
&nbsp;        public NodeList listNodes() {
&nbsp;            return new NodeList(Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public MethodGraph getSuperClassGraph() {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
&nbsp;            return this;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Linked compile(TypeDefinition typeDefinition) {
&nbsp;            return this;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
&nbsp;        public Linked compile(TypeDescription typeDescription) {
&nbsp;            return this;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
&nbsp;            return this;
&nbsp;        }
&nbsp;
&nbsp;        /** @deprecated */
&nbsp;        @Deprecated
<b class="nc">&nbsp;        public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {</b>
&nbsp;            return this;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @SuppressFBWarnings(
&nbsp;        value = {&quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;},
<b class="nc">&nbsp;        justification = &quot;Safe initialization is implied.&quot;</b>
&nbsp;    )
&nbsp;    public interface Compiler {
&nbsp;        Compiler DEFAULT = MethodGraph.Compiler.Default.forJavaHierarchy();
&nbsp;
&nbsp;        Linked compile(TypeDefinition var1);
&nbsp;
<b class="nc">&nbsp;        /** @deprecated */</b>
&nbsp;        @Deprecated
&nbsp;        Linked compile(TypeDescription var1);
&nbsp;
&nbsp;        Linked compile(TypeDefinition var1, TypeDescription var2);
&nbsp;
&nbsp;        /** @deprecated */
<b class="nc">&nbsp;        @Deprecated</b>
&nbsp;        Linked compile(TypeDescription var1, TypeDescription var2);
&nbsp;
&nbsp;        public static enum ForDeclaredMethods implements Compiler {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private ForDeclaredMethods() {
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            public Linked compile(TypeDefinition typeDefinition) {
&nbsp;                return this.compile(typeDefinition, typeDefinition.asErasure());
&nbsp;            }
&nbsp;
&nbsp;            /** @deprecated */
&nbsp;            @Deprecated
<b class="nc">&nbsp;            public Linked compile(TypeDescription typeDescription) {</b>
&nbsp;                return this.compile((TypeDefinition)typeDescription, typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
&nbsp;                LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes = new LinkedHashMap();
&nbsp;
&nbsp;                for(MethodDescription methodDescription : (MethodList)typeDefinition.getDeclaredMethods().filter(ElementMatchers.isVirtual().and(ElementMatchers.not(ElementMatchers.isBridge())).and(ElementMatchers.isVisibleTo(viewPoint)))) {
<b class="nc">&nbsp;                    nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));</b>
&nbsp;                }
&nbsp;
&nbsp;                return new Linked.Delegation(new Simple(nodes), MethodGraph.Empty.INSTANCE, Collections.emptyMap());
&nbsp;            }
&nbsp;
&nbsp;            /** @deprecated */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
&nbsp;                return this.compile((TypeDefinition)typeDefinition, viewPoint);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public abstract static class AbstractBase implements Compiler {
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public Linked compile(TypeDefinition typeDefinition) {
&nbsp;                return this.compile(typeDefinition, typeDefinition.asErasure());
&nbsp;            }
&nbsp;
&nbsp;            /** @deprecated */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDescription) {
&nbsp;                return this.compile(typeDescription, typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            /** @deprecated */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
&nbsp;                return this.compile(typeDefinition, viewPoint);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Default&lt;T&gt; extends AbstractBase {
&nbsp;            private final Harmonizer&lt;T&gt; harmonizer;
&nbsp;            private final Merger merger;
&nbsp;            private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            protected Default(Harmonizer&lt;T&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                this(harmonizer, merger, visitor, ElementMatchers.any());
&nbsp;            }
&nbsp;
&nbsp;            public Default(Harmonizer&lt;T&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor, ElementMatcher&lt;? super MethodDescription&gt; matcher) {
&nbsp;                this.harmonizer = harmonizer;
&nbsp;                this.merger = merger;
&nbsp;                this.visitor = visitor;
&nbsp;                this.matcher = matcher;
&nbsp;            }
&nbsp;
&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger) {
<b class="fc">&nbsp;                return new Default(harmonizer, merger, Reifying.INITIATING);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger, ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
&nbsp;                return new Default(harmonizer, merger, Reifying.INITIATING, matcher);
&nbsp;            }
&nbsp;
&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
&nbsp;                return new Default(harmonizer, merger, visitor);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public static Compiler forJavaHierarchy() {
&nbsp;                return of(MethodGraph.Compiler.Default.Harmonizer.ForJavaMethod.INSTANCE, MethodGraph.Compiler.Default.Merger.Directional.LEFT);
&nbsp;            }
&nbsp;
&nbsp;            public static Compiler forJVMHierarchy() {
&nbsp;                return of(MethodGraph.Compiler.Default.Harmonizer.ForJVMMethod.INSTANCE, MethodGraph.Compiler.Default.Merger.Directional.LEFT);
<b class="fc">&nbsp;            }</b>
<b class="pc">&nbsp;</b>
&nbsp;            public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
&nbsp;                Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots = new HashMap();
&nbsp;                Key.Store&lt;?&gt; rootStore = this.doAnalyze(typeDefinition, snapshots, ElementMatchers.isVirtual().and(ElementMatchers.isVisibleTo(viewPoint)).and(this.matcher));
&nbsp;                TypeDescription.Generic superClass = typeDefinition.getSuperClass();
&nbsp;                List&lt;TypeDescription.Generic&gt; interfaceTypes = typeDefinition.getInterfaces();
&nbsp;                Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs = new HashMap();
&nbsp;
&nbsp;                for(TypeDescription.Generic interfaceType : interfaceTypes) {
<b class="nc">&nbsp;                    Key.Store&lt;T&gt; store = (Key.Store)snapshots.get(interfaceType);</b>
&nbsp;                    if (store == null) {
&nbsp;                        throw new IllegalStateException(&quot;Failed to resolve interface type &quot; + interfaceType + &quot; from &quot; + snapshots.keySet());
&nbsp;                    }
&nbsp;
&nbsp;                    interfaceGraphs.put(interfaceType.asErasure(), store.asGraph(this.merger));
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                Key.Store&lt;T&gt; store;
&nbsp;                if (superClass == null) {
&nbsp;                    store = null;
&nbsp;                } else {
&nbsp;                    store = (Key.Store)snapshots.get(superClass);
&nbsp;                    if (store == null) {
&nbsp;                        throw new IllegalStateException(&quot;Failed to resolve super class &quot; + superClass + &quot; from &quot; + snapshots.keySet());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return new Linked.Delegation(rootStore.asGraph(this.merger), (MethodGraph)(store == null ? MethodGraph.Empty.INSTANCE : store.asGraph(this.merger)), interfaceGraphs);
&nbsp;            }
&nbsp;
&nbsp;            protected Key.Store&lt;T&gt; analyze(TypeDefinition typeDefinition, TypeDefinition key, Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots, ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
&nbsp;                Key.Store&lt;T&gt; store = (Key.Store)snapshots.get(key);
&nbsp;                if (store == null) {
&nbsp;                    store = this.doAnalyze(typeDefinition, snapshots, relevanceMatcher);
&nbsp;                    snapshots.put(key, store);
&nbsp;                }
&nbsp;
&nbsp;                return store;
&nbsp;            }
&nbsp;
&nbsp;            protected Key.Store&lt;T&gt; analyzeNullable(@MaybeNull TypeDescription.Generic typeDescription, Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots, ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
&nbsp;                return typeDescription == null ? new Key.Store() : this.analyze((TypeDefinition)typeDescription.accept(this.visitor), typeDescription, snapshots, relevanceMatcher);
&nbsp;            }
&nbsp;
&nbsp;            protected Key.Store&lt;T&gt; doAnalyze(TypeDefinition typeDefinition, Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots, ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
&nbsp;                Key.Store&lt;T&gt; store = this.analyzeNullable(typeDefinition.getSuperClass(), snapshots, relevanceMatcher);
&nbsp;                Key.Store&lt;T&gt; interfaceStore = new Key.Store&lt;T&gt;();
&nbsp;
&nbsp;                for(TypeDescription.Generic interfaceType : typeDefinition.getInterfaces()) {
&nbsp;                    interfaceStore = interfaceStore.combineWith(this.analyze((TypeDefinition)interfaceType.accept(this.visitor), interfaceType, snapshots, relevanceMatcher));
&nbsp;                }
&nbsp;
&nbsp;                return store.inject(interfaceStore).registerTopLevel(typeDefinition.getDeclaredMethods().filter(relevanceMatcher), this.harmonizer);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
<b class="fc">&nbsp;                } else if (var1 == null) {</b>
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.harmonizer.equals(((Default)var1).harmonizer)) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (!this.merger.equals(((Default)var1).merger)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.visitor.equals(((Default)var1).visitor)) {
&nbsp;                    return false;
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    return this.matcher.equals(((Default)var1).matcher);
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public int hashCode() {</b>
&nbsp;                return (((this.getClass().hashCode() * 31 + this.harmonizer.hashCode()) * 31 + this.merger.hashCode()) * 31 + this.visitor.hashCode()) * 31 + this.matcher.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class Key&lt;S&gt; {
<b class="fc">&nbsp;                protected final String internalName;</b>
&nbsp;                protected final int parameterCount;
&nbsp;
&nbsp;                protected Key(String internalName, int parameterCount) {
&nbsp;                    this.internalName = internalName;
&nbsp;                    this.parameterCount = parameterCount;
&nbsp;                }
&nbsp;
&nbsp;                protected abstract Set&lt;S&gt; getIdentifiers();
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.internalName.hashCode() + 31 * this.parameterCount;
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object other) {
&nbsp;                    if (this == other) {
&nbsp;                        return true;
&nbsp;                    } else if (!(other instanceof Key)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        Key&lt;?&gt; key = (Key)other;
&nbsp;                        return this.internalName.equals(key.internalName) &amp;&amp; this.parameterCount == key.parameterCount &amp;&amp; !Collections.disjoint(this.getIdentifiers(), key.getIdentifiers());
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                protected static class Harmonized&lt;V&gt; extends Key&lt;V&gt; {</b>
<b class="fc">&nbsp;                    private final Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers;</b>
<b class="fc">&nbsp;</b>
&nbsp;                    protected Harmonized(String internalName, int parameterCount, Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers) {
&nbsp;                        super(internalName, parameterCount);
&nbsp;                        this.identifiers = identifiers;
&nbsp;                    }
&nbsp;
&nbsp;                    protected static &lt;Q&gt; Harmonized&lt;Q&gt; of(MethodDescription methodDescription, Harmonizer&lt;Q&gt; harmonizer) {
&nbsp;                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();
&nbsp;                        return new Harmonized&lt;Q&gt;(methodDescription.getInternalName(), methodDescription.getParameters().size(), Collections.singletonMap(harmonizer.harmonize(typeToken), Collections.emptySet()));
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected Detached detach(MethodDescription.TypeToken typeToken) {
&nbsp;                        Set&lt;MethodDescription.TypeToken&gt; identifiers = new HashSet();
&nbsp;
&nbsp;                        for(Set&lt;MethodDescription.TypeToken&gt; typeTokens : this.identifiers.values()) {
&nbsp;                            identifiers.addAll(typeTokens);
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        identifiers.add(typeToken);</b>
&nbsp;                        return new Detached(this.internalName, this.parameterCount, identifiers);
&nbsp;                    }
&nbsp;
&nbsp;                    protected Harmonized&lt;V&gt; combineWith(Harmonized&lt;V&gt; key) {
&nbsp;                        Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers = new HashMap(this.identifiers);
&nbsp;
&nbsp;                        for(Map.Entry&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; entry : key.identifiers.entrySet()) {
&nbsp;                            Set&lt;MethodDescription.TypeToken&gt; typeTokens = (Set)identifiers.get(entry.getKey());
<b class="fc">&nbsp;                            if (typeTokens == null) {</b>
&nbsp;                                identifiers.put(entry.getKey(), entry.getValue());
&nbsp;                            } else {
&nbsp;                                typeTokens = new HashSet(typeTokens);
&nbsp;                                typeTokens.addAll((Collection)entry.getValue());
&nbsp;                                identifiers.put(entry.getKey(), typeTokens);
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        return new Harmonized&lt;V&gt;(this.internalName, this.parameterCount, identifiers);
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    protected Harmonized&lt;V&gt; extend(MethodDescription.InDefinedShape methodDescription, Harmonizer&lt;V&gt; harmonizer) {</b>
&nbsp;                        Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers = new HashMap(this.identifiers);
&nbsp;                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();
&nbsp;                        V identifier = harmonizer.harmonize(typeToken);
&nbsp;                        Set&lt;MethodDescription.TypeToken&gt; typeTokens = (Set)identifiers.get(identifier);
&nbsp;                        if (typeTokens == null) {
<b class="fc">&nbsp;                            identifiers.put(identifier, Collections.singleton(typeToken));</b>
&nbsp;                        } else {
&nbsp;                            typeTokens = new HashSet(typeTokens);
&nbsp;                            typeTokens.add(typeToken);
&nbsp;                            identifiers.put(identifier, typeTokens);
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        return new Harmonized&lt;V&gt;(this.internalName, this.parameterCount, identifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    protected Set&lt;V&gt; getIdentifiers() {
&nbsp;                        return this.identifiers.keySet();
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                protected static class Detached extends Key&lt;MethodDescription.TypeToken&gt; {
&nbsp;                    private final Set&lt;MethodDescription.TypeToken&gt; identifiers;
&nbsp;
&nbsp;                    protected Detached(String internalName, int parameterCount, Set&lt;MethodDescription.TypeToken&gt; identifiers) {
&nbsp;                        super(internalName, parameterCount);
&nbsp;                        this.identifiers = identifiers;
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected static Detached of(MethodDescription.SignatureToken token) {
&nbsp;                        return new Detached(token.getName(), token.getParameterTypes().size(), Collections.singleton(token.asTypeToken()));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Set&lt;MethodDescription.TypeToken&gt; getIdentifiers() {
&nbsp;                        return this.identifiers;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class Store&lt;V&gt; {
&nbsp;                    private final LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries;
&nbsp;
&nbsp;                    protected Store() {
&nbsp;                        this(new LinkedHashMap());
&nbsp;                    }
&nbsp;
&nbsp;                    private Store(LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries) {
<b class="fc">&nbsp;                        this.entries = entries;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    private static &lt;W&gt; Entry&lt;W&gt; combine(Entry&lt;W&gt; left, Entry&lt;W&gt; right) {
&nbsp;                        Set&lt;MethodDescription&gt; leftMethods = left.getCandidates();
&nbsp;                        Set&lt;MethodDescription&gt; rightMethods = right.getCandidates();
&nbsp;                        LinkedHashSet&lt;MethodDescription&gt; combined = new LinkedHashSet();
&nbsp;                        combined.addAll(leftMethods);
<b class="nc">&nbsp;                        combined.addAll(rightMethods);</b>
&nbsp;
&nbsp;                        for(MethodDescription leftMethod : leftMethods) {
&nbsp;                            TypeDescription leftType = leftMethod.getDeclaringType().asErasure();
&nbsp;
&nbsp;                            for(MethodDescription rightMethod : rightMethods) {
&nbsp;                                TypeDescription rightType = rightMethod.getDeclaringType().asErasure();
<b class="fc">&nbsp;                                if (leftType.equals(rightType)) {</b>
&nbsp;                                    break;
&nbsp;                                }
&nbsp;
&nbsp;                                if (leftType.isAssignableTo(rightType)) {
&nbsp;                                    combined.remove(rightMethod);
&nbsp;                                    break;
<b class="fc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                if (leftType.isAssignableFrom(rightType)) {
&nbsp;                                    combined.remove(leftMethod);
&nbsp;                                    break;
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        Harmonized&lt;W&gt; key = left.getKey().combineWith(right.getKey());
&nbsp;                        Visibility visibility = left.getVisibility().expandTo(right.getVisibility());
&nbsp;                        return (Entry&lt;W&gt;)(combined.size() == 1 ? new Entry.Resolved(key, (MethodDescription)combined.iterator().next(), visibility, false) : new Entry.Ambiguous(key, combined, visibility));
&nbsp;                    }
&nbsp;
&nbsp;                    protected Store&lt;V&gt; registerTopLevel(List&lt;? extends MethodDescription&gt; methodDescriptions, Harmonizer&lt;V&gt; harmonizer) {
&nbsp;                        if (methodDescriptions.isEmpty()) {
&nbsp;                            return this;
&nbsp;                        } else {
&nbsp;                            LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap(this.entries);
&nbsp;
&nbsp;                            for(MethodDescription methodDescription : methodDescriptions) {
<b class="fc">&nbsp;                                Harmonized&lt;V&gt; key = MethodGraph.Compiler.Default.Key.Harmonized.&lt;V&gt;of(methodDescription, harmonizer);</b>
&nbsp;                                Entry&lt;V&gt; currentEntry = (Entry)entries.remove(key);
&nbsp;                                Entry&lt;V&gt; extendedEntry = ((Entry)(currentEntry == null ? new Entry.Initial(key) : currentEntry)).extendBy(methodDescription, harmonizer);
&nbsp;                                entries.put(extendedEntry.getKey(), extendedEntry);
&nbsp;                            }
&nbsp;
&nbsp;                            return new Store&lt;V&gt;(entries);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected Store&lt;V&gt; combineWith(Store&lt;V&gt; store) {
&nbsp;                        if (this.entries.isEmpty()) {
&nbsp;                            return store;
&nbsp;                        } else if (store.entries.isEmpty()) {
&nbsp;                            return this;
&nbsp;                        } else {
&nbsp;                            LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap(this.entries);
&nbsp;
&nbsp;                            for(Entry&lt;V&gt; entry : store.entries.values()) {
&nbsp;                                Entry&lt;V&gt; previousEntry = (Entry)entries.remove(entry.getKey());
&nbsp;                                Entry&lt;V&gt; injectedEntry = previousEntry == null ? entry : combine(previousEntry, entry);
&nbsp;                                entries.put(injectedEntry.getKey(), injectedEntry);
&nbsp;                            }
&nbsp;
&nbsp;                            return new Store&lt;V&gt;(entries);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected Store&lt;V&gt; inject(Store&lt;V&gt; store) {
&nbsp;                        if (this.entries.isEmpty()) {
&nbsp;                            return store;
&nbsp;                        } else if (store.entries.isEmpty()) {
&nbsp;                            return this;
&nbsp;                        } else {
&nbsp;                            LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap(this.entries);
&nbsp;
&nbsp;                            for(Entry&lt;V&gt; entry : store.entries.values()) {
&nbsp;                                Entry&lt;V&gt; previous = (Entry)entries.remove(entry.getKey());
&nbsp;                                Entry&lt;V&gt; injectedEntry = previous == null ? entry : previous.inject(entry);
&nbsp;                                entries.put(injectedEntry.getKey(), injectedEntry);
&nbsp;                            }
&nbsp;
&nbsp;                            return new Store&lt;V&gt;(entries);
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    protected MethodGraph asGraph(Merger merger) {
&nbsp;                        LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries = new LinkedHashMap();
<b class="fc">&nbsp;</b>
&nbsp;                        for(Entry&lt;V&gt; entry : this.entries.values()) {
&nbsp;                            Node node = entry.asNode(merger);
&nbsp;                            entries.put(entry.getKey().detach(node.getRepresentative().asTypeToken()), node);
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        return new Graph(entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
<b class="nc">&nbsp;                        } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.entries.equals(((Store)var1).entries);
&nbsp;                        }
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    public int hashCode() {</b>
<b class="fc">&nbsp;                        return this.getClass().hashCode() * 31 + this.entries.hashCode();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    @Enhance</b>
&nbsp;                    protected static class Graph implements MethodGraph {
&nbsp;                        private final LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries;
&nbsp;
&nbsp;                        protected Graph(LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries) {
&nbsp;                            this.entries = entries;
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public Node locate(MethodDescription.SignatureToken token) {</b>
&nbsp;                            Node node = (Node)this.entries.get(MethodGraph.Compiler.Default.Key.Detached.of(token));
&nbsp;                            return (Node)(node == null ? MethodGraph.Node.Unresolved.INSTANCE : node);
&nbsp;                        }
&nbsp;
&nbsp;                        public NodeList listNodes() {
&nbsp;                            return new NodeList(new ArrayList(this.entries.values()));
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object var1) {
&nbsp;                            if (this == var1) {
&nbsp;                                return true;
&nbsp;                            } else if (var1 == null) {
<b class="fc">&nbsp;                                return false;</b>
&nbsp;                            } else if (this.getClass() != var1.getClass()) {
&nbsp;                                return false;
&nbsp;                            } else {
&nbsp;                                return this.entries.equals(((Graph)var1).entries);
&nbsp;                            }
&nbsp;                        }
&nbsp;
<b class="nc">&nbsp;                        public int hashCode() {</b>
&nbsp;                            return this.getClass().hashCode() * 31 + this.entries.hashCode();
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    protected interface Entry&lt;W&gt; {
&nbsp;                        Harmonized&lt;W&gt; getKey();
&nbsp;
<b class="nc">&nbsp;                        Set&lt;MethodDescription&gt; getCandidates();</b>
&nbsp;
&nbsp;                        Visibility getVisibility();
&nbsp;
&nbsp;                        Entry&lt;W&gt; extendBy(MethodDescription var1, Harmonizer&lt;W&gt; var2);
&nbsp;
&nbsp;                        Entry&lt;W&gt; inject(Entry&lt;W&gt; var1);
&nbsp;
&nbsp;                        Node asNode(Merger var1);
&nbsp;
&nbsp;                        public static class Initial&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;
&nbsp;                            protected Initial(Harmonized&lt;U&gt; key) {
&nbsp;                                this.key = key;
&nbsp;                            }
&nbsp;
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
&nbsp;                                throw new IllegalStateException(&quot;Cannot extract key from initial entry:&quot; + this);
&nbsp;                            }
&nbsp;
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
&nbsp;                                throw new IllegalStateException(&quot;Cannot extract method from initial entry:&quot; + this);
&nbsp;                            }
&nbsp;
&nbsp;                            public Visibility getVisibility() {
&nbsp;                                throw new IllegalStateException(&quot;Cannot extract visibility from initial entry:&quot; + this);
&nbsp;                            }
&nbsp;
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
&nbsp;                                return new Resolved&lt;U&gt;(this.key.extend((MethodDescription.InDefinedShape)methodDescription.asDefined(), harmonizer), methodDescription, methodDescription.getVisibility(), false);
&nbsp;                            }
&nbsp;
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot inject into initial entry without a registered method: &quot; + this);
&nbsp;                            }
&nbsp;
&nbsp;                            public Node asNode(Merger merger) {
&nbsp;                                throw new IllegalStateException(&quot;Cannot transform initial entry without a registered method: &quot; + this);
&nbsp;                            }
<b class="fc">&nbsp;</b>
&nbsp;                            public int hashCode() {
&nbsp;                                return this.key.hashCode();
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(@MaybeNull Object other) {
&nbsp;                                if (this == other) {
&nbsp;                                    return true;
&nbsp;                                } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {
&nbsp;                                    Initial&lt;?&gt; initial = (Initial)other;
&nbsp;                                    return this.key.equals(initial.key);
<b class="fc">&nbsp;                                } else {</b>
<b class="fc">&nbsp;                                    return false;</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Resolved&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;                            private static final int MADE_VISIBLE = 5;
&nbsp;                            private static final boolean NOT_MADE_VISIBLE = false;
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;                            private final MethodDescription methodDescription;
&nbsp;                            private final Visibility visibility;
&nbsp;                            private final boolean madeVisible;
&nbsp;
&nbsp;                            protected Resolved(Harmonized&lt;U&gt; key, MethodDescription methodDescription, Visibility visibility) {
<b class="fc">&nbsp;                                this(key, methodDescription, visibility, false);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            protected Resolved(Harmonized&lt;U&gt; key, MethodDescription methodDescription, Visibility visibility, boolean madeVisible) {
&nbsp;                                this.key = key;
&nbsp;                                this.methodDescription = methodDescription;
&nbsp;                                this.visibility = visibility;
&nbsp;                                this.madeVisible = madeVisible;
&nbsp;                            }
&nbsp;
&nbsp;                            private static &lt;V&gt; Entry&lt;V&gt; of(Harmonized&lt;V&gt; key, MethodDescription override, MethodDescription original, Visibility visibility) {
&nbsp;                                visibility = visibility.expandTo(original.getVisibility()).expandTo(override.getVisibility());
&nbsp;                                return override.isBridge() ? new Resolved(key, original, visibility, (original.getDeclaringType().getModifiers() &amp; 5) == 0) : new Resolved(key, override, visibility, false);
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
&nbsp;                                return this.key;
&nbsp;                            }
&nbsp;
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
&nbsp;                                return Collections.singleton(this.methodDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            public Visibility getVisibility() {
&nbsp;                                return this.visibility;
&nbsp;                            }
<b class="nc">&nbsp;</b>
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
&nbsp;                                Harmonized&lt;U&gt; key = this.key.extend((MethodDescription.InDefinedShape)methodDescription.asDefined(), harmonizer);
&nbsp;                                Visibility visibility = this.visibility.expandTo(methodDescription.getVisibility());
&nbsp;                                return methodDescription.getDeclaringType().equals(this.methodDescription.getDeclaringType()) ? MethodGraph.Compiler.Default.Key.Store.Entry.Ambiguous.of(key, methodDescription, this.methodDescription, visibility) : of(key, methodDescription, this.methodDescription, visibility);
&nbsp;                            }
&nbsp;
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
&nbsp;                                if (this.methodDescription.getDeclaringType().isInterface()) {
&nbsp;                                    LinkedHashSet&lt;MethodDescription&gt; candidates = new LinkedHashSet();
&nbsp;                                    candidates.add(this.methodDescription);
&nbsp;                                    TypeDescription target = this.methodDescription.getDeclaringType().asErasure();
&nbsp;
&nbsp;                                    for(MethodDescription methodDescription : entry.getCandidates()) {
&nbsp;                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {
&nbsp;                                            candidates.remove(this.methodDescription);
<b class="fc">&nbsp;                                            candidates.add(methodDescription);</b>
&nbsp;                                        } else if (!methodDescription.getDeclaringType().asErasure().isAssignableFrom(target)) {
&nbsp;                                            candidates.add(methodDescription);
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
&nbsp;                                    return (Entry&lt;U&gt;)(candidates.size() == 1 ? new Resolved(this.key.combineWith(entry.getKey()), (MethodDescription)candidates.iterator().next(), this.visibility.expandTo(entry.getVisibility()), this.madeVisible) : new Ambiguous(this.key.combineWith(entry.getKey()), candidates, this.visibility.expandTo(entry.getVisibility())));
&nbsp;                                } else {
&nbsp;                                    return new Resolved&lt;U&gt;(this.key.combineWith(entry.getKey()), this.methodDescription, this.visibility.expandTo(entry.getVisibility()), this.madeVisible);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public Node asNode(Merger merger) {
&nbsp;                                return new Node(this.key.detach(this.methodDescription.asTypeToken()), this.methodDescription, this.visibility, this.madeVisible);
&nbsp;                            }
&nbsp;
<b class="nc">&nbsp;                            public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
<b class="fc">&nbsp;                                } else if (this.madeVisible != ((Resolved)var1).madeVisible) {</b>
<b class="fc">&nbsp;                                    return false;</b>
<b class="fc">&nbsp;                                } else if (!this.visibility.equals(((Resolved)var1).visibility)) {</b>
<b class="fc">&nbsp;                                    return false;</b>
<b class="fc">&nbsp;                                } else if (!this.key.equals(((Resolved)var1).key)) {</b>
<b class="fc">&nbsp;                                    return false;</b>
<b class="fc">&nbsp;                                } else {</b>
<b class="pc">&nbsp;                                    return this.methodDescription.equals(((Resolved)var1).methodDescription);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
<b class="fc">&nbsp;</b>
&nbsp;                            public int hashCode() {
&nbsp;                                return (((this.getClass().hashCode() * 31 + this.key.hashCode()) * 31 + this.methodDescription.hashCode()) * 31 + this.visibility.hashCode()) * 31 + this.madeVisible;
<b class="pc">&nbsp;                            }</b>
<b class="nc">&nbsp;</b>
&nbsp;                            @Enhance
<b class="fc">&nbsp;                            protected static class Node implements Node {</b>
<b class="pc">&nbsp;                                private final Detached key;</b>
<b class="nc">&nbsp;                                private final MethodDescription methodDescription;</b>
&nbsp;                                private final Visibility visibility;
&nbsp;                                private final boolean visible;
<b class="pc">&nbsp;</b>
&nbsp;                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility, boolean visible) {
&nbsp;                                    this.key = key;
<b class="fc">&nbsp;                                    this.methodDescription = methodDescription;</b>
&nbsp;                                    this.visibility = visibility;
&nbsp;                                    this.visible = visible;
&nbsp;                                }
&nbsp;
&nbsp;                                public Node.Sort getSort() {
&nbsp;                                    return this.visible ? MethodGraph.Node.Sort.VISIBLE : MethodGraph.Node.Sort.RESOLVED;
&nbsp;                                }
&nbsp;
&nbsp;                                public MethodDescription getRepresentative() {
&nbsp;                                    return this.methodDescription;
&nbsp;                                }
&nbsp;
&nbsp;                                public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
&nbsp;                                    return this.key.getIdentifiers();
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                                public Visibility getVisibility() {</b>
<b class="pc">&nbsp;                                    return this.visibility;</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                                public boolean equals(@MaybeNull Object var1) {
<b class="fc">&nbsp;                                    if (this == var1) {</b>
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.visible != ((Node)var1).visible) {
&nbsp;                                        return false;
&nbsp;                                    } else if (!this.visibility.equals(((Node)var1).visibility)) {
&nbsp;                                        return false;
&nbsp;                                    } else if (!this.key.equals(((Node)var1).key)) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.methodDescription.equals(((Node)var1).methodDescription);
<b class="fc">&nbsp;                                    }</b>
&nbsp;                                }
<b class="fc">&nbsp;</b>
&nbsp;                                public int hashCode() {
&nbsp;                                    return (((this.getClass().hashCode() * 31 + this.key.hashCode()) * 31 + this.methodDescription.hashCode()) * 31 + this.visibility.hashCode()) * 31 + this.visible;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @Enhance
&nbsp;                        public static class Ambiguous&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;                            private final LinkedHashSet&lt;MethodDescription&gt; methodDescriptions;
&nbsp;                            private final Visibility visibility;
&nbsp;
&nbsp;                            protected Ambiguous(Harmonized&lt;U&gt; key, LinkedHashSet&lt;MethodDescription&gt; methodDescriptions, Visibility visibility) {
<b class="fc">&nbsp;                                this.key = key;</b>
<b class="fc">&nbsp;                                this.methodDescriptions = methodDescriptions;</b>
<b class="fc">&nbsp;                                this.visibility = visibility;</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;
<b class="fc">&nbsp;                            protected static &lt;Q&gt; Entry&lt;Q&gt; of(Harmonized&lt;Q&gt; key, MethodDescription left, MethodDescription right, Visibility visibility) {</b>
&nbsp;                                visibility = visibility.expandTo(left.getVisibility()).expandTo(right.getVisibility());
&nbsp;                                return (Entry&lt;Q&gt;)(left.isBridge() ^ right.isBridge() ? new Resolved(key, left.isBridge() ? right : left, visibility, false) : new Ambiguous(key, new LinkedHashSet(Arrays.asList(left, right)), visibility));
&nbsp;                            }
&nbsp;
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
&nbsp;                                return this.key;
&nbsp;                            }
&nbsp;
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
&nbsp;                                return this.methodDescriptions;
&nbsp;                            }
&nbsp;
&nbsp;                            public Visibility getVisibility() {
&nbsp;                                return this.visibility;
&nbsp;                            }
&nbsp;
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
&nbsp;                                Harmonized&lt;U&gt; key = this.key.extend((MethodDescription.InDefinedShape)methodDescription.asDefined(), harmonizer);
&nbsp;                                LinkedHashSet&lt;MethodDescription&gt; methodDescriptions = new LinkedHashSet();
&nbsp;                                TypeDescription declaringType = methodDescription.getDeclaringType().asErasure();
&nbsp;                                boolean bridge = methodDescription.isBridge();
<b class="fc">&nbsp;                                Visibility visibility = this.visibility;</b>
&nbsp;
&nbsp;                                for(MethodDescription extendedMethod : this.methodDescriptions) {
&nbsp;                                    if (extendedMethod.getDeclaringType().asErasure().equals(declaringType)) {
&nbsp;                                        if (extendedMethod.isBridge() ^ bridge) {
<b class="fc">&nbsp;                                            methodDescriptions.add(bridge ? extendedMethod : methodDescription);</b>
&nbsp;                                        } else {
&nbsp;                                            methodDescriptions.add(methodDescription);
&nbsp;                                            methodDescriptions.add(extendedMethod);
&nbsp;                                        }
&nbsp;                                    }
<b class="fc">&nbsp;</b>
&nbsp;                                    visibility = visibility.expandTo(extendedMethod.getVisibility());
&nbsp;                                }
&nbsp;
&nbsp;                                if (methodDescriptions.isEmpty()) {
&nbsp;                                    return new Resolved&lt;U&gt;(key, methodDescription, visibility, bridge);
&nbsp;                                } else if (methodDescriptions.size() == 1) {
&nbsp;                                    return new Resolved&lt;U&gt;(key, (MethodDescription)methodDescriptions.iterator().next(), visibility, false);
&nbsp;                                } else {
&nbsp;                                    return new Ambiguous&lt;U&gt;(key, methodDescriptions, visibility);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
&nbsp;                                LinkedHashSet&lt;MethodDescription&gt; methodDescriptions = new LinkedHashSet();
&nbsp;
&nbsp;                                label50:
&nbsp;                                for(MethodDescription methodDescription : this.methodDescriptions) {
&nbsp;                                    TypeDescription target = methodDescription.getDeclaringType().asErasure();
&nbsp;
&nbsp;                                    for(MethodDescription candidate : entry.getCandidates()) {
&nbsp;                                        TypeDescription typeDescription = candidate.getDeclaringType().asErasure();
&nbsp;                                        if (!typeDescription.equals(target) &amp;&amp; typeDescription.isAssignableTo(target)) {
<b class="fc">&nbsp;                                            continue label50;</b>
<b class="fc">&nbsp;                                        }</b>
<b class="fc">&nbsp;                                    }</b>
&nbsp;
&nbsp;                                    methodDescriptions.add(methodDescription);
&nbsp;                                }
&nbsp;
<b class="fc">&nbsp;                                label37:</b>
&nbsp;                                for(MethodDescription candidate : entry.getCandidates()) {
&nbsp;                                    TypeDescription target = candidate.getDeclaringType().asErasure();
&nbsp;
&nbsp;                                    for(MethodDescription methodDescription : this.methodDescriptions) {
<b class="pc">&nbsp;                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {</b>
&nbsp;                                            continue label37;
&nbsp;                                        }
&nbsp;                                    }
&nbsp;
<b class="nc">&nbsp;                                    methodDescriptions.add(candidate);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                return (Entry&lt;U&gt;)(methodDescriptions.size() == 1 ? new Resolved(this.key.combineWith(entry.getKey()), (MethodDescription)methodDescriptions.iterator().next(), this.visibility.expandTo(entry.getVisibility())) : new Ambiguous(this.key.combineWith(entry.getKey()), methodDescriptions, this.visibility.expandTo(entry.getVisibility())));
&nbsp;                            }
&nbsp;
&nbsp;                            public Node asNode(Merger merger) {
&nbsp;                                Iterator&lt;MethodDescription&gt; iterator = this.methodDescriptions.iterator();
&nbsp;
&nbsp;                                MethodDescription methodDescription;
&nbsp;                                for(methodDescription = (MethodDescription)iterator.next(); iterator.hasNext(); methodDescription = merger.merge(methodDescription, (MethodDescription)iterator.next())) {
&nbsp;                                }
&nbsp;
&nbsp;                                return new Node(this.key.detach(methodDescription.asTypeToken()), methodDescription, this.visibility);
&nbsp;                            }
&nbsp;
&nbsp;                            public boolean equals(@MaybeNull Object var1) {
&nbsp;                                if (this == var1) {
&nbsp;                                    return true;
&nbsp;                                } else if (var1 == null) {
&nbsp;                                    return false;
&nbsp;                                } else if (this.getClass() != var1.getClass()) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.visibility.equals(((Ambiguous)var1).visibility)) {
&nbsp;                                    return false;
&nbsp;                                } else if (!this.key.equals(((Ambiguous)var1).key)) {
&nbsp;                                    return false;
&nbsp;                                } else {
&nbsp;                                    return this.methodDescriptions.equals(((Ambiguous)var1).methodDescriptions);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            public int hashCode() {
&nbsp;                                return ((this.getClass().hashCode() * 31 + this.key.hashCode()) * 31 + this.methodDescriptions.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                            }
&nbsp;
&nbsp;                            @Enhance
&nbsp;                            protected static class Node implements Node {
&nbsp;                                private final Detached key;
&nbsp;                                private final MethodDescription methodDescription;
&nbsp;                                private final Visibility visibility;
&nbsp;
&nbsp;                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility) {
&nbsp;                                    this.key = key;
&nbsp;                                    this.methodDescription = methodDescription;
&nbsp;                                    this.visibility = visibility;
&nbsp;                                }
&nbsp;
&nbsp;                                public Node.Sort getSort() {
&nbsp;                                    return MethodGraph.Node.Sort.AMBIGUOUS;
&nbsp;                                }
&nbsp;
&nbsp;                                public MethodDescription getRepresentative() {
&nbsp;                                    return this.methodDescription;
&nbsp;                                }
&nbsp;
&nbsp;                                public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
&nbsp;                                    return this.key.getIdentifiers();
&nbsp;                                }
&nbsp;
&nbsp;                                public Visibility getVisibility() {
&nbsp;                                    return this.visibility;
&nbsp;                                }
&nbsp;
&nbsp;                                public boolean equals(@MaybeNull Object var1) {
&nbsp;                                    if (this == var1) {
&nbsp;                                        return true;
&nbsp;                                    } else if (var1 == null) {
&nbsp;                                        return false;
&nbsp;                                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                                        return false;
&nbsp;                                    } else if (!this.visibility.equals(((Node)var1).visibility)) {
&nbsp;                                        return false;
&nbsp;                                    } else if (!this.key.equals(((Node)var1).key)) {
&nbsp;                                        return false;
&nbsp;                                    } else {
&nbsp;                                        return this.methodDescription.equals(((Node)var1).methodDescription);
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                public int hashCode() {
&nbsp;                                    return ((this.getClass().hashCode() * 31 + this.key.hashCode()) * 31 + this.methodDescription.hashCode()) * 31 + this.visibility.hashCode();
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Harmonizer&lt;S&gt; {
<b class="fc">&nbsp;                S harmonize(MethodDescription.TypeToken var1);</b>
&nbsp;
&nbsp;                public static enum ForJavaMethod implements Harmonizer&lt;Token&gt; {
&nbsp;                    INSTANCE;
&nbsp;
<b class="fc">&nbsp;                    private ForJavaMethod() {</b>
&nbsp;                    }
&nbsp;
&nbsp;                    public Token harmonize(MethodDescription.TypeToken typeToken) {
&nbsp;                        return new Token(typeToken);
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    protected static class Token {
&nbsp;                        private final MethodDescription.TypeToken typeToken;
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        protected Token(MethodDescription.TypeToken typeToken) {
&nbsp;                            this.typeToken = typeToken;
&nbsp;                            this.hashCode = typeToken.getParameterTypes().hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
<b class="fc">&nbsp;                            return this.hashCode;</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object other) {
&nbsp;                            return this == other || other instanceof Token &amp;&amp; this.typeToken.getParameterTypes().equals(((Token)other).typeToken.getParameterTypes());
&nbsp;                        }
&nbsp;
&nbsp;                        public String toString() {
<b class="nc">&nbsp;                            return this.typeToken.getParameterTypes().toString();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public static enum ForJVMMethod implements Harmonizer&lt;Token&gt; {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private ForJVMMethod() {
&nbsp;                    }
&nbsp;
&nbsp;                    public Token harmonize(MethodDescription.TypeToken typeToken) {
&nbsp;                        return new Token(typeToken);
&nbsp;                    }
&nbsp;
&nbsp;                    protected static class Token {
&nbsp;                        private final MethodDescription.TypeToken typeToken;
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        public Token(MethodDescription.TypeToken typeToken) {
&nbsp;                            this.typeToken = typeToken;
&nbsp;                            this.hashCode = typeToken.getReturnType().hashCode() + 31 * typeToken.getParameterTypes().hashCode();
&nbsp;                        }
&nbsp;
&nbsp;                        public int hashCode() {
&nbsp;                            return this.hashCode;
&nbsp;                        }
&nbsp;
&nbsp;                        public boolean equals(@MaybeNull Object other) {
&nbsp;                            if (this == other) {
&nbsp;                                return true;
<b class="fc">&nbsp;                            } else if (!(other instanceof Token)) {</b>
<b class="fc">&nbsp;                                return false;</b>
<b class="fc">&nbsp;                            } else {</b>
&nbsp;                                Token token = (Token)other;
&nbsp;                                return this.typeToken.getReturnType().equals(token.typeToken.getReturnType()) &amp;&amp; this.typeToken.getParameterTypes().equals(token.typeToken.getParameterTypes());
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        public String toString() {
&nbsp;                            return this.typeToken.toString();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public interface Merger {
&nbsp;                MethodDescription merge(MethodDescription var1, MethodDescription var2);
&nbsp;
&nbsp;                public static enum Directional implements Merger {
<b class="pc">&nbsp;                    LEFT(true),</b>
<b class="nc">&nbsp;                    RIGHT(false);</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                    private final boolean left;</b>
&nbsp;
<b class="fc">&nbsp;                    private Directional(boolean left) {</b>
<b class="pc">&nbsp;                        this.left = left;</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
&nbsp;                    public MethodDescription merge(MethodDescription left, MethodDescription right) {
&nbsp;                        return this.left ? left : right;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class NodeList extends FilterableList.AbstractBase&lt;Node, NodeList&gt; {
&nbsp;        private final List&lt;? extends Node&gt; nodes;
&nbsp;
&nbsp;        public NodeList(List&lt;? extends Node&gt; nodes) {
&nbsp;            this.nodes = nodes;
&nbsp;        }
&nbsp;
&nbsp;        public Node get(int index) {
&nbsp;            return (Node)this.nodes.get(index);
&nbsp;        }
&nbsp;
&nbsp;        public int size() {
&nbsp;            return this.nodes.size();
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        protected NodeList wrap(List&lt;Node&gt; values) {</b>
<b class="fc">&nbsp;            return new NodeList(values);</b>
&nbsp;        }
&nbsp;
&nbsp;        public MethodList&lt;?&gt; asMethodList() {
&nbsp;            List&lt;MethodDescription&gt; methodDescriptions = new ArrayList(this.size());
&nbsp;
&nbsp;            for(Node node : this.nodes) {
&nbsp;                methodDescriptions.add(node.getRepresentative());
&nbsp;            }
&nbsp;
&nbsp;            return new MethodList.Explicit(methodDescriptions);
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @Enhance</b>
<b class="fc">&nbsp;    public static class Simple implements MethodGraph {</b>
&nbsp;        private final LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes;
&nbsp;
&nbsp;        public Simple(LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes) {
&nbsp;            this.nodes = nodes;
&nbsp;        }
&nbsp;
&nbsp;        public static MethodGraph of(List&lt;? extends MethodDescription&gt; methodDescriptions) {
&nbsp;            LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes = new LinkedHashMap();
&nbsp;
<b class="fc">&nbsp;            for(MethodDescription methodDescription : methodDescriptions) {</b>
<b class="fc">&nbsp;                nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            return new Simple(nodes);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public Node locate(MethodDescription.SignatureToken token) {
&nbsp;            Node node = (Node)this.nodes.get(token);
&nbsp;            return (Node)(node == null ? MethodGraph.Node.Unresolved.INSTANCE : node);
&nbsp;        }
&nbsp;
&nbsp;        public NodeList listNodes() {
&nbsp;            return new NodeList(new ArrayList(this.nodes.values()));
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean equals(@MaybeNull Object var1) {</b>
<b class="nc">&nbsp;            if (this == var1) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (var1 == null) {</b>
&nbsp;                return false;
<b class="nc">&nbsp;            } else if (this.getClass() != var1.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                return this.nodes.equals(((Simple)var1).nodes);
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.nodes.hashCode();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Linked extends MethodGraph {
&nbsp;        MethodGraph getSuperClassGraph();
&nbsp;
&nbsp;        MethodGraph getInterfaceGraph(TypeDescription var1);
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @Enhance</b>
<b class="fc">&nbsp;        public static class Delegation implements Linked {</b>
<b class="fc">&nbsp;            private final MethodGraph methodGraph;</b>
<b class="pc">&nbsp;            private final MethodGraph superClassGraph;</b>
<b class="nc">&nbsp;            private final Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs;</b>
&nbsp;
<b class="fc">&nbsp;            public Delegation(MethodGraph methodGraph, MethodGraph superClassGraph, Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs) {</b>
<b class="fc">&nbsp;                this.methodGraph = methodGraph;</b>
<b class="fc">&nbsp;                this.superClassGraph = superClassGraph;</b>
&nbsp;                this.interfaceGraphs = interfaceGraphs;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public MethodGraph getSuperClassGraph() {
&nbsp;                return this.superClassGraph;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
&nbsp;                MethodGraph interfaceGraph = (MethodGraph)this.interfaceGraphs.get(typeDescription);
&nbsp;                return (MethodGraph)(interfaceGraph == null ? MethodGraph.Empty.INSTANCE : interfaceGraph);
&nbsp;            }
&nbsp;
&nbsp;            public Node locate(MethodDescription.SignatureToken token) {
&nbsp;                return this.methodGraph.locate(token);
&nbsp;            }
&nbsp;
&nbsp;            public NodeList listNodes() {
&nbsp;                return this.methodGraph.listNodes();
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else if (!this.methodGraph.equals(((Delegation)var1).methodGraph)) {
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                } else if (!this.superClassGraph.equals(((Delegation)var1).superClassGraph)) {</b>
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.interfaceGraphs.equals(((Delegation)var1).interfaceGraphs);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return ((this.getClass().hashCode() * 31 + this.methodGraph.hashCode()) * 31 + this.superClassGraph.hashCode()) * 31 + this.interfaceGraphs.hashCode();
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public interface Node {
&nbsp;        Sort getSort();
<b class="fc">&nbsp;</b>
&nbsp;        MethodDescription getRepresentative();
&nbsp;
&nbsp;        Set&lt;MethodDescription.TypeToken&gt; getMethodTypes();
&nbsp;
&nbsp;        Visibility getVisibility();
&nbsp;
&nbsp;        public static enum Sort {
&nbsp;            VISIBLE(true, true, true),
&nbsp;            RESOLVED(true, true, false),
&nbsp;            AMBIGUOUS(true, false, false),
&nbsp;            UNRESOLVED(false, false, false);
&nbsp;
&nbsp;            private final boolean resolved;
&nbsp;            private final boolean unique;
&nbsp;            private final boolean madeVisible;
&nbsp;
&nbsp;            private Sort(boolean resolved, boolean unique, boolean madeVisible) {
&nbsp;                this.resolved = resolved;
&nbsp;                this.unique = unique;
&nbsp;                this.madeVisible = madeVisible;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public boolean isResolved() {
&nbsp;                return this.resolved;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isUnique() {
&nbsp;                return this.unique;
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public boolean isMadeVisible() {
&nbsp;                return this.madeVisible;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static enum Unresolved implements Node {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private Unresolved() {
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public Sort getSort() {</b>
<b class="nc">&nbsp;                return MethodGraph.Node.Sort.UNRESOLVED;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public MethodDescription getRepresentative() {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot resolve the method of an illegal node&quot;);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {</b>
&nbsp;                throw new IllegalStateException(&quot;Cannot resolve bridge method of an illegal node&quot;);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            public Visibility getVisibility() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot resolve visibility of an illegal node&quot;);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Simple implements Node {
<b class="nc">&nbsp;            private final MethodDescription methodDescription;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Simple(MethodDescription methodDescription) {</b>
<b class="nc">&nbsp;                this.methodDescription = methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            public Sort getSort() {
&nbsp;                return MethodGraph.Node.Sort.RESOLVED;
&nbsp;            }
&nbsp;
&nbsp;            public MethodDescription getRepresentative() {
&nbsp;                return this.methodDescription;
&nbsp;            }
&nbsp;
&nbsp;            public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
<b class="fc">&nbsp;                return Collections.emptySet();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            public Visibility getVisibility() {</b>
<b class="fc">&nbsp;                return this.methodDescription.getVisibility();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            public boolean equals(@MaybeNull Object var1) {
<b class="fc">&nbsp;                if (this == var1) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                } else if (var1 == null) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.methodDescription.equals(((Simple)var1).methodDescription);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.methodDescription.hashCode();
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="pc">&nbsp;    }</b>
<b class="nc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
