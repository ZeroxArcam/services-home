


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > JavaConstant</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.utility</a>
</div>

<h1>Coverage Summary for Class: JavaConstant (net.bytebuddy.utility)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">JavaConstant$Simple</td>
<td class="coverageStat">
  <span class="percent">
    31.2%
  </span>
  <span class="absValue">
    (5/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.6%
  </span>
  <span class="absValue">
    (5/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.3%
  </span>
  <span class="absValue">
    (18/118)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfClassDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDirectMethodHandleDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDirectMethodHandleDesc$ForKind</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDynamicConstantDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfMethodHandleDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfMethodTypeDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForString</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    38.1%
  </span>
  <span class="absValue">
    (8/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.6%
  </span>
  <span class="absValue">
    (5/76)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.1%
  </span>
  <span class="absValue">
    (21/123)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.utility;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin.Enhance;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ArrayProjection;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeList.Explicit;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator.ForClassLoader;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DoubleConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.FloatConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.JavaConstantValue;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.LongConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.TextConstant;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.pool.TypePool.Default.WithLazyResolution;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Container;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Instance;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.IsConstructor;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.IsStatic;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public interface JavaConstant extends ConstantValue {
&nbsp;    Object toDescription();
&nbsp;
&nbsp;    &lt;T&gt; T accept(Visitor&lt;T&gt; var1);
&nbsp;
&nbsp;    public abstract static class Simple&lt;T&gt; implements JavaConstant {
&nbsp;        protected static final Dispatcher CONSTANT_DESC;
&nbsp;        protected static final Dispatcher.OfClassDesc CLASS_DESC;
&nbsp;        protected static final Dispatcher.OfMethodTypeDesc METHOD_TYPE_DESC;
&nbsp;        protected static final Dispatcher.OfMethodHandleDesc METHOD_HANDLE_DESC;
&nbsp;        protected static final Dispatcher.OfDirectMethodHandleDesc DIRECT_METHOD_HANDLE_DESC;
&nbsp;        protected static final Dispatcher.OfDirectMethodHandleDesc.ForKind DIRECT_METHOD_HANDLE_DESC_KIND;
&nbsp;        protected static final Dispatcher.OfDynamicConstantDesc DYNAMIC_CONSTANT_DESC;
&nbsp;        protected final T value;
&nbsp;        private final TypeDescription typeDescription;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        protected Simple(T value, TypeDescription typeDescription) {
&nbsp;            this.value = value;
&nbsp;            this.typeDescription = typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofLoaded(Object value) {
&nbsp;            JavaConstant constant = ofLoadedOrNull(value);
&nbsp;            if (constant == null) {
&nbsp;                throw new IllegalArgumentException(&quot;Not a constant: &quot; + value);
&nbsp;            } else {
&nbsp;                return constant;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        protected static JavaConstant ofLoadedOrNull(Object value) {
&nbsp;            if (value instanceof Integer) {
&nbsp;                return new OfTrivialValue.ForInteger((Integer)value);
&nbsp;            } else if (value instanceof Long) {
&nbsp;                return new OfTrivialValue.ForLong((Long)value);
&nbsp;            } else if (value instanceof Float) {
&nbsp;                return new OfTrivialValue.ForFloat((Float)value);
&nbsp;            } else if (value instanceof Double) {
&nbsp;                return new OfTrivialValue.ForDouble((Double)value);
&nbsp;            } else if (value instanceof String) {
&nbsp;                return new OfTrivialValue.ForString((String)value);
&nbsp;            } else if (value instanceof Class) {
&nbsp;                return of(ForLoadedType.of((Class)value));
&nbsp;            } else if (JavaType.METHOD_HANDLE.isInstance(value)) {
&nbsp;                return JavaConstant.MethodHandle.ofLoaded(value);
&nbsp;            } else {
&nbsp;                return JavaType.METHOD_TYPE.isInstance(value) ? JavaConstant.MethodType.ofLoaded(value) : null;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofDescription(Object value, @MaybeNull ClassLoader classLoader) {
&nbsp;            return ofDescription(value, ForClassLoader.of(classLoader));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofDescription(Object value, ClassFileLocator classFileLocator) {
&nbsp;            return ofDescription(value, WithLazyResolution.of(classFileLocator));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofDescription(Object value, TypePool typePool) {
&nbsp;            if (value instanceof Integer) {
&nbsp;                return new OfTrivialValue.ForInteger((Integer)value);
&nbsp;            } else if (value instanceof Long) {
&nbsp;                return new OfTrivialValue.ForLong((Long)value);
&nbsp;            } else if (value instanceof Float) {
&nbsp;                return new OfTrivialValue.ForFloat((Float)value);
&nbsp;            } else if (value instanceof Double) {
&nbsp;                return new OfTrivialValue.ForDouble((Double)value);
&nbsp;            } else if (value instanceof String) {
&nbsp;                return new OfTrivialValue.ForString((String)value);
&nbsp;            } else if (CLASS_DESC.isInstance(value)) {
&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(value));
&nbsp;                return JavaConstant.Simple.OfTypeDescription.of(typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve());
&nbsp;            } else if (METHOD_TYPE_DESC.isInstance(value)) {
&nbsp;                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(value);
&nbsp;                List&lt;TypeDescription&gt; typeDescriptions = new ArrayList(parameterTypes.length);
&nbsp;
&nbsp;                for(Object parameterType : parameterTypes) {
&nbsp;                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));
&nbsp;                    typeDescriptions.add(typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve());
&nbsp;                }
&nbsp;
&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(value)));
&nbsp;                return JavaConstant.MethodType.of(typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve(), typeDescriptions);
&nbsp;            } else if (DIRECT_METHOD_HANDLE_DESC.isInstance(value)) {
&nbsp;                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(METHOD_HANDLE_DESC.invocationType(value));
&nbsp;                List&lt;TypeDescription&gt; typeDescriptions = new ArrayList(parameterTypes.length);
&nbsp;
&nbsp;                for(Object parameterType : parameterTypes) {
&nbsp;                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));
&nbsp;                    typeDescriptions.add(typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve());
&nbsp;                }
&nbsp;
&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(METHOD_HANDLE_DESC.invocationType(value))));
&nbsp;                return new MethodHandle(JavaConstant.MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(value)), typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(value))).getClassName()).resolve(), DIRECT_METHOD_HANDLE_DESC.methodName(value), DIRECT_METHOD_HANDLE_DESC.refKind(value) == 8 ? ForLoadedType.of(Void.TYPE) : typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve(), typeDescriptions);
&nbsp;            } else if (!DYNAMIC_CONSTANT_DESC.isInstance(value)) {
&nbsp;                throw new IllegalArgumentException(&quot;Not a resolvable constant description or not expressible as a constant pool value: &quot; + value);
&nbsp;            } else {
&nbsp;                Type methodType = Type.getMethodType(DIRECT_METHOD_HANDLE_DESC.lookupDescriptor(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)));
&nbsp;                List&lt;TypeDescription&gt; parameterTypes = new ArrayList(methodType.getArgumentTypes().length);
&nbsp;
&nbsp;                for(Type type : methodType.getArgumentTypes()) {
&nbsp;                    parameterTypes.add(typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve());
&nbsp;                }
&nbsp;
&nbsp;                Object[] constant = DYNAMIC_CONSTANT_DESC.bootstrapArgs(value);
&nbsp;                List&lt;JavaConstant&gt; arguments = new ArrayList(constant.length);
&nbsp;
&nbsp;                for(Object aConstant : constant) {
&nbsp;                    arguments.add(ofDescription(aConstant, typePool));
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(DYNAMIC_CONSTANT_DESC.constantType(value)));
&nbsp;                return new Dynamic(DYNAMIC_CONSTANT_DESC.constantName(value), typePool.describe(type.getSort() == 9 ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve(), new MethodHandle(JavaConstant.MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value))), typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)))).getClassName()).resolve(), DIRECT_METHOD_HANDLE_DESC.methodName(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)), typePool.describe(methodType.getReturnType().getSort() == 9 ? methodType.getReturnType().getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : methodType.getReturnType().getClassName()).resolve(), parameterTypes), arguments);
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public static JavaConstant of(TypeDescription typeDescription) {
&nbsp;            if (typeDescription.isPrimitive()) {
&nbsp;                throw new IllegalArgumentException(&quot;A primitive type cannot be represented as a type constant: &quot; + typeDescription);
&nbsp;            } else {
<b class="fc">&nbsp;                return new OfTypeDescription(typeDescription);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant wrap(Object value) {
<b class="fc">&nbsp;            if (value instanceof JavaConstant) {</b>
&nbsp;                return (JavaConstant)value;
&nbsp;            } else {
&nbsp;                return value instanceof TypeDescription ? of((TypeDescription)value) : ofLoaded(value);
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static List&lt;JavaConstant&gt; wrap(List&lt;?&gt; values) {
&nbsp;            List&lt;JavaConstant&gt; constants = new ArrayList(values.size());
&nbsp;
<b class="fc">&nbsp;            for(Object value : values) {</b>
&nbsp;                constants.add(wrap(value));
&nbsp;            }
&nbsp;
&nbsp;            return constants;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public T getValue() {
&nbsp;            return this.value;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getTypeDescription() {
&nbsp;            return this.typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.value.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object object) {
&nbsp;            if (this == object) {
&nbsp;                return true;
&nbsp;            } else {
<b class="fc">&nbsp;                return object != null &amp;&amp; this.getClass() == object.getClass() ? this.value.equals(((Simple)object).value) : false;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return this.value.toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
<b class="fc">&nbsp;            } catch (SecurityException var1) {</b>
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            CONSTANT_DESC = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;            CLASS_DESC = (Dispatcher.OfClassDesc)doPrivileged(JavaDispatcher.of(Dispatcher.OfClassDesc.class));
&nbsp;            METHOD_TYPE_DESC = (Dispatcher.OfMethodTypeDesc)doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodTypeDesc.class));
&nbsp;            METHOD_HANDLE_DESC = (Dispatcher.OfMethodHandleDesc)doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodHandleDesc.class));
&nbsp;            DIRECT_METHOD_HANDLE_DESC = (Dispatcher.OfDirectMethodHandleDesc)doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.class));
&nbsp;            DIRECT_METHOD_HANDLE_DESC_KIND = (Dispatcher.OfDirectMethodHandleDesc.ForKind)doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.ForKind.class));
<b class="nc">&nbsp;            DYNAMIC_CONSTANT_DESC = (Dispatcher.OfDynamicConstantDesc)doPrivileged(JavaDispatcher.of(Dispatcher.OfDynamicConstantDesc.class));</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        protected abstract static class OfTrivialValue&lt;S&gt; extends Simple&lt;S&gt; {
<b class="nc">&nbsp;            protected OfTrivialValue(S value, TypeDescription typeDescription) {</b>
&nbsp;                super(value, typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            public Object toDescription() {
&nbsp;                return this.value;
&nbsp;            }
&nbsp;
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;                return visitor.onValue(this);
&nbsp;            }
&nbsp;
<b class="pc">&nbsp;            protected static class ForInteger extends OfTrivialValue&lt;Integer&gt; {</b>
<b class="nc">&nbsp;                public ForInteger(Integer value) {</b>
<b class="pc">&nbsp;                    super(value, ForLoadedType.of(Integer.TYPE));</b>
<b class="nc">&nbsp;                }</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                public StackManipulation toStackManipulation() {</b>
<b class="pc">&nbsp;                    return IntegerConstant.forValue((Integer)this.value);</b>
<b class="nc">&nbsp;                }</b>
<b class="pc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="nc">&nbsp;            protected static class ForLong extends OfTrivialValue&lt;Long&gt; {</b>
<b class="nc">&nbsp;                public ForLong(Long value) {</b>
<b class="nc">&nbsp;                    super(value, ForLoadedType.of(Long.TYPE));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                public StackManipulation toStackManipulation() {</b>
&nbsp;                    return LongConstant.forValue((Long)this.value);
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForFloat extends OfTrivialValue&lt;Float&gt; {
&nbsp;                public ForFloat(Float value) {
&nbsp;                    super(value, ForLoadedType.of(Float.TYPE));
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation() {
&nbsp;                    return FloatConstant.forValue((Float)this.value);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            protected static class ForDouble extends OfTrivialValue&lt;Double&gt; {
&nbsp;                public ForDouble(Double value) {
&nbsp;                    super(value, ForLoadedType.of(Double.TYPE));
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation() {
&nbsp;                    return DoubleConstant.forValue((Double)this.value);
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            protected static class ForString extends OfTrivialValue&lt;String&gt; {</b>
&nbsp;                public ForString(String value) {
&nbsp;                    super(value, ForLoadedType.of(String.class));
&nbsp;                }
&nbsp;
&nbsp;                public StackManipulation toStackManipulation() {
&nbsp;                    return new TextConstant(this.value);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        protected static class OfTypeDescription extends Simple&lt;TypeDescription&gt; {</b>
<b class="nc">&nbsp;            protected OfTypeDescription(TypeDescription value) {</b>
<b class="nc">&nbsp;                super(value, ForLoadedType.of(Class.class));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public Object toDescription() {</b>
<b class="nc">&nbsp;                return CLASS_DESC.ofDescriptor(((TypeDescription)this.value).getDescriptor());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public StackManipulation toStackManipulation() {</b>
<b class="nc">&nbsp;                return ClassConstant.of(this.value);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {</b>
<b class="nc">&nbsp;                return visitor.onType(this);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Proxied(&quot;java.lang.constant.ConstantDesc&quot;)</b>
<b class="nc">&nbsp;        protected interface Dispatcher {</b>
<b class="nc">&nbsp;            @Instance</b>
<b class="nc">&nbsp;            @Proxied(&quot;isInstance&quot;)</b>
<b class="nc">&nbsp;            boolean isInstance(Object var1);</b>
&nbsp;
<b class="nc">&nbsp;            @Container</b>
<b class="nc">&nbsp;            @Proxied(&quot;toArray&quot;)</b>
<b class="nc">&nbsp;            Object[] toArray(int var1);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @Proxied(&quot;java.lang.constant.ClassDesc&quot;)</b>
<b class="nc">&nbsp;            public interface OfClassDesc extends Dispatcher {</b>
<b class="nc">&nbsp;                @IsStatic</b>
<b class="nc">&nbsp;                @Proxied(&quot;ofDescriptor&quot;)</b>
<b class="nc">&nbsp;                Object ofDescriptor(String var1);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;descriptorString&quot;)</b>
<b class="nc">&nbsp;                String descriptorString(Object var1);</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @Proxied(&quot;java.lang.constant.DirectMethodHandleDesc&quot;)</b>
<b class="nc">&nbsp;            public interface OfDirectMethodHandleDesc extends Dispatcher {</b>
<b class="nc">&nbsp;                @Proxied(&quot;refKind&quot;)</b>
<b class="nc">&nbsp;                int refKind(Object var1);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;methodName&quot;)</b>
&nbsp;                String methodName(Object var1);
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;owner&quot;)</b>
<b class="nc">&nbsp;                Object owner(Object var1);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;lookupDescriptor&quot;)</b>
<b class="nc">&nbsp;                String lookupDescriptor(Object var1);</b>
<b class="nc">&nbsp;</b>
&nbsp;                @Proxied(&quot;java.lang.constant.DirectMethodHandleDesc$Kind&quot;)
<b class="nc">&nbsp;                public interface ForKind {</b>
<b class="nc">&nbsp;                    @IsStatic</b>
<b class="nc">&nbsp;                    @Proxied(&quot;valueOf&quot;)</b>
<b class="nc">&nbsp;                    Object valueOf(int var1, boolean var2);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @Proxied(&quot;java.lang.constant.DynamicConstantDesc&quot;)</b>
<b class="nc">&nbsp;            public interface OfDynamicConstantDesc extends Dispatcher {</b>
<b class="nc">&nbsp;                @IsStatic</b>
<b class="nc">&nbsp;                @Proxied(&quot;ofCanonical&quot;)</b>
<b class="nc">&nbsp;                Object ofCanonical(@Proxied(&quot;java.lang.constant.DirectMethodHandleDesc&quot;) Object var1, String var2, @Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object var3, @Proxied(&quot;java.lang.constant.ConstantDesc&quot;) Object[] var4);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;bootstrapArgs&quot;)</b>
<b class="nc">&nbsp;                Object[] bootstrapArgs(Object var1);</b>
<b class="nc">&nbsp;</b>
&nbsp;                @Proxied(&quot;constantName&quot;)
&nbsp;                String constantName(Object var1);
&nbsp;
<b class="nc">&nbsp;                @Proxied(&quot;constantType&quot;)</b>
&nbsp;                Object constantType(Object var1);
&nbsp;
&nbsp;                @Proxied(&quot;bootstrapMethod&quot;)
&nbsp;                Object bootstrapMethod(Object var1);
&nbsp;            }
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.constant.MethodHandleDesc&quot;)
&nbsp;            public interface OfMethodHandleDesc extends Dispatcher {
&nbsp;                @IsStatic
&nbsp;                @Proxied(&quot;of&quot;)
<b class="nc">&nbsp;                Object of(@Proxied(&quot;java.lang.constant.DirectMethodHandleDesc$Kind&quot;) Object var1, @Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object var2, String var3, String var4);</b>
<b class="nc">&nbsp;</b>
&nbsp;                @Proxied(&quot;invocationType&quot;)
<b class="nc">&nbsp;                Object invocationType(Object var1);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.constant.MethodTypeDesc&quot;)
&nbsp;            public interface OfMethodTypeDesc extends Dispatcher {
&nbsp;                @IsStatic
&nbsp;                @Proxied(&quot;of&quot;)
&nbsp;                Object of(@Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object var1, @Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object[] var2);
&nbsp;
&nbsp;                @IsStatic
<b class="nc">&nbsp;                @Proxied(&quot;ofDescriptor&quot;)</b>
<b class="nc">&nbsp;                Object ofDescriptor(String var1);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                @Proxied(&quot;returnType&quot;)</b>
&nbsp;                Object returnType(Object var1);
<b class="nc">&nbsp;</b>
&nbsp;                @Proxied(&quot;parameterArray&quot;)
&nbsp;                Object[] parameterArray(Object var1);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class MethodType implements JavaConstant {
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;        private final TypeDescription returnType;
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
<b class="nc">&nbsp;        private static final boolean ACCESS_CONTROLLER;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        protected MethodType(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
&nbsp;            this.returnType = returnType;
<b class="nc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofLoaded(Object methodType) {
<b class="nc">&nbsp;            if (!JavaType.METHOD_TYPE.isInstance(methodType)) {</b>
&nbsp;                throw new IllegalArgumentException(&quot;Expected method type object: &quot; + methodType);
&nbsp;            } else {
&nbsp;                return of(DISPATCHER.returnType(methodType), DISPATCHER.parameterArray(methodType));
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public static MethodType of(Class&lt;?&gt; returnType, Class&lt;?&gt;... parameterType) {</b>
&nbsp;            return of(ForLoadedType.of(returnType), new TypeList.ForLoadedTypes(parameterType));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType of(TypeDescription returnType, TypeDescription... parameterType) {
<b class="nc">&nbsp;            return new MethodType(returnType, Arrays.asList(parameterType));</b>
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType of(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            return new MethodType(returnType, parameterTypes);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public static MethodType of(Method method) {</b>
&nbsp;            return of((MethodDescription)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType of(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return of((MethodDescription)(new MethodDescription.ForLoadedConstructor(constructor)));</b>
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType of(MethodDescription methodDescription) {
&nbsp;            return new MethodType(((TypeDefinition)(methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType())).asErasure(), (List)(!methodDescription.isStatic() &amp;&amp; !methodDescription.isConstructor() ? CompoundList.of(methodDescription.getDeclaringType().asErasure(), methodDescription.getParameters().asTypeList().asErasures()) : methodDescription.getParameters().asTypeList().asErasures()));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofSignature(Method method) {
&nbsp;            return ofSignature((MethodDescription)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofSignature(Constructor&lt;?&gt; constructor) {
&nbsp;            return ofSignature((MethodDescription)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofSignature(MethodDescription methodDescription) {
&nbsp;            return new MethodType(methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static MethodType ofSetter(Field field) {
&nbsp;            return ofSetter((FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
<b class="nc">&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},</b>
&nbsp;            justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;        )
&nbsp;        public static MethodType ofSetter(FieldDescription fieldDescription) {
&nbsp;            return new MethodType(ForLoadedType.of(Void.TYPE), fieldDescription.isStatic() ? Collections.singletonList(fieldDescription.getType().asErasure()) : Arrays.asList(fieldDescription.getDeclaringType().asErasure(), fieldDescription.getType().asErasure()));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public static MethodType ofGetter(Field field) {</b>
&nbsp;            return ofGetter((FieldDescription)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming declaring type for type member.&quot;
&nbsp;        )
&nbsp;        public static MethodType ofGetter(FieldDescription fieldDescription) {
&nbsp;            return new MethodType(fieldDescription.getType().asErasure(), fieldDescription.isStatic() ? Collections.emptyList() : Collections.singletonList(fieldDescription.getDeclaringType().asErasure()));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofConstant(Object instance) {
&nbsp;            return ofConstant(instance.getClass());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofConstant(Class&lt;?&gt; type) {
&nbsp;            return ofConstant(ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodType ofConstant(TypeDescription typeDescription) {
&nbsp;            return new MethodType(typeDescription, Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getParameterTypes() {
&nbsp;            return new TypeList.Explicit(this.parameterTypes);
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder(&quot;(&quot;);
&nbsp;
&nbsp;            for(TypeDescription parameterType : this.parameterTypes) {
&nbsp;                stringBuilder.append(parameterType.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        public Object toDescription() {
&nbsp;            Object[] parameterType = JavaConstant.Simple.CLASS_DESC.toArray(this.parameterTypes.size());
&nbsp;
&nbsp;            for(int index = 0; index &lt; this.parameterTypes.size(); ++index) {
&nbsp;                parameterType[index] = JavaConstant.Simple.CLASS_DESC.ofDescriptor(((TypeDescription)this.parameterTypes.get(index)).getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return JavaConstant.Simple.METHOD_TYPE_DESC.of(JavaConstant.Simple.CLASS_DESC.ofDescriptor(this.returnType.getDescriptor()), parameterType);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;            return visitor.onMethodType(this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getTypeDescription() {
&nbsp;            return JavaType.METHOD_TYPE.getTypeStub();
&nbsp;        }
&nbsp;
&nbsp;        public StackManipulation toStackManipulation() {
&nbsp;            return new JavaConstantValue(this);
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int result = this.returnType.hashCode();
&nbsp;            result = 31 * result + this.parameterTypes.hashCode();
&nbsp;            return result;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof MethodType)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                MethodType methodType = (MethodType)other;
&nbsp;                return this.parameterTypes.equals(methodType.parameterTypes) &amp;&amp; this.returnType.equals(methodType.returnType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            for(TypeDescription typeDescription : this.parameterTypes) {
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                }
&nbsp;
&nbsp;                stringBuilder.append(typeDescription.getSimpleName());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getSimpleName()).toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.invoke.MethodType&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;            @Proxied(&quot;returnType&quot;)
&nbsp;            Class&lt;?&gt; returnType(Object var1);
&nbsp;
&nbsp;            @Proxied(&quot;parameterArray&quot;)
&nbsp;            Class&lt;?&gt;[] parameterArray(Object var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class MethodHandle implements JavaConstant {
&nbsp;        protected static final MethodHandleInfo METHOD_HANDLE_INFO;
&nbsp;        protected static final MethodType METHOD_TYPE;
&nbsp;        protected static final MethodHandles METHOD_HANDLES;
&nbsp;        protected static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP;
&nbsp;        private final HandleType handleType;
&nbsp;        private final TypeDescription ownerType;
&nbsp;        private final String name;
&nbsp;        private final TypeDescription returnType;
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public MethodHandle(HandleType handleType, TypeDescription ownerType, String name, TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            this.handleType = handleType;
&nbsp;            this.ownerType = ownerType;
&nbsp;            this.name = name;
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTypes = parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofLoaded(Object methodHandle) {
&nbsp;            return ofLoaded(methodHandle, METHOD_HANDLES.publicLookup());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofLoaded(Object methodHandle, Object lookup) {
&nbsp;            if (!JavaType.METHOD_HANDLE.isInstance(methodHandle)) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected method handle object: &quot; + methodHandle);
&nbsp;            } else if (!JavaType.METHOD_HANDLES_LOOKUP.isInstance(lookup)) {
&nbsp;                throw new IllegalArgumentException(&quot;Expected method handle lookup object: &quot; + lookup);
&nbsp;            } else {
&nbsp;                Object methodHandleInfo = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V8).isAtMost(ClassFileVersion.JAVA_V7) ? METHOD_HANDLE_INFO.revealDirect(methodHandle) : METHOD_HANDLES_LOOKUP.revealDirect(lookup, methodHandle);
&nbsp;                Object methodType = METHOD_HANDLE_INFO.getMethodType(methodHandleInfo);
&nbsp;                return new MethodHandle(JavaConstant.MethodHandle.HandleType.of(METHOD_HANDLE_INFO.getReferenceKind(methodHandleInfo)), ForLoadedType.of(METHOD_HANDLE_INFO.getDeclaringClass(methodHandleInfo)), METHOD_HANDLE_INFO.getName(methodHandleInfo), ForLoadedType.of(METHOD_TYPE.returnType(methodType)), new TypeList.ForLoadedTypes(METHOD_TYPE.parameterArray(methodType)));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle of(Method method) {
&nbsp;            return of((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(method)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle of(Constructor&lt;?&gt; constructor) {
&nbsp;            return of((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedConstructor(constructor)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle of(MethodDescription.InDefinedShape methodDescription) {
&nbsp;            return new MethodHandle(JavaConstant.MethodHandle.HandleType.of(methodDescription), methodDescription.getDeclaringType().asErasure(), methodDescription.getInternalName(), methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofSpecial(Method method, Class&lt;?&gt; type) {
&nbsp;            return ofSpecial((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(method)), ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofSpecial(MethodDescription.InDefinedShape methodDescription, TypeDescription typeDescription) {
&nbsp;            if (!methodDescription.isSpecializableFor(typeDescription)) {
&nbsp;                throw new IllegalArgumentException(&quot;Cannot specialize &quot; + methodDescription + &quot; for &quot; + typeDescription);
&nbsp;            } else {
&nbsp;                return new MethodHandle(JavaConstant.MethodHandle.HandleType.ofSpecial(methodDescription), typeDescription, methodDescription.getInternalName(), methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofGetter(Field field) {
&nbsp;            return ofGetter((FieldDescription.InDefinedShape)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofGetter(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;            return new MethodHandle(JavaConstant.MethodHandle.HandleType.ofGetter(fieldDescription), fieldDescription.getDeclaringType().asErasure(), fieldDescription.getInternalName(), fieldDescription.getType().asErasure(), Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofSetter(Field field) {
&nbsp;            return ofSetter((FieldDescription.InDefinedShape)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public static MethodHandle ofSetter(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;            return new MethodHandle(JavaConstant.MethodHandle.HandleType.ofSetter(fieldDescription), fieldDescription.getDeclaringType().asErasure(), fieldDescription.getInternalName(), ForLoadedType.of(Void.TYPE), Collections.singletonList(fieldDescription.getType().asErasure()));
&nbsp;        }
&nbsp;
&nbsp;        public static Class&lt;?&gt; lookupType(Object callerClassLookup) {
&nbsp;            return METHOD_HANDLES_LOOKUP.lookupClass(callerClassLookup);
&nbsp;        }
&nbsp;
&nbsp;        public Object toDescription() {
&nbsp;            return JavaConstant.Simple.METHOD_HANDLE_DESC.of(JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(this.handleType.getIdentifier(), this.ownerType.isInterface()), JavaConstant.Simple.CLASS_DESC.ofDescriptor(this.ownerType.getDescriptor()), this.name, this.getDescriptor());
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;            return visitor.onMethodHandle(this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getTypeDescription() {
&nbsp;            return JavaType.METHOD_HANDLE.getTypeStub();
&nbsp;        }
&nbsp;
&nbsp;        public StackManipulation toStackManipulation() {
&nbsp;            return new JavaConstantValue(this);
&nbsp;        }
&nbsp;
&nbsp;        public HandleType getHandleType() {
&nbsp;            return this.handleType;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getOwnerType() {
&nbsp;            return this.ownerType;
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList getParameterTypes() {
&nbsp;            return new TypeList.Explicit(this.parameterTypes);
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            switch (this.handleType) {
&nbsp;                case GET_FIELD:
&nbsp;                case GET_STATIC_FIELD:
&nbsp;                    return this.returnType.getDescriptor();
&nbsp;                case PUT_FIELD:
&nbsp;                case PUT_STATIC_FIELD:
&nbsp;                    return ((TypeDescription)this.parameterTypes.get(0)).getDescriptor();
&nbsp;                default:
&nbsp;                    StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;
&nbsp;                    for(TypeDescription parameterType : this.parameterTypes) {
&nbsp;                        stringBuilder.append(parameterType.getDescriptor());
&nbsp;                    }
&nbsp;
&nbsp;                    return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int result = this.handleType.hashCode();
&nbsp;            result = 31 * result + this.ownerType.hashCode();
&nbsp;            result = 31 * result + this.name.hashCode();
&nbsp;            result = 31 * result + this.returnType.hashCode();
&nbsp;            result = 31 * result + this.parameterTypes.hashCode();
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof MethodHandle)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                MethodHandle methodHandle = (MethodHandle)other;
&nbsp;                return this.handleType == methodHandle.handleType &amp;&amp; this.name.equals(methodHandle.name) &amp;&amp; this.ownerType.equals(methodHandle.ownerType) &amp;&amp; this.parameterTypes.equals(methodHandle.parameterTypes) &amp;&amp; this.returnType.equals(methodHandle.returnType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(this.handleType.name()).append(this.ownerType.isInterface() &amp;&amp; !this.handleType.isField() &amp;&amp; this.handleType != JavaConstant.MethodHandle.HandleType.INVOKE_INTERFACE ? &quot;@interface&quot; : &quot;&quot;).append(&#39;/&#39;).append(this.ownerType.getSimpleName()).append(&quot;::&quot;).append(this.name).append(&#39;(&#39;);
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            for(TypeDescription typeDescription : this.parameterTypes) {
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                }
&nbsp;
&nbsp;                stringBuilder.append(typeDescription.getSimpleName());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getSimpleName()).toString();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            METHOD_HANDLE_INFO = (MethodHandleInfo)doPrivileged(JavaDispatcher.of(MethodHandleInfo.class));
&nbsp;            METHOD_TYPE = (MethodType)doPrivileged(JavaDispatcher.of(MethodType.class));
&nbsp;            METHOD_HANDLES = (MethodHandles)doPrivileged(JavaDispatcher.of(MethodHandles.class));
&nbsp;            METHOD_HANDLES_LOOKUP = (MethodHandles.Lookup)doPrivileged(JavaDispatcher.of(MethodHandles.Lookup.class));
&nbsp;        }
&nbsp;
&nbsp;        public static enum HandleType {
&nbsp;            INVOKE_VIRTUAL(5, false),
&nbsp;            INVOKE_STATIC(6, false),
&nbsp;            INVOKE_SPECIAL(7, false),
&nbsp;            INVOKE_INTERFACE(9, false),
&nbsp;            INVOKE_SPECIAL_CONSTRUCTOR(8, false),
&nbsp;            PUT_FIELD(3, true),
&nbsp;            GET_FIELD(1, true),
&nbsp;            PUT_STATIC_FIELD(4, true),
&nbsp;            GET_STATIC_FIELD(2, true);
&nbsp;
&nbsp;            private final int identifier;
&nbsp;            private final boolean field;
&nbsp;
&nbsp;            private HandleType(int identifier, boolean field) {
&nbsp;                this.identifier = identifier;
&nbsp;                this.field = field;
&nbsp;            }
&nbsp;
&nbsp;            protected static HandleType of(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                if (methodDescription.isTypeInitializer()) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot create handle of type initializer &quot; + methodDescription);
&nbsp;                } else if (methodDescription.isStatic()) {
&nbsp;                    return INVOKE_STATIC;
&nbsp;                } else if (methodDescription.isConstructor()) {
&nbsp;                    return INVOKE_SPECIAL_CONSTRUCTOR;
&nbsp;                } else if (methodDescription.isPrivate()) {
&nbsp;                    return INVOKE_SPECIAL;
&nbsp;                } else {
&nbsp;                    return methodDescription.getDeclaringType().isInterface() ? INVOKE_INTERFACE : INVOKE_VIRTUAL;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static HandleType of(int identifier) {
&nbsp;                for(HandleType handleType : values()) {
&nbsp;                    if (handleType.getIdentifier() == identifier) {
&nbsp;                        return handleType;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                throw new IllegalArgumentException(&quot;Unknown handle type: &quot; + identifier);
&nbsp;            }
&nbsp;
&nbsp;            protected static HandleType ofSpecial(MethodDescription.InDefinedShape methodDescription) {
&nbsp;                if (!methodDescription.isStatic() &amp;&amp; !methodDescription.isAbstract()) {
&nbsp;                    return methodDescription.isConstructor() ? INVOKE_SPECIAL_CONSTRUCTOR : INVOKE_SPECIAL;
&nbsp;                } else {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot invoke &quot; + methodDescription + &quot; via invokespecial&quot;);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static HandleType ofGetter(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;                return fieldDescription.isStatic() ? GET_STATIC_FIELD : GET_FIELD;
&nbsp;            }
&nbsp;
&nbsp;            protected static HandleType ofSetter(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;                return fieldDescription.isStatic() ? PUT_STATIC_FIELD : PUT_FIELD;
&nbsp;            }
&nbsp;
&nbsp;            public int getIdentifier() {
&nbsp;                return this.identifier;
&nbsp;            }
&nbsp;
&nbsp;            public boolean isField() {
&nbsp;                return this.field;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.invoke.MethodHandleInfo&quot;)
&nbsp;        protected interface MethodHandleInfo {
&nbsp;            @Proxied(&quot;getName&quot;)
&nbsp;            String getName(Object var1);
&nbsp;
&nbsp;            @Proxied(&quot;getDeclaringClass&quot;)
&nbsp;            Class&lt;?&gt; getDeclaringClass(Object var1);
&nbsp;
&nbsp;            @Proxied(&quot;getReferenceKind&quot;)
&nbsp;            int getReferenceKind(Object var1);
&nbsp;
&nbsp;            @Proxied(&quot;getMethodType&quot;)
&nbsp;            Object getMethodType(Object var1);
&nbsp;
&nbsp;            @IsConstructor
&nbsp;            @Proxied(&quot;revealDirect&quot;)
&nbsp;            Object revealDirect(@Proxied(&quot;java.lang.invoke.MethodHandle&quot;) Object var1);
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.invoke.MethodHandles&quot;)
&nbsp;        protected interface MethodHandles {
&nbsp;            @IsStatic
&nbsp;            @Proxied(&quot;publicLookup&quot;)
&nbsp;            Object publicLookup();
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;)
&nbsp;            public interface Lookup {
&nbsp;                @Proxied(&quot;lookupClass&quot;)
&nbsp;                Class&lt;?&gt; lookupClass(Object var1);
&nbsp;
&nbsp;                @Proxied(&quot;revealDirect&quot;)
&nbsp;                Object revealDirect(Object var1, @Proxied(&quot;java.lang.invoke.MethodHandle&quot;) Object var2);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.invoke.MethodType&quot;)
&nbsp;        protected interface MethodType {
&nbsp;            @Proxied(&quot;returnType&quot;)
&nbsp;            Class&lt;?&gt; returnType(Object var1);
&nbsp;
&nbsp;            @Proxied(&quot;parameterArray&quot;)
&nbsp;            Class&lt;?&gt;[] parameterArray(Object var1);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class Dynamic implements JavaConstant {
&nbsp;        public static final String DEFAULT_NAME = &quot;_&quot;;
&nbsp;        private final String name;
&nbsp;        private final TypeDescription typeDescription;
&nbsp;        private final MethodHandle bootstrap;
&nbsp;        private final List&lt;JavaConstant&gt; arguments;
&nbsp;
&nbsp;        protected Dynamic(String name, TypeDescription typeDescription, MethodHandle bootstrap, List&lt;JavaConstant&gt; arguments) {
&nbsp;            this.name = name;
&nbsp;            this.typeDescription = typeDescription;
&nbsp;            this.bootstrap = bootstrap;
&nbsp;            this.arguments = arguments;
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofNullConstant() {
&nbsp;            return new Dynamic(&quot;_&quot;, ForLoadedType.of(Object.class), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;nullConstant&quot;, ForLoadedType.of(Object.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class))), Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofPrimitiveType(Class&lt;?&gt; type) {
&nbsp;            return ofPrimitiveType(ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofPrimitiveType(TypeDescription typeDescription) {
&nbsp;            if (!typeDescription.isPrimitive()) {
&nbsp;                throw new IllegalArgumentException(&quot;Not a primitive type: &quot; + typeDescription);
&nbsp;            } else {
&nbsp;                return new Dynamic(typeDescription.getDescriptor(), ForLoadedType.of(Class.class), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;primitiveClass&quot;, ForLoadedType.of(Class.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class))), Collections.emptyList());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofEnumeration(Enum&lt;?&gt; enumeration) {
&nbsp;            return ofEnumeration(new EnumerationDescription.ForLoadedEnumeration(enumeration));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofEnumeration(EnumerationDescription enumerationDescription) {
&nbsp;            return new Dynamic(enumerationDescription.getValue(), enumerationDescription.getEnumerationType(), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;enumConstant&quot;, ForLoadedType.of(Enum.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class))), Collections.emptyList());
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofField(Field field) {
&nbsp;            return ofField((FieldDescription.InDefinedShape)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofField(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;            if (fieldDescription.isStatic() &amp;&amp; fieldDescription.isFinal()) {
&nbsp;                boolean selfDeclared = fieldDescription.getType().isPrimitive() ? fieldDescription.getType().asErasure().asBoxed().equals(fieldDescription.getType().asErasure()) : fieldDescription.getDeclaringType().equals(fieldDescription.getType().asErasure());
&nbsp;                return new Dynamic(fieldDescription.getInternalName(), fieldDescription.getType().asErasure(), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;getStaticFinal&quot;, ForLoadedType.of(Object.class), selfDeclared ? Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class)) : Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class), ForLoadedType.of(Class.class))), selfDeclared ? Collections.emptyList() : Collections.singletonList(JavaConstant.Simple.of(fieldDescription.getDeclaringType())));
&nbsp;            } else {
&nbsp;                throw new IllegalArgumentException(&quot;Field must be static and final: &quot; + fieldDescription);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(Method method, Object... constant) {
&nbsp;            return ofInvocation(method, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(Method method, List&lt;?&gt; constants) {
&nbsp;            return ofInvocation((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(method)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(Constructor&lt;?&gt; constructor, Object... constant) {
&nbsp;            return ofInvocation(constructor, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(Constructor&lt;?&gt; constructor, List&lt;?&gt; constants) {
&nbsp;            return ofInvocation((MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedConstructor(constructor)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, Object... constant) {
&nbsp;            return ofInvocation(methodDescription, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, List&lt;?&gt; constants) {
&nbsp;            if (!methodDescription.isConstructor() &amp;&amp; methodDescription.getReturnType().represents(Void.TYPE)) {
&nbsp;                throw new IllegalArgumentException(&quot;Bootstrap method is no constructor or non-void static factory: &quot; + methodDescription);
&nbsp;            } else {
&nbsp;                if (methodDescription.isVarArgs()) {
&nbsp;                    if (methodDescription.getParameters().size() + (!methodDescription.isStatic() &amp;&amp; !methodDescription.isConstructor() ? 1 : 0) &gt; constants.size() + 1) {
&nbsp;                        throw new IllegalArgumentException(&quot;Cannot assign &quot; + constants + &quot; to &quot; + methodDescription);
&nbsp;                    }
&nbsp;                } else if (methodDescription.getParameters().size() + (!methodDescription.isStatic() &amp;&amp; !methodDescription.isConstructor() ? 1 : 0) != constants.size()) {
&nbsp;                    throw new IllegalArgumentException(&quot;Cannot assign &quot; + constants + &quot; to &quot; + methodDescription);
&nbsp;                }
&nbsp;
&nbsp;                List&lt;TypeDescription&gt; parameters = (List&lt;TypeDescription&gt;)(!methodDescription.isStatic() &amp;&amp; !methodDescription.isConstructor() ? CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures()) : methodDescription.getParameters().asTypeList().asErasures());
&nbsp;                Iterator&lt;TypeDescription&gt; iterator;
&nbsp;                if (methodDescription.isVarArgs()) {
&nbsp;                    iterator = CompoundList.of(parameters.subList(0, parameters.size() - 1), Collections.nCopies(constants.size() - parameters.size() + 1, ((TypeDescription)parameters.get(parameters.size() - 1)).getComponentType())).iterator();
&nbsp;                } else {
&nbsp;                    iterator = parameters.iterator();
&nbsp;                }
&nbsp;
&nbsp;                List&lt;JavaConstant&gt; arguments = new ArrayList(constants.size() + 1);
&nbsp;                arguments.add(JavaConstant.MethodHandle.of(methodDescription));
&nbsp;
&nbsp;                for(Object constant : constants) {
&nbsp;                    JavaConstant argument = JavaConstant.Simple.wrap(constant);
&nbsp;                    if (!argument.getTypeDescription().isAssignableTo((TypeDescription)iterator.next())) {
&nbsp;                        throw new IllegalArgumentException(&quot;Cannot assign &quot; + constants + &quot; to &quot; + methodDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    arguments.add(argument);
&nbsp;                }
&nbsp;
&nbsp;                return new Dynamic(&quot;_&quot;, methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType().asErasure(), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;invoke&quot;, ForLoadedType.of(Object.class), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class), JavaType.METHOD_HANDLE.getTypeStub(), ArrayProjection.of(ForLoadedType.of(Object.class)))), arguments);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofVarHandle(Field field) {
&nbsp;            return ofVarHandle((FieldDescription.InDefinedShape)(new FieldDescription.ForLoadedField(field)));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofVarHandle(FieldDescription.InDefinedShape fieldDescription) {
&nbsp;            return new Dynamic(fieldDescription.getInternalName(), JavaType.VAR_HANDLE.getTypeStub(), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), fieldDescription.isStatic() ? &quot;staticFieldVarHandle&quot; : &quot;fieldVarHandle&quot;, JavaType.VAR_HANDLE.getTypeStub(), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class), ForLoadedType.of(Class.class), ForLoadedType.of(Class.class))), Arrays.asList(JavaConstant.Simple.of(fieldDescription.getDeclaringType()), JavaConstant.Simple.of(fieldDescription.getType().asErasure())));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofArrayVarHandle(Class&lt;?&gt; type) {
&nbsp;            return ofArrayVarHandle(ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public static JavaConstant ofArrayVarHandle(TypeDescription typeDescription) {
&nbsp;            if (!typeDescription.isArray()) {
&nbsp;                throw new IllegalArgumentException(&quot;Not an array type: &quot; + typeDescription);
&nbsp;            } else {
&nbsp;                return new Dynamic(&quot;_&quot;, JavaType.VAR_HANDLE.getTypeStub(), new MethodHandle(JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(), &quot;arrayVarHandle&quot;, JavaType.VAR_HANDLE.getTypeStub(), Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), ForLoadedType.of(String.class), ForLoadedType.of(Class.class), ForLoadedType.of(Class.class))), Collections.singletonList(JavaConstant.Simple.of(typeDescription)));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, Method method, Object... constant) {
&nbsp;            return bootstrap(name, method, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, Method method, List&lt;?&gt; constants) {
&nbsp;            return bootstrap(name, (MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedMethod(method)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, Constructor&lt;?&gt; constructor, Object... constant) {
&nbsp;            return bootstrap(name, constructor, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, Constructor&lt;?&gt; constructor, List&lt;?&gt; constants) {
&nbsp;            return bootstrap(name, (MethodDescription.InDefinedShape)(new MethodDescription.ForLoadedConstructor(constructor)), (List)constants);
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
&nbsp;            return bootstrap(name, bootstrapMethod, Arrays.asList(constant));
&nbsp;        }
&nbsp;
&nbsp;        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrap, List&lt;?&gt; arguments) {
&nbsp;            if (name.length() != 0 &amp;&amp; !name.contains(&quot;.&quot;)) {
&nbsp;                List&lt;JavaConstant&gt; constants = new ArrayList(arguments.size());
&nbsp;
&nbsp;                for(Object argument : arguments) {
&nbsp;                    constants.add(JavaConstant.Simple.wrap(argument));
&nbsp;                }
&nbsp;
&nbsp;                if (!bootstrap.isConstantBootstrap(Explicit.of(constants))) {
&nbsp;                    throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrap + &quot; for &quot; + arguments);
&nbsp;                } else {
&nbsp;                    return new Dynamic(name, bootstrap.isConstructor() ? bootstrap.getDeclaringType() : bootstrap.getReturnType().asErasure(), new MethodHandle(bootstrap.isConstructor() ? JavaConstant.MethodHandle.HandleType.INVOKE_SPECIAL_CONSTRUCTOR : JavaConstant.MethodHandle.HandleType.INVOKE_STATIC, bootstrap.getDeclaringType(), bootstrap.getInternalName(), bootstrap.getReturnType().asErasure(), bootstrap.getParameters().asTypeList().asErasures()), constants);
&nbsp;                }
&nbsp;            } else {
&nbsp;                throw new IllegalArgumentException(&quot;Not a valid field name: &quot; + name);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public MethodHandle getBootstrap() {
&nbsp;            return this.bootstrap;
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;JavaConstant&gt; getArguments() {
&nbsp;            return this.arguments;
&nbsp;        }
&nbsp;
&nbsp;        public JavaConstant withType(Class&lt;?&gt; type) {
&nbsp;            return this.withType(ForLoadedType.of(type));
&nbsp;        }
&nbsp;
&nbsp;        public JavaConstant withType(TypeDescription typeDescription) {
&nbsp;            if (typeDescription.represents(Void.TYPE)) {
&nbsp;                throw new IllegalArgumentException(&quot;Constant value cannot represent void&quot;);
&nbsp;            } else {
&nbsp;                if (this.getBootstrap().getName().equals(&quot;&lt;init&gt;&quot;)) {
&nbsp;                    if (!this.getTypeDescription().isAssignableTo(typeDescription)) {
&nbsp;                        throw new IllegalArgumentException(typeDescription + &quot; is not compatible with bootstrapped type &quot; + this.getTypeDescription());
&nbsp;                    }
&nbsp;                } else if (!typeDescription.asBoxed().isInHierarchyWith(this.getTypeDescription().asBoxed())) {
&nbsp;                    throw new IllegalArgumentException(typeDescription + &quot; is not compatible with bootstrapped type &quot; + this.getTypeDescription());
&nbsp;                }
&nbsp;
&nbsp;                return new Dynamic(this.getName(), typeDescription, this.getBootstrap(), this.getArguments());
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public Object toDescription() {
&nbsp;            Object[] argument = JavaConstant.Simple.CONSTANT_DESC.toArray(this.arguments.size());
&nbsp;
&nbsp;            for(int index = 0; index &lt; argument.length; ++index) {
&nbsp;                argument[index] = ((JavaConstant)this.arguments.get(index)).toDescription();
&nbsp;            }
&nbsp;
&nbsp;            return JavaConstant.Simple.DYNAMIC_CONSTANT_DESC.ofCanonical(JavaConstant.Simple.METHOD_HANDLE_DESC.of(JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(this.bootstrap.getHandleType().getIdentifier(), this.bootstrap.getOwnerType().isInterface()), JavaConstant.Simple.CLASS_DESC.ofDescriptor(this.bootstrap.getOwnerType().getDescriptor()), this.bootstrap.getName(), this.bootstrap.getDescriptor()), this.getName(), JavaConstant.Simple.CLASS_DESC.ofDescriptor(this.typeDescription.getDescriptor()), argument);
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
&nbsp;            return visitor.onDynamic(this);
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getTypeDescription() {
&nbsp;            return this.typeDescription;
&nbsp;        }
&nbsp;
&nbsp;        public StackManipulation toStackManipulation() {
&nbsp;            return new JavaConstantValue(this);
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int result = this.name.hashCode();
&nbsp;            result = 31 * result + this.typeDescription.hashCode();
&nbsp;            result = 31 * result + this.bootstrap.hashCode();
&nbsp;            result = 31 * result + this.arguments.hashCode();
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object object) {
&nbsp;            if (this == object) {
&nbsp;                return true;
&nbsp;            } else if (object != null &amp;&amp; this.getClass() == object.getClass()) {
&nbsp;                Dynamic dynamic = (Dynamic)object;
&nbsp;                if (!this.name.equals(dynamic.name)) {
&nbsp;                    return false;
&nbsp;                } else if (!this.typeDescription.equals(dynamic.typeDescription)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return !this.bootstrap.equals(dynamic.bootstrap) ? false : this.arguments.equals(dynamic.arguments);
&nbsp;                }
&nbsp;            } else {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(this.bootstrap.getOwnerType().getSimpleName()).append(&quot;::&quot;).append(this.bootstrap.getName()).append(&#39;(&#39;).append(this.name.equals(&quot;_&quot;) ? &quot;&quot; : this.name).append(&#39;/&#39;);
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            for(JavaConstant constant : this.arguments) {
&nbsp;                if (first) {
&nbsp;                    first = false;
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                }
&nbsp;
&nbsp;                stringBuilder.append(constant.toString());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.typeDescription.getSimpleName()).toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface Visitor&lt;T&gt; {
&nbsp;        T onValue(Simple&lt;?&gt; var1);
&nbsp;
&nbsp;        T onType(Simple&lt;TypeDescription&gt; var1);
&nbsp;
&nbsp;        T onMethodType(MethodType var1);
&nbsp;
&nbsp;        T onMethodHandle(MethodHandle var1);
&nbsp;
&nbsp;        T onDynamic(Dynamic var1);
&nbsp;
&nbsp;        public static enum NoOp implements Visitor&lt;JavaConstant&gt; {
&nbsp;            INSTANCE;
&nbsp;
&nbsp;            private NoOp() {
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant onValue(Simple&lt;?&gt; constant) {
&nbsp;                return constant;
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant onType(Simple&lt;TypeDescription&gt; constant) {
&nbsp;                return constant;
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant onMethodType(MethodType constant) {
&nbsp;                return constant;
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant onMethodHandle(MethodHandle constant) {
&nbsp;                return constant;
&nbsp;            }
&nbsp;
&nbsp;            public JavaConstant onDynamic(Dynamic constant) {
&nbsp;                return constant;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
