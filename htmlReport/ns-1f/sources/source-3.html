


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ClassInjector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.loading</a>
</div>

<h1>Coverage Summary for Class: ClassInjector (net.bytebuddy.dynamic.loading)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassInjector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ClassInjector$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (10/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (6/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.9%
  </span>
  <span class="absValue">
    (28/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Initializable</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$UsingUnsafeInjection</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (5/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.7%
  </span>
  <span class="absValue">
    (73/99)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$System</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (20/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (28/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (10/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$Initializable</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$System</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    67.4%
  </span>
  <span class="absValue">
    (31/46)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.3%
  </span>
  <span class="absValue">
    (22/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.5%
  </span>
  <span class="absValue">
    (174/254)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.dynamic.loading;
&nbsp;
&nbsp;import com.sun.jna.FunctionMapper;
&nbsp;import com.sun.jna.JNIEnv;
&nbsp;import com.sun.jna.LastErrorException;
&nbsp;import com.sun.jna.Library;
&nbsp;import com.sun.jna.Native;
&nbsp;import com.sun.jna.NativeLibrary;
&nbsp;import com.sun.jna.Platform;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.AccessibleObject;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.ReflectPermission;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.net.URL;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.Permission;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.MemberRemoval;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.Enhance;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin.ValueHandling.Sort;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.loading.PackageDefinitionStrategy.Trivial;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.implementation.FixedValue;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Defaults;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.IsStatic;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.nullability.UnknownNull;
&nbsp;import net.bytebuddy.utility.privilege.GetMethodAction;
&nbsp;
&nbsp;public interface ClassInjector {
&nbsp;    Permission SUPPRESS_ACCESS_CHECKS = new ReflectPermission(&quot;suppressAccessChecks&quot;);
&nbsp;    boolean ALLOW_EXISTING_TYPES = false;
<b class="nc">&nbsp;</b>
&nbsp;    boolean isAlive();
&nbsp;
&nbsp;    Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Set&lt;? extends TypeDescription&gt; var1, ClassFileLocator var2);
&nbsp;
&nbsp;    Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; var1, ClassFileLocator var2);
&nbsp;
&nbsp;    Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Map&lt;? extends TypeDescription, byte[]&gt; var1);
&nbsp;
&nbsp;    Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;String, byte[]&gt; var1);
&nbsp;
&nbsp;    public abstract static class AbstractBase implements ClassInjector {
&nbsp;        public AbstractBase() {
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Set&lt;? extends TypeDescription&gt; types, ClassFileLocator classFileLocator) {
&nbsp;            Set&lt;String&gt; names = new LinkedHashSet();
&nbsp;
&nbsp;            for(TypeDescription type : types) {
&nbsp;                names.add(type.getName());
&nbsp;            }
&nbsp;
&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; loadedTypes = this.injectRaw(names, classFileLocator);
&nbsp;            Map&lt;TypeDescription, Class&lt;?&gt;&gt; result = new HashMap();
&nbsp;
&nbsp;            for(TypeDescription type : types) {
&nbsp;                result.put(type, loadedTypes.get(type.getName()));
&nbsp;            }
&nbsp;
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Map&lt;? extends TypeDescription, byte[]&gt; types) {
&nbsp;            Map&lt;String, byte[]&gt; binaryRepresentations = new LinkedHashMap();
&nbsp;
&nbsp;            for(Map.Entry&lt;? extends TypeDescription, byte[]&gt; entry : types.entrySet()) {
&nbsp;                binaryRepresentations.put(((TypeDescription)entry.getKey()).getName(), entry.getValue());
&nbsp;            }
&nbsp;
&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; loadedTypes = this.injectRaw(binaryRepresentations);
&nbsp;            Map&lt;TypeDescription, Class&lt;?&gt;&gt; result = new HashMap();
&nbsp;
&nbsp;            for(TypeDescription typeDescription : types.keySet()) {
&nbsp;                result.put(typeDescription, loadedTypes.get(typeDescription.getName()));
&nbsp;            }
&nbsp;
&nbsp;            return result;
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;String, byte[]&gt; types) {
&nbsp;            return this.injectRaw(types.keySet(), new ClassFileLocator.Simple(types));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class UsingReflection extends AbstractBase {
&nbsp;        private static final Dispatcher.Initializable DISPATCHER;
<b class="nc">&nbsp;        private static final System SYSTEM;</b>
<b class="nc">&nbsp;        private static final Method CHECK_PERMISSION;</b>
<b class="nc">&nbsp;        private final ClassLoader classLoader;</b>
&nbsp;        @MaybeNull
<b class="nc">&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)</b>
<b class="nc">&nbsp;        private final ProtectionDomain protectionDomain;</b>
<b class="nc">&nbsp;        private final PackageDefinitionStrategy packageDefinitionStrategy;</b>
<b class="nc">&nbsp;        private final boolean forbidExisting;</b>
&nbsp;        private static final boolean ACCESS_CONTROLLER;
<b class="nc">&nbsp;</b>
&nbsp;        public UsingReflection(ClassLoader classLoader) {
&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);
&nbsp;        }
&nbsp;
&nbsp;        public UsingReflection(ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;            this(classLoader, protectionDomain, Trivial.INSTANCE, false);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public UsingReflection(ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, PackageDefinitionStrategy packageDefinitionStrategy, boolean forbidExisting) {</b>
&nbsp;            if (classLoader == null) {
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot inject classes into the bootstrap class loader&quot;);</b>
<b class="fc">&nbsp;            } else {</b>
<b class="fc">&nbsp;                this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                this.protectionDomain = protectionDomain;</b>
&nbsp;                this.packageDefinitionStrategy = packageDefinitionStrategy;
<b class="fc">&nbsp;                this.forbidExisting = forbidExisting;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean isAlive() {
&nbsp;            return isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; names, ClassFileLocator classFileLocator) {
&nbsp;            Dispatcher dispatcher = DISPATCHER.initialize();
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap();</b>
&nbsp;
&nbsp;            for(String name : names) {
&nbsp;                synchronized(dispatcher.getClassLoadingLock(this.classLoader, name)) {
&nbsp;                    Class&lt;?&gt; type = dispatcher.findClass(this.classLoader, name);
<b class="fc">&nbsp;                    if (type != null) {</b>
&nbsp;                        if (this.forbidExisting) {
&nbsp;                            throw new IllegalStateException(&quot;Cannot inject already loaded type: &quot; + type);
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        int packageIndex = name.lastIndexOf(46);</b>
&nbsp;                        if (packageIndex != -1) {
&nbsp;                            String packageName = name.substring(0, packageIndex);
&nbsp;                            PackageDefinitionStrategy.Definition definition = this.packageDefinitionStrategy.define(this.classLoader, packageName, name);
&nbsp;                            if (definition.isDefined()) {
<b class="fc">&nbsp;                                Package definedPackage = dispatcher.getDefinedPackage(this.classLoader, packageName);</b>
&nbsp;                                if (definedPackage == null) {
&nbsp;                                    try {
&nbsp;                                        dispatcher.definePackage(this.classLoader, packageName, definition.getSpecificationTitle(), definition.getSpecificationVersion(), definition.getSpecificationVendor(), definition.getImplementationTitle(), definition.getImplementationVersion(), definition.getImplementationVendor(), definition.getSealBase());
&nbsp;                                    } catch (IllegalStateException exception) {
&nbsp;                                        definedPackage = dispatcher.getPackage(this.classLoader, packageName);
&nbsp;                                        if (definedPackage == null) {
&nbsp;                                            throw exception;
&nbsp;                                        }
&nbsp;
&nbsp;                                        if (!definition.isCompatibleTo(definedPackage)) {
&nbsp;                                            throw new SecurityException(&quot;Sealing violation for package &quot; + packageName + &quot; (getPackage fallback)&quot;);
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                } else if (!definition.isCompatibleTo(definedPackage)) {
&nbsp;                                    throw new SecurityException(&quot;Sealing violation for package &quot; + packageName);
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        try {
&nbsp;                            type = dispatcher.defineClass(this.classLoader, name, classFileLocator.locate(name).resolve(), this.protectionDomain);
&nbsp;                        } catch (IOException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Could not resolve type description for &quot; + name, exception);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    result.put(name, type);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return result;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public static boolean isAvailable() {
&nbsp;            return DISPATCHER.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofSystemClassLoader() {
&nbsp;            return new UsingReflection(ClassLoader.getSystemClassLoader());
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
<b class="nc">&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);</b>
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher.Initializable)doPrivileged(ClassInjector.UsingReflection.Dispatcher.CreationAction.INSTANCE);
&nbsp;            SYSTEM = (System)doPrivileged(JavaDispatcher.of(System.class));
&nbsp;            CHECK_PERMISSION = (Method)doPrivileged(new GetMethodAction(&quot;java.lang.SecurityManager&quot;, &quot;checkPermission&quot;, new Class[]{Permission.class}));
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
<b class="fc">&nbsp;                return false;</b>
<b class="pc">&nbsp;            } else if (this.getClass() != var1.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else if (this.forbidExisting != ((UsingReflection)var1).forbidExisting) {
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            } else if (!this.classLoader.equals(((UsingReflection)var1).classLoader)) {</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            } else {</b>
&nbsp;                ProtectionDomain var2 = ((UsingReflection)var1).protectionDomain;
&nbsp;                ProtectionDomain var3 = this.protectionDomain;
&nbsp;                if (var2 != null) {
&nbsp;                    if (var3 == null) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!var3.equals(var2)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else if (var3 != null) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                if (!this.packageDefinitionStrategy.equals(((UsingReflection)var1).packageDefinitionStrategy)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return true;
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int var10000 = (this.getClass().hashCode() * 31 + this.classLoader.hashCode()) * 31;
&nbsp;            ProtectionDomain var1 = this.protectionDomain;
<b class="fc">&nbsp;            if (var1 != null) {</b>
<b class="fc">&nbsp;                var10000 += var1.hashCode();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            return (var10000 * 31 + this.packageDefinitionStrategy.hashCode()) * 31 + this.forbidExisting;</b>
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;        protected interface Dispatcher {</b>
<b class="fc">&nbsp;            @AlwaysNull</b>
<b class="fc">&nbsp;            Class&lt;?&gt; UNDEFINED = null;</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            Object getClassLoadingLock(ClassLoader var1, String var2);</b>
<b class="nc">&nbsp;</b>
&nbsp;            @MaybeNull
<b class="nc">&nbsp;            Class&lt;?&gt; findClass(ClassLoader var1, String var2);</b>
&nbsp;
<b class="nc">&nbsp;            Class&lt;?&gt; defineClass(ClassLoader var1, String var2, byte[] var3, @MaybeNull ProtectionDomain var4);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @MaybeNull</b>
<b class="nc">&nbsp;            Package getDefinedPackage(ClassLoader var1, String var2);</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            @MaybeNull</b>
<b class="nc">&nbsp;            Package getPackage(ClassLoader var1, String var2);</b>
&nbsp;
&nbsp;            Package definePackage(ClassLoader var1, String var2, @MaybeNull String var3, @MaybeNull String var4, @MaybeNull String var5, @MaybeNull String var6, @MaybeNull String var7, @MaybeNull String var8, @MaybeNull URL var9);
&nbsp;
&nbsp;            public static enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private CreationAction() {
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                @SuppressFBWarnings(</b>
<b class="nc">&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},</b>
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
<b class="nc">&nbsp;                )</b>
<b class="nc">&nbsp;                public Initializable run() {</b>
&nbsp;                    try {
&nbsp;                        if (JavaModule.isSupported()) {
<b class="nc">&nbsp;                            return ClassInjector.UsingUnsafe.isAvailable() ? ClassInjector.UsingReflection.Dispatcher.UsingUnsafeInjection.make() : ClassInjector.UsingReflection.Dispatcher.UsingUnsafeOverride.make();</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            return ClassInjector.UsingReflection.Dispatcher.Direct.make();
&nbsp;                        }
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        return new Initializable.Unavailable(exception.getTargetException().getMessage());
<b class="fc">&nbsp;                    } catch (Exception exception) {</b>
&nbsp;                        return new Initializable.Unavailable(exception.getMessage());
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            @Enhance
<b class="fc">&nbsp;            public abstract static class Direct implements Dispatcher, Initializable {</b>
<b class="fc">&nbsp;                protected final Method findLoadedClass;</b>
&nbsp;                protected final Method defineClass;
<b class="fc">&nbsp;                @UnknownNull</b>
&nbsp;                protected final Method getDefinedPackage;
&nbsp;                protected final Method getPackage;
&nbsp;                protected final Method definePackage;
&nbsp;
&nbsp;                protected Direct(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage) {
&nbsp;                    this.findLoadedClass = findLoadedClass;
&nbsp;                    this.defineClass = defineClass;
&nbsp;                    this.getDefinedPackage = getDefinedPackage;
<b class="fc">&nbsp;                    this.getPackage = getPackage;</b>
&nbsp;                    this.definePackage = definePackage;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                    justification = &quot;Assuring privilege is explicit user responsibility.&quot;
&nbsp;                )
&nbsp;                protected static Initializable make() throws Exception {
<b class="nc">&nbsp;                    Method getDefinedPackage;</b>
&nbsp;                    if (JavaModule.isSupported()) {
&nbsp;                        try {
&nbsp;                            getDefinedPackage = ClassLoader.class.getMethod(&quot;getDefinedPackage&quot;, String.class);
&nbsp;                        } catch (NoSuchMethodException var7) {
&nbsp;                            getDefinedPackage = null;
&nbsp;                        }
&nbsp;                    } else {
&nbsp;                        getDefinedPackage = null;
&nbsp;                    }
&nbsp;
&nbsp;                    Method getPackage = ClassLoader.class.getDeclaredMethod(&quot;getPackage&quot;, String.class);
<b class="nc">&nbsp;                    getPackage.setAccessible(true);</b>
&nbsp;                    Method findLoadedClass = ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, String.class);
&nbsp;                    findLoadedClass.setAccessible(true);
&nbsp;                    Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class);
&nbsp;                    defineClass.setAccessible(true);
&nbsp;                    Method definePackage = ClassLoader.class.getDeclaredMethod(&quot;definePackage&quot;, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class);
&nbsp;                    definePackage.setAccessible(true);
&nbsp;
&nbsp;                    try {
&nbsp;                        Method getClassLoadingLock = ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class);
&nbsp;                        getClassLoadingLock.setAccessible(true);
&nbsp;                        return new ForJava7CapableVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage, getClassLoadingLock);
&nbsp;                    } catch (NoSuchMethodException var6) {
&nbsp;                        return new ForLegacyVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher initialize() {
&nbsp;                    Object securityManager = ClassInjector.UsingReflection.SYSTEM.getSecurityManager();
&nbsp;                    if (securityManager != null) {
&nbsp;                        try {
&nbsp;                            ClassInjector.UsingReflection.CHECK_PERMISSION.invoke(securityManager, ClassInjector.SUPPRESS_ACCESS_CHECKS);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            return new Unavailable(exception.getTargetException().getMessage());
&nbsp;                        } catch (Exception exception) {
&nbsp;                            return new Unavailable(exception.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Class)this.findLoadedClass.invoke(classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
&nbsp;                        return (Class)this.defineClass.invoke(classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
&nbsp;                    if (this.getDefinedPackage == null) {
&nbsp;                        return this.getPackage(classLoader, name);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return (Package)this.getDefinedPackage.invoke(classLoader, name);
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(exception.getTargetException());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Package)this.getPackage.invoke(classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package definePackage(ClassLoader classLoader, String name, @MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {
&nbsp;                    try {
&nbsp;                        return (Package)this.definePackage.invoke(classLoader, name, specificationTitle, specificationVersion, specificationVendor, implementationTitle, implementationVersion, implementationVendor, sealBase);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.findLoadedClass.equals(((Direct)var1).findLoadedClass)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.defineClass.equals(((Direct)var1).defineClass)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.getDefinedPackage.equals(((Direct)var1).getDefinedPackage)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.getPackage.equals(((Direct)var1).getPackage)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.definePackage.equals(((Direct)var1).definePackage);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((this.getClass().hashCode() * 31 + this.findLoadedClass.hashCode()) * 31 + this.defineClass.hashCode()) * 31 + this.getDefinedPackage.hashCode()) * 31 + this.getPackage.hashCode()) * 31 + this.definePackage.hashCode();
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class ForJava7CapableVm extends Direct {
&nbsp;                    private final Method getClassLoadingLock;
&nbsp;
&nbsp;                    protected ForJava7CapableVm(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage, Method getClassLoadingLock) {
&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                        this.getClassLoadingLock = getClassLoadingLock;
&nbsp;                    }
&nbsp;
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        try {
&nbsp;                            return this.getClassLoadingLock.invoke(classLoader, name);
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(exception.getTargetException());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (!super.equals(var1)) {
&nbsp;                            return false;
&nbsp;                        } else if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.getClassLoadingLock.equals(((ForJava7CapableVm)var1).getClassLoadingLock);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return super.hashCode() * 31 + this.getClassLoadingLock.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class ForLegacyVm extends Direct {
&nbsp;                    protected ForLegacyVm(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage) {
&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                    }
&nbsp;
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        return classLoader;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class UsingUnsafeInjection implements Dispatcher, Initializable {
&nbsp;                private final Object accessor;
&nbsp;                private final Method findLoadedClass;
&nbsp;                private final Method defineClass;
&nbsp;                @UnknownNull
&nbsp;                private final Method getDefinedPackage;
&nbsp;                private final Method getPackage;
&nbsp;                private final Method definePackage;
&nbsp;                private final Method getClassLoadingLock;
&nbsp;
&nbsp;                protected UsingUnsafeInjection(Object accessor, Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage, Method getClassLoadingLock) {
&nbsp;                    this.accessor = accessor;
&nbsp;                    this.findLoadedClass = findLoadedClass;
&nbsp;                    this.defineClass = defineClass;
&nbsp;                    this.getDefinedPackage = getDefinedPackage;
&nbsp;                    this.getPackage = getPackage;
&nbsp;                    this.definePackage = definePackage;
&nbsp;                    this.getClassLoadingLock = getClassLoadingLock;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                    justification = &quot;Assuring privilege is explicit user responsibility.&quot;
<b class="fc">&nbsp;                )</b>
&nbsp;                protected static Initializable make() throws Exception {
&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.safe&quot;, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {
&nbsp;                        return new Initializable.Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);
&nbsp;                    } else {
<b class="fc">&nbsp;                        Class&lt;?&gt; unsafe = Class.forName(&quot;sun.misc.Unsafe&quot;);</b>
&nbsp;                        Field theUnsafe = unsafe.getDeclaredField(&quot;theUnsafe&quot;);
&nbsp;                        theUnsafe.setAccessible(true);
&nbsp;                        Object unsafeInstance = theUnsafe.get((Object)null);
&nbsp;                        Method getDefinedPackage;
&nbsp;                        if (JavaModule.isSupported()) {
&nbsp;                            try {
&nbsp;                                getDefinedPackage = ClassLoader.class.getDeclaredMethod(&quot;getDefinedPackage&quot;, String.class);
<b class="pc">&nbsp;                            } catch (NoSuchMethodException var7) {</b>
<b class="pc">&nbsp;                                getDefinedPackage = null;</b>
<b class="fc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } else {</b>
&nbsp;                            getDefinedPackage = null;
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        DynamicType.Builder&lt;?&gt; builder = (new ByteBuddy()).with(TypeValidation.DISABLED).subclass(Object.class, net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy.Default.NO_CONSTRUCTORS).name(ClassLoader.class.getName() + &quot;$ByteBuddyAccessor$V1&quot;).defineMethod(&quot;findLoadedClass&quot;, Class.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class}).intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, String.class)).onArgument(0).withArgument(new int[]{1})).defineMethod(&quot;defineClass&quot;, Class.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class}).intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class)).onArgument(0).withArgument(new int[]{1, 2, 3, 4, 5})).defineMethod(&quot;getPackage&quot;, Package.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class}).intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;getPackage&quot;, String.class)).onArgument(0).withArgument(new int[]{1})).defineMethod(&quot;definePackage&quot;, Package.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class}).intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;definePackage&quot;, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class)).onArgument(0).withArgument(new int[]{1, 2, 3, 4, 5, 6, 7, 8}));
<b class="nc">&nbsp;                        if (getDefinedPackage != null) {</b>
&nbsp;                            builder = builder.defineMethod(&quot;getDefinedPackage&quot;, Package.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class}).intercept(MethodCall.invoke(getDefinedPackage).onArgument(0).withArgument(new int[]{1}));
<b class="nc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        try {
&nbsp;                            var8 = builder.defineMethod(&quot;getClassLoadingLock&quot;, Object.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class}).intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class)).onArgument(0).withArgument(new int[]{1}));
&nbsp;                        } catch (NoSuchMethodException var6) {
&nbsp;                            var8 = builder.defineMethod(&quot;getClassLoadingLock&quot;, Object.class, new ModifierContributor.ForMethod[]{Visibility.PUBLIC}).withParameters(new Type[]{ClassLoader.class, String.class}).intercept(FixedValue.argument(0));
&nbsp;                        }
&nbsp;
&nbsp;                        Class&lt;?&gt; type = var8.make().load(ClassLoadingStrategy.BOOTSTRAP_LOADER, new ClassLoadingStrategy.ForUnsafeInjection()).getLoaded();
&nbsp;                        return new UsingUnsafeInjection(unsafe.getMethod(&quot;allocateInstance&quot;, Class.class).invoke(unsafeInstance, type), type.getMethod(&quot;findLoadedClass&quot;, ClassLoader.class, String.class), type.getMethod(&quot;defineClass&quot;, ClassLoader.class, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class), getDefinedPackage != null ? type.getMethod(&quot;getDefinedPackage&quot;, ClassLoader.class, String.class) : null, type.getMethod(&quot;getPackage&quot;, ClassLoader.class, String.class), type.getMethod(&quot;definePackage&quot;, ClassLoader.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class), type.getMethod(&quot;getClassLoadingLock&quot;, ClassLoader.class, String.class));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher initialize() {
&nbsp;                    Object securityManager = ClassInjector.UsingReflection.SYSTEM.getSecurityManager();
&nbsp;                    if (securityManager != null) {
&nbsp;                        try {
&nbsp;                            ClassInjector.UsingReflection.CHECK_PERMISSION.invoke(securityManager, ClassInjector.SUPPRESS_ACCESS_CHECKS);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            return new Unavailable(exception.getTargetException().getMessage());
&nbsp;                        } catch (Exception exception) {
&nbsp;                            return new Unavailable(exception.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return this.getClassLoadingLock.invoke(this.accessor, classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Class)this.findLoadedClass.invoke(this.accessor, classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
&nbsp;                        return (Class)this.defineClass.invoke(this.accessor, classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
&nbsp;                    if (this.getDefinedPackage == null) {
&nbsp;                        return this.getPackage(classLoader, name);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return (Package)this.getDefinedPackage.invoke(this.accessor, classLoader, name);
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(exception.getTargetException());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Package)this.getPackage.invoke(this.accessor, classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package definePackage(ClassLoader classLoader, String name, @MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {
&nbsp;                    try {
&nbsp;                        return (Package)this.definePackage.invoke(this.accessor, classLoader, name, specificationTitle, specificationVersion, specificationVendor, implementationTitle, implementationVersion, implementationVendor, sealBase);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.accessor.equals(((UsingUnsafeInjection)var1).accessor)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.findLoadedClass.equals(((UsingUnsafeInjection)var1).findLoadedClass)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.defineClass.equals(((UsingUnsafeInjection)var1).defineClass)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.getDefinedPackage.equals(((UsingUnsafeInjection)var1).getDefinedPackage)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.getPackage.equals(((UsingUnsafeInjection)var1).getPackage)) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.definePackage.equals(((UsingUnsafeInjection)var1).definePackage)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.getClassLoadingLock.equals(((UsingUnsafeInjection)var1).getClassLoadingLock);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return ((((((this.getClass().hashCode() * 31 + this.accessor.hashCode()) * 31 + this.findLoadedClass.hashCode()) * 31 + this.defineClass.hashCode()) * 31 + this.getDefinedPackage.hashCode()) * 31 + this.getPackage.hashCode()) * 31 + this.definePackage.hashCode()) * 31 + this.getClassLoadingLock.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public abstract static class UsingUnsafeOverride implements Dispatcher, Initializable {
&nbsp;                protected final Method findLoadedClass;
&nbsp;                protected final Method defineClass;
&nbsp;                @MaybeNull
&nbsp;                protected final Method getDefinedPackage;
&nbsp;                protected final Method getPackage;
&nbsp;                protected final Method definePackage;
&nbsp;
&nbsp;                protected UsingUnsafeOverride(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage) {
&nbsp;                    this.findLoadedClass = findLoadedClass;
&nbsp;                    this.defineClass = defineClass;
&nbsp;                    this.getDefinedPackage = getDefinedPackage;
&nbsp;                    this.getPackage = getPackage;
&nbsp;                    this.definePackage = definePackage;
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;},
&nbsp;                    justification = &quot;Assuring privilege is explicit user responsibility.&quot;
&nbsp;                )
&nbsp;                protected static Initializable make() throws Exception {
&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.safe&quot;, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {
&nbsp;                        return new Initializable.Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);
&nbsp;                    } else {
&nbsp;                        Class&lt;?&gt; unsafeType = Class.forName(&quot;sun.misc.Unsafe&quot;);
&nbsp;                        Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);
&nbsp;                        theUnsafe.setAccessible(true);
&nbsp;                        Object unsafe = theUnsafe.get((Object)null);
&nbsp;
&nbsp;                        Field override;
&nbsp;                        try {
&nbsp;                            override = AccessibleObject.class.getDeclaredField(&quot;override&quot;);
&nbsp;                        } catch (NoSuchFieldException var15) {
&nbsp;                            override = (new ByteBuddy()).redefine(AccessibleObject.class).name(&quot;net.bytebuddy.mirror.&quot; + AccessibleObject.class.getSimpleName()).noNestMate().visit((new MemberRemoval()).stripInvokables(ElementMatchers.any())).make().load(AccessibleObject.class.getClassLoader(), net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.WRAPPER.with(AccessibleObject.class.getProtectionDomain())).getLoaded().getDeclaredField(&quot;override&quot;);
&nbsp;                        }
&nbsp;
&nbsp;                        long offset = (Long)unsafeType.getMethod(&quot;objectFieldOffset&quot;, Field.class).invoke(unsafe, override);
&nbsp;                        Method putBoolean = unsafeType.getMethod(&quot;putBoolean&quot;, Object.class, Long.TYPE, Boolean.TYPE);
&nbsp;                        Method getDefinedPackage;
&nbsp;                        if (JavaModule.isSupported()) {
&nbsp;                            try {
&nbsp;                                getDefinedPackage = ClassLoader.class.getMethod(&quot;getDefinedPackage&quot;, String.class);
&nbsp;                            } catch (NoSuchMethodException var14) {
&nbsp;                                getDefinedPackage = null;
&nbsp;                            }
&nbsp;                        } else {
&nbsp;                            getDefinedPackage = null;
&nbsp;                        }
&nbsp;
&nbsp;                        Method getPackage = ClassLoader.class.getDeclaredMethod(&quot;getPackage&quot;, String.class);
&nbsp;                        putBoolean.invoke(unsafe, getPackage, offset, true);
&nbsp;                        Method findLoadedClass = ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, String.class);
&nbsp;                        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ProtectionDomain.class);
&nbsp;                        Method definePackage = ClassLoader.class.getDeclaredMethod(&quot;definePackage&quot;, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class);
&nbsp;                        putBoolean.invoke(unsafe, defineClass, offset, true);
&nbsp;                        putBoolean.invoke(unsafe, findLoadedClass, offset, true);
&nbsp;                        putBoolean.invoke(unsafe, definePackage, offset, true);
&nbsp;
&nbsp;                        try {
&nbsp;                            Method getClassLoadingLock = ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class);
&nbsp;                            putBoolean.invoke(unsafe, getClassLoadingLock, offset, true);
&nbsp;                            return new ForJava7CapableVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage, getClassLoadingLock);
&nbsp;                        } catch (NoSuchMethodException var13) {
&nbsp;                            return new ForLegacyVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher initialize() {
&nbsp;                    Object securityManager = ClassInjector.UsingReflection.SYSTEM.getSecurityManager();
&nbsp;                    if (securityManager != null) {
&nbsp;                        try {
&nbsp;                            ClassInjector.UsingReflection.CHECK_PERMISSION.invoke(securityManager, ClassInjector.SUPPRESS_ACCESS_CHECKS);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            return new Unavailable(exception.getTargetException().getMessage());
&nbsp;                        } catch (Exception exception) {
&nbsp;                            return new Unavailable(exception.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Class)this.findLoadedClass.invoke(classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
&nbsp;                        return (Class)this.defineClass.invoke(classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
&nbsp;                    if (this.getDefinedPackage == null) {
&nbsp;                        return this.getPackage(classLoader, name);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            return (Package)this.getDefinedPackage.invoke(classLoader, name);
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(exception.getTargetException());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return (Package)this.getPackage.invoke(classLoader, name);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Package definePackage(ClassLoader classLoader, String name, @MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {
&nbsp;                    try {
&nbsp;                        return (Package)this.definePackage.invoke(classLoader, name, specificationTitle, specificationVersion, specificationVendor, implementationTitle, implementationVersion, implementationVendor, sealBase);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Enhance
&nbsp;                protected static class ForJava7CapableVm extends UsingUnsafeOverride {
&nbsp;                    private final Method getClassLoadingLock;
&nbsp;
&nbsp;                    protected ForJava7CapableVm(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage, Method getClassLoadingLock) {
&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                        this.getClassLoadingLock = getClassLoadingLock;
&nbsp;                    }
&nbsp;
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        try {
&nbsp;                            return this.getClassLoadingLock.invoke(classLoader, name);
&nbsp;                        } catch (IllegalAccessException exception) {
&nbsp;                            throw new IllegalStateException(exception);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            throw new IllegalStateException(exception.getTargetException());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
&nbsp;                        if (this == var1) {
&nbsp;                            return true;
&nbsp;                        } else if (var1 == null) {
&nbsp;                            return false;
&nbsp;                        } else if (this.getClass() != var1.getClass()) {
&nbsp;                            return false;
&nbsp;                        } else {
&nbsp;                            return this.getClassLoadingLock.equals(((ForJava7CapableVm)var1).getClassLoadingLock);
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.getClassLoadingLock.hashCode();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                protected static class ForLegacyVm extends UsingUnsafeOverride {
&nbsp;                    protected ForLegacyVm(Method findLoadedClass, Method defineClass, @MaybeNull Method getDefinedPackage, Method getPackage, Method definePackage) {
&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);
&nbsp;                    }
&nbsp;
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        return classLoader;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Unavailable implements Dispatcher {
&nbsp;                private final String message;
&nbsp;
&nbsp;                protected Unavailable(String message) {
&nbsp;                    this.message = message;
&nbsp;                }
&nbsp;
&nbsp;                public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                    return classLoader;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
&nbsp;                        return classLoader.loadClass(name);
&nbsp;                    } catch (ClassNotFoundException var4) {
&nbsp;                        return UNDEFINED;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot define class using reflection: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot get defined package using reflection: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot get package using reflection: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public Package definePackage(ClassLoader classLoader, String name, @MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot define package using injection: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        return this.message.equals(((Unavailable)var1).message);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public int hashCode() {</b>
<b class="fc">&nbsp;                    return this.getClass().hashCode() * 31 + this.message.hashCode();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Initializable {
&nbsp;                boolean isAvailable();
&nbsp;
&nbsp;                Dispatcher initialize();
&nbsp;
&nbsp;                @Enhance
&nbsp;                public static class Unavailable implements Dispatcher, Initializable {
<b class="pc">&nbsp;                    private final String message;</b>
<b class="nc">&nbsp;</b>
&nbsp;                    protected Unavailable(String message) {
<b class="fc">&nbsp;                        this.message = message;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public boolean isAvailable() {</b>
&nbsp;                        return false;
<b class="pc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    public Dispatcher initialize() {</b>
&nbsp;                        return this;
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                        return classLoader;</b>
&nbsp;                    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {</b>
<b class="fc">&nbsp;                        try {</b>
<b class="fc">&nbsp;                            return classLoader.loadClass(name);</b>
<b class="fc">&nbsp;                        } catch (ClassNotFoundException var4) {</b>
<b class="fc">&nbsp;                            return UNDEFINED;</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {</b>
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot define class using reflection: &quot; + this.message);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
<b class="fc">&nbsp;                    public Package getDefinedPackage(ClassLoader classLoader, String name) {</b>
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot get defined package using reflection: &quot; + this.message);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public Package getPackage(ClassLoader classLoader, String name) {</b>
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot get package using reflection: &quot; + this.message);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    public Package definePackage(ClassLoader classLoader, String name, @MaybeNull String specificationTitle, @MaybeNull String specificationVersion, @MaybeNull String specificationVendor, @MaybeNull String implementationTitle, @MaybeNull String implementationVersion, @MaybeNull String implementationVendor, @MaybeNull URL sealBase) {</b>
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot define package using injection: &quot; + this.message);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    public boolean equals(@MaybeNull Object var1) {
<b class="fc">&nbsp;                        if (this == var1) {</b>
<b class="fc">&nbsp;                            return true;</b>
<b class="fc">&nbsp;                        } else if (var1 == null) {</b>
<b class="fc">&nbsp;                            return false;</b>
<b class="pc">&nbsp;                        } else if (this.getClass() != var1.getClass()) {</b>
<b class="fc">&nbsp;                            return false;</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            return this.message.equals(((Unavailable)var1).message);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
&nbsp;                    public int hashCode() {
&nbsp;                        return this.getClass().hashCode() * 31 + this.message.hashCode();
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        @Proxied(&quot;java.lang.System&quot;)
<b class="nc">&nbsp;        protected interface System {</b>
<b class="nc">&nbsp;            @MaybeNull</b>
<b class="nc">&nbsp;            @IsStatic</b>
&nbsp;            @Defaults
<b class="fc">&nbsp;            @Proxied(&quot;getSecurityManager&quot;)</b>
<b class="fc">&nbsp;            Object getSecurityManager();</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    @Enhance</b>
<b class="pc">&nbsp;    public static class UsingLookup extends AbstractBase {</b>
<b class="fc">&nbsp;        private static final MethodHandles METHOD_HANDLES;</b>
<b class="fc">&nbsp;        private static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP;</b>
<b class="fc">&nbsp;        private static final int PACKAGE_LOOKUP = 8;</b>
<b class="fc">&nbsp;        private final Object lookup;</b>
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        protected UsingLookup(Object lookup) {
&nbsp;            this.lookup = lookup;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance</b>
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public static UsingLookup of(Object lookup) {
&nbsp;            if (!isAvailable()) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;The current VM does not support class definition via method handle lookups&quot;);</b>
<b class="pc">&nbsp;            } else if (!JavaType.METHOD_HANDLES_LOOKUP.isInstance(lookup)) {</b>
&nbsp;                throw new IllegalArgumentException(&quot;Not a method handle lookup: &quot; + lookup);
<b class="nc">&nbsp;            } else if ((METHOD_HANDLES_LOOKUP.lookupModes(lookup) &amp; 8) == 0) {</b>
&nbsp;                throw new IllegalArgumentException(&quot;Lookup does not imply package-access: &quot; + lookup);
<b class="nc">&nbsp;            } else {</b>
&nbsp;                return new UsingLookup(lookup);
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Class&lt;?&gt; lookupType() {</b>
&nbsp;            return METHOD_HANDLES_LOOKUP.lookupClass(this.lookup);
&nbsp;        }
&nbsp;
&nbsp;        public UsingLookup in(Class&lt;?&gt; type) {
&nbsp;            try {
&nbsp;                return new UsingLookup(METHOD_HANDLES.privateLookupIn(type, this.lookup));
&nbsp;            } catch (IllegalAccessException exception) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot access &quot; + type.getName() + &quot; from &quot; + this.lookup, exception);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public boolean isAlive() {</b>
&nbsp;            return isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; names, ClassFileLocator classFileLocator) {
&nbsp;            PackageDescription target = ForLoadedType.of(this.lookupType()).getPackage();
&nbsp;            if (target == null) {
&nbsp;                throw new IllegalArgumentException(&quot;Cannot inject array or primitive type&quot;);
&nbsp;            } else {
<b class="fc">&nbsp;                Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap();</b>
&nbsp;
<b class="nc">&nbsp;                for(String name : names) {</b>
&nbsp;                    int index = name.lastIndexOf(46);
<b class="nc">&nbsp;                    if (!target.getName().equals(index == -1 ? &quot;&quot; : name.substring(0, index))) {</b>
&nbsp;                        throw new IllegalArgumentException(name + &quot; must be defined in the same package as &quot; + this.lookup);
&nbsp;                    }
&nbsp;
&nbsp;                    try {
&nbsp;                        result.put(name, METHOD_HANDLES_LOOKUP.defineClass(this.lookup, classFileLocator.locate(name).resolve()));
&nbsp;                    } catch (Exception exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public static boolean isAvailable() {
&nbsp;            return JavaType.MODULE.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
<b class="nc">&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException var0) {</b>
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
<b class="nc">&nbsp;                ACCESS_CONTROLLER = true;</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            METHOD_HANDLES = (MethodHandles)doPrivileged(JavaDispatcher.of(MethodHandles.class));
<b class="nc">&nbsp;            METHOD_HANDLES_LOOKUP = (MethodHandles.Lookup)doPrivileged(JavaDispatcher.of(MethodHandles.Lookup.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return this.lookup.equals(((UsingLookup)var1).lookup);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.getClass().hashCode() * 31 + this.lookup.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.invoke.MethodHandles&quot;)
&nbsp;        protected interface MethodHandles {
&nbsp;            @IsStatic
&nbsp;            @Proxied(&quot;privateLookupIn&quot;)
&nbsp;            Object privateLookupIn(Class&lt;?&gt; var1, @Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;) Object var2) throws IllegalAccessException;
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;)
&nbsp;            public interface Lookup {
&nbsp;                @Proxied(&quot;lookupClass&quot;)
&nbsp;                Class&lt;?&gt; lookupClass(Object var1);
&nbsp;
<b class="nc">&nbsp;                @Proxied(&quot;lookupModes&quot;)</b>
&nbsp;                int lookupModes(Object var1);
&nbsp;
&nbsp;                @Proxied(&quot;defineClass&quot;)
&nbsp;                Class&lt;?&gt; defineClass(Object var1, byte[] var2) throws IllegalAccessException;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class UsingUnsafe extends AbstractBase {
<b class="nc">&nbsp;        public static final String SAFE_PROPERTY = &quot;net.bytebuddy.safe&quot;;</b>
&nbsp;        private static final Dispatcher.Initializable DISPATCHER;
<b class="nc">&nbsp;        private static final System SYSTEM;</b>
&nbsp;        private static final Method CHECK_PERMISSION;
&nbsp;        private static final Object BOOTSTRAP_LOADER_LOCK;
&nbsp;        @MaybeNull
&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;        @MaybeNull
&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;        private final ProtectionDomain protectionDomain;
&nbsp;        private final Dispatcher.Initializable dispatcher;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public UsingUnsafe(@MaybeNull ClassLoader classLoader) {
&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);
&nbsp;        }
&nbsp;
&nbsp;        public UsingUnsafe(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;            this(classLoader, protectionDomain, DISPATCHER);
&nbsp;        }
&nbsp;
&nbsp;        protected UsingUnsafe(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, Dispatcher.Initializable dispatcher) {
&nbsp;            this.classLoader = classLoader;
&nbsp;            this.protectionDomain = protectionDomain;
&nbsp;            this.dispatcher = dispatcher;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAlive() {
&nbsp;            return this.dispatcher.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; names, ClassFileLocator classFileLocator) {
&nbsp;            Dispatcher dispatcher = this.dispatcher.initialize();
&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap();
&nbsp;            synchronized(this.classLoader == null ? BOOTSTRAP_LOADER_LOCK : this.classLoader) {
&nbsp;                for(String name : names) {
&nbsp;                    try {
&nbsp;                        result.put(name, Class.forName(name, false, this.classLoader));
&nbsp;                    } catch (ClassNotFoundException var17) {
&nbsp;                        try {
&nbsp;                            result.put(name, dispatcher.defineClass(this.classLoader, name, classFileLocator.locate(name).resolve(), this.protectionDomain));
&nbsp;                        } catch (RuntimeException exception) {
&nbsp;                            try {
&nbsp;                                result.put(name, Class.forName(name, false, this.classLoader));
&nbsp;                            } catch (ClassNotFoundException var13) {
&nbsp;                                throw exception;
&nbsp;                            }
&nbsp;                        } catch (IOException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Failed to resolve binary representation of &quot; + name, exception);
&nbsp;                        } catch (Error error) {
&nbsp;                            try {
&nbsp;                                result.put(name, Class.forName(name, false, this.classLoader));
&nbsp;                            } catch (ClassNotFoundException var12) {
&nbsp;                                throw error;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return result;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static boolean isAvailable() {
&nbsp;            return DISPATCHER.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofSystemLoader() {
&nbsp;            return new UsingUnsafe(ClassLoader.getSystemClassLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofPlatformLoader() {
&nbsp;            return new UsingUnsafe(ClassLoader.getSystemClassLoader().getParent());
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofBootLoader() {
&nbsp;            return new UsingUnsafe(ClassLoadingStrategy.BOOTSTRAP_LOADER);
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher.Initializable)doPrivileged(ClassInjector.UsingUnsafe.Dispatcher.CreationAction.INSTANCE);
&nbsp;            SYSTEM = (System)doPrivileged(JavaDispatcher.of(System.class));
&nbsp;            CHECK_PERMISSION = (Method)doPrivileged(new GetMethodAction(&quot;java.lang.SecurityManager&quot;, &quot;checkPermission&quot;, new Class[]{Permission.class}));
&nbsp;            BOOTSTRAP_LOADER_LOCK = new Object();
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                ClassLoader var2 = ((UsingUnsafe)var1).classLoader;
&nbsp;                ClassLoader var3 = this.classLoader;
&nbsp;                if (var2 != null) {
&nbsp;                    if (var3 == null) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!var3.equals(var2)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else if (var3 != null) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                ProtectionDomain var4 = ((UsingUnsafe)var1).protectionDomain;
&nbsp;                ProtectionDomain var5 = this.protectionDomain;
&nbsp;                if (var4 != null) {
&nbsp;                    if (var5 == null) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!var5.equals(var4)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else if (var5 != null) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                if (!this.dispatcher.equals(((UsingUnsafe)var1).dispatcher)) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return true;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int var10000 = this.getClass().hashCode() * 31;
&nbsp;            ClassLoader var1 = this.classLoader;
&nbsp;            if (var1 != null) {
&nbsp;                var10000 += var1.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            var10000 *= 31;
&nbsp;            ProtectionDomain var2 = this.protectionDomain;
&nbsp;            if (var2 != null) {
&nbsp;                var10000 += var2.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            return var10000 * 31 + this.dispatcher.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance
&nbsp;        public static class Factory {
&nbsp;            private final Dispatcher.Initializable dispatcher;
&nbsp;
&nbsp;            public Factory() {
&nbsp;                this((AccessResolver)ClassInjector.UsingUnsafe.Factory.AccessResolver.Default.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;            )
&nbsp;            public Factory(AccessResolver accessResolver) {
&nbsp;                Dispatcher.Initializable dispatcher;
&nbsp;                if (ClassInjector.UsingUnsafe.DISPATCHER.isAvailable()) {
&nbsp;                    dispatcher = ClassInjector.UsingUnsafe.DISPATCHER;
&nbsp;                } else {
&nbsp;                    try {
&nbsp;                        Class&lt;?&gt; unsafeType = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);
&nbsp;                        Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);
&nbsp;                        accessResolver.apply(theUnsafe);
&nbsp;                        Object unsafe = theUnsafe.get((Object)null);
&nbsp;                        Method defineClass = unsafeType.getMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ClassLoader.class, ProtectionDomain.class);
&nbsp;                        accessResolver.apply(defineClass);
&nbsp;                        dispatcher = new Dispatcher.Enabled(unsafe, defineClass);
&nbsp;                    } catch (Exception exception) {
&nbsp;                        dispatcher = new Dispatcher.Unavailable(exception.getMessage());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                this.dispatcher = dispatcher;
&nbsp;            }
&nbsp;
&nbsp;            protected Factory(Dispatcher.Initializable dispatcher) {
&nbsp;                this.dispatcher = dispatcher;
&nbsp;            }
&nbsp;
&nbsp;            public static Factory resolve(Instrumentation instrumentation) {
&nbsp;                return resolve(instrumentation, false);
&nbsp;            }
&nbsp;
&nbsp;            @SuppressFBWarnings(
&nbsp;                value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                justification = &quot;Exception intends to trigger disabled injection strategy. Modules are assumed if module system is supported.&quot;
&nbsp;            )
&nbsp;            public static Factory resolve(Instrumentation instrumentation, boolean local) {
&nbsp;                if (!ClassInjector.UsingUnsafe.isAvailable() &amp;&amp; JavaModule.isSupported()) {
&nbsp;                    try {
&nbsp;                        Class&lt;?&gt; type = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);
&nbsp;                        PackageDescription packageDescription = new PackageDescription.ForLoadedPackage(type.getPackage());
&nbsp;                        JavaModule source = JavaModule.ofType(type);
&nbsp;                        JavaModule target = JavaModule.ofType(UsingUnsafe.class);
&nbsp;                        if (source.isOpened(packageDescription, target)) {
&nbsp;                            return new Factory();
&nbsp;                        } else if (local) {
&nbsp;                            JavaModule module = JavaModule.ofType(AccessResolver.Default.class);
&nbsp;                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation, source, Collections.singleton(module), Collections.emptyMap(), Collections.singletonMap(packageDescription.getName(), Collections.singleton(module)), Collections.emptySet(), Collections.emptyMap());
&nbsp;                            return new Factory();
&nbsp;                        } else {
&nbsp;                            Class&lt;? extends AccessResolver&gt; resolver = (new ByteBuddy()).subclass(AccessResolver.class).method(ElementMatchers.named(&quot;apply&quot;)).intercept(MethodCall.invoke(AccessibleObject.class.getMethod(&quot;setAccessible&quot;, Boolean.TYPE)).onArgument(0).with(new Object[]{true})).make().load(AccessResolver.class.getClassLoader(), net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.WRAPPER.with(AccessResolver.class.getProtectionDomain())).getLoaded();
&nbsp;                            JavaModule module = JavaModule.ofType(resolver);
&nbsp;                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation, source, Collections.singleton(module), Collections.emptyMap(), Collections.singletonMap(packageDescription.getName(), Collections.singleton(module)), Collections.emptySet(), Collections.emptyMap());
&nbsp;                            return new Factory((AccessResolver)resolver.getConstructor().newInstance());
&nbsp;                        }
&nbsp;                    } catch (Exception exception) {
&nbsp;                        return new Factory(new Dispatcher.Unavailable(exception.getMessage()));
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    return new Factory();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public boolean isAvailable() {
&nbsp;                return this.dispatcher.isAvailable();
&nbsp;            }
&nbsp;
&nbsp;            public ClassInjector make(@MaybeNull ClassLoader classLoader) {
&nbsp;                return this.make(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);
&nbsp;            }
&nbsp;
&nbsp;            public ClassInjector make(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                return new UsingUnsafe(classLoader, protectionDomain, this.dispatcher);
&nbsp;            }
&nbsp;
&nbsp;            public boolean equals(@MaybeNull Object var1) {
&nbsp;                if (this == var1) {
&nbsp;                    return true;
&nbsp;                } else if (var1 == null) {
&nbsp;                    return false;
&nbsp;                } else if (this.getClass() != var1.getClass()) {
&nbsp;                    return false;
&nbsp;                } else {
&nbsp;                    return this.dispatcher.equals(((Factory)var1).dispatcher);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public int hashCode() {
&nbsp;                return this.getClass().hashCode() * 31 + this.dispatcher.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            public interface AccessResolver {
&nbsp;                void apply(AccessibleObject var1);
&nbsp;
&nbsp;                public static enum Default implements AccessResolver {
&nbsp;                    INSTANCE;
&nbsp;
&nbsp;                    private Default() {
&nbsp;                    }
&nbsp;
&nbsp;                    public void apply(AccessibleObject accessibleObject) {
&nbsp;                        accessibleObject.setAccessible(true);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        protected interface Dispatcher {
&nbsp;            Class&lt;?&gt; defineClass(@MaybeNull ClassLoader var1, String var2, byte[] var3, @MaybeNull ProtectionDomain var4);
&nbsp;
&nbsp;            public static enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private CreationAction() {
&nbsp;                }
&nbsp;
&nbsp;                @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;},
&nbsp;                    justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;
&nbsp;                )
&nbsp;                public Initializable run() {
&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.safe&quot;, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {
&nbsp;                        return new Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            Class&lt;?&gt; unsafeType = Class.forName(&quot;sun.misc.Unsafe&quot;);
&nbsp;                            Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);
&nbsp;                            theUnsafe.setAccessible(true);
&nbsp;                            Object unsafe = theUnsafe.get((Object)null);
&nbsp;
&nbsp;                            try {
&nbsp;                                Method defineClass = unsafeType.getMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ClassLoader.class, ProtectionDomain.class);
&nbsp;                                defineClass.setAccessible(true);
&nbsp;                                return new Enabled(unsafe, defineClass);
&nbsp;                            } catch (Exception exception) {
&nbsp;                                try {
&nbsp;                                    Field override;
&nbsp;                                    try {
&nbsp;                                        override = AccessibleObject.class.getDeclaredField(&quot;override&quot;);
&nbsp;                                    } catch (NoSuchFieldException var12) {
&nbsp;                                        override = (new ByteBuddy()).redefine(AccessibleObject.class).name(&quot;net.bytebuddy.mirror.&quot; + AccessibleObject.class.getSimpleName()).noNestMate().visit((new MemberRemoval()).stripInvokables(ElementMatchers.any())).make().load(AccessibleObject.class.getClassLoader(), net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default.WRAPPER.with(AccessibleObject.class.getProtectionDomain())).getLoaded().getDeclaredField(&quot;override&quot;);
&nbsp;                                    }
&nbsp;
&nbsp;                                    long offset = (Long)unsafeType.getMethod(&quot;objectFieldOffset&quot;, Field.class).invoke(unsafe, override);
&nbsp;                                    Method putBoolean = unsafeType.getMethod(&quot;putBoolean&quot;, Object.class, Long.TYPE, Boolean.TYPE);
&nbsp;                                    Class&lt;?&gt; internalUnsafe = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);
&nbsp;                                    Field theUnsafeInternal = internalUnsafe.getDeclaredField(&quot;theUnsafe&quot;);
&nbsp;                                    putBoolean.invoke(unsafe, theUnsafeInternal, offset, true);
&nbsp;                                    Method defineClassInternal = internalUnsafe.getMethod(&quot;defineClass&quot;, String.class, byte[].class, Integer.TYPE, Integer.TYPE, ClassLoader.class, ProtectionDomain.class);
&nbsp;                                    putBoolean.invoke(unsafe, defineClassInternal, offset, true);
&nbsp;                                    return new Enabled(theUnsafeInternal.get((Object)null), defineClassInternal);
&nbsp;                                } catch (Exception var13) {
&nbsp;                                    throw exception;
&nbsp;                                }
&nbsp;                            }
&nbsp;                        } catch (Exception exception) {
&nbsp;                            return new Unavailable(exception.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Enabled implements Dispatcher, Initializable {
&nbsp;                private final Object unsafe;
&nbsp;                private final Method defineClass;
&nbsp;
&nbsp;                protected Enabled(Object unsafe, Method defineClass) {
&nbsp;                    this.unsafe = unsafe;
&nbsp;                    this.defineClass = defineClass;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher initialize() {
&nbsp;                    Object securityManager = ClassInjector.UsingUnsafe.SYSTEM.getSecurityManager();
&nbsp;                    if (securityManager != null) {
&nbsp;                        try {
&nbsp;                            ClassInjector.UsingUnsafe.CHECK_PERMISSION.invoke(securityManager, ClassInjector.SUPPRESS_ACCESS_CHECKS);
&nbsp;                        } catch (InvocationTargetException exception) {
&nbsp;                            return new Unavailable(exception.getTargetException().getMessage());
&nbsp;                        } catch (Exception exception) {
&nbsp;                            return new Unavailable(exception.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return this;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
&nbsp;                        return (Class)this.defineClass.invoke(this.unsafe, name, binaryRepresentation, 0, binaryRepresentation.length, classLoader, protectionDomain);
&nbsp;                    } catch (IllegalAccessException exception) {
&nbsp;                        throw new IllegalStateException(exception);
&nbsp;                    } catch (InvocationTargetException exception) {
&nbsp;                        throw new IllegalStateException(exception.getTargetException());
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else if (!this.unsafe.equals(((Enabled)var1).unsafe)) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.defineClass.equals(((Enabled)var1).defineClass);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return (this.getClass().hashCode() * 31 + this.unsafe.hashCode()) * 31 + this.defineClass.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Unavailable implements Dispatcher, Initializable {
&nbsp;                private final String message;
&nbsp;
&nbsp;                protected Unavailable(String message) {
&nbsp;                    this.message = message;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher initialize() {
&nbsp;                    throw new UnsupportedOperationException(&quot;Could not access Unsafe class: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    throw new UnsupportedOperationException(&quot;Could not access Unsafe class: &quot; + this.message);
&nbsp;                }
&nbsp;
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
&nbsp;                        return true;
&nbsp;                    } else if (var1 == null) {
&nbsp;                        return false;
&nbsp;                    } else if (this.getClass() != var1.getClass()) {
&nbsp;                        return false;
&nbsp;                    } else {
&nbsp;                        return this.message.equals(((Unavailable)var1).message);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.message.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public interface Initializable {
&nbsp;                boolean isAvailable();
&nbsp;
&nbsp;                Dispatcher initialize();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.System&quot;)
&nbsp;        protected interface System {
&nbsp;            @MaybeNull
&nbsp;            @IsStatic
&nbsp;            @Defaults
&nbsp;            @Proxied(&quot;getSecurityManager&quot;)
&nbsp;            Object getSecurityManager();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class UsingInstrumentation extends AbstractBase {
&nbsp;        private static final String JAR = &quot;jar&quot;;
&nbsp;        private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;        private final Instrumentation instrumentation;
&nbsp;        private final Target target;
&nbsp;        private final File folder;
&nbsp;        private final RandomString randomString;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        protected UsingInstrumentation(File folder, Target target, Instrumentation instrumentation, RandomString randomString) {
&nbsp;            this.folder = folder;
&nbsp;            this.target = target;
&nbsp;            this.instrumentation = instrumentation;
&nbsp;            this.randomString = randomString;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
&nbsp;        public static void redefineModule(Instrumentation instrumentation, JavaModule target, Set&lt;JavaModule&gt; reads, Map&lt;String, Set&lt;JavaModule&gt;&gt; exports, Map&lt;String, Set&lt;JavaModule&gt;&gt; opens, Set&lt;Class&lt;?&gt;&gt; uses, Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; provides) {
&nbsp;            if (!DISPATCHER.isModifiableModule(instrumentation, target.unwrap())) {
&nbsp;                throw new IllegalArgumentException(&quot;Cannot modify module: &quot; + target);
&nbsp;            } else {
&nbsp;                Set&lt;Object&gt; unwrappedReads = new HashSet();
&nbsp;
&nbsp;                for(JavaModule read : reads) {
&nbsp;                    unwrappedReads.add(read.unwrap());
&nbsp;                }
&nbsp;
&nbsp;                Map&lt;String, Set&lt;?&gt;&gt; unwrappedExports = new HashMap();
&nbsp;
&nbsp;                for(Map.Entry&lt;String, Set&lt;JavaModule&gt;&gt; entry : exports.entrySet()) {
&nbsp;                    Set&lt;Object&gt; modules = new HashSet();
&nbsp;
&nbsp;                    for(JavaModule module : (Set)entry.getValue()) {
&nbsp;                        modules.add(module.unwrap());
&nbsp;                    }
&nbsp;
&nbsp;                    unwrappedExports.put(entry.getKey(), modules);
&nbsp;                }
&nbsp;
&nbsp;                Map&lt;String, Set&lt;?&gt;&gt; unwrappedOpens = new HashMap();
&nbsp;
&nbsp;                for(Map.Entry&lt;String, Set&lt;JavaModule&gt;&gt; entry : opens.entrySet()) {
&nbsp;                    Set&lt;Object&gt; modules = new HashSet();
&nbsp;
&nbsp;                    for(JavaModule module : (Set)entry.getValue()) {
&nbsp;                        modules.add(module.unwrap());
&nbsp;                    }
&nbsp;
&nbsp;                    unwrappedOpens.put(entry.getKey(), modules);
&nbsp;                }
&nbsp;
&nbsp;                DISPATCHER.redefineModule(instrumentation, target.unwrap(), unwrappedReads, unwrappedExports, unwrappedOpens, uses, provides);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector of(File folder, Target target, Instrumentation instrumentation) {
&nbsp;            return new UsingInstrumentation(folder, target, instrumentation, new RandomString());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAlive() {
&nbsp;            return isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; names, ClassFileLocator classFileLocator) {
&nbsp;            File file = new File(this.folder, &quot;jar&quot; + this.randomString.nextString() + &quot;.&quot; + &quot;jar&quot;);
&nbsp;
&nbsp;            try {
&nbsp;                if (!file.createNewFile()) {
&nbsp;                    throw new IllegalStateException(&quot;Cannot create file &quot; + file);
&nbsp;                } else {
&nbsp;                    HashMap var35;
&nbsp;                    try {
&nbsp;                        JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(file));
&nbsp;
&nbsp;                        try {
&nbsp;                            for(String name : names) {
&nbsp;                                jarOutputStream.putNextEntry(new JarEntry(name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;));
&nbsp;                                jarOutputStream.write(classFileLocator.locate(name).resolve());
&nbsp;                            }
&nbsp;                        } finally {
&nbsp;                            jarOutputStream.close();
&nbsp;                        }
&nbsp;
&nbsp;                        JarFile var33 = new JarFile(file, false, 1);
&nbsp;
&nbsp;                        try {
&nbsp;                            this.target.inject(this.instrumentation, var33);
&nbsp;                        } finally {
&nbsp;                            var33.close();
&nbsp;                        }
&nbsp;
&nbsp;                        HashMap var34 = new HashMap();
&nbsp;
&nbsp;                        for(String name : names) {
&nbsp;                            var34.put(name, Class.forName(name, false, this.target.getClassLoader()));
&nbsp;                        }
&nbsp;
&nbsp;                        var35 = var34;
&nbsp;                    } finally {
&nbsp;                        if (!file.delete()) {
&nbsp;                            file.deleteOnExit();
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
&nbsp;                    return var35;
&nbsp;                }
&nbsp;            } catch (IOException exception) {
&nbsp;                throw new IllegalStateException(&quot;Cannot write jar file to disk&quot;, exception);
&nbsp;            } catch (ClassNotFoundException exception) {
&nbsp;                throw new IllegalStateException(&quot;Cannot load injected class&quot;, exception);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public static boolean isAvailable() {
&nbsp;            return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V6);
&nbsp;        }
&nbsp;
&nbsp;        static {
&nbsp;            try {
&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
&nbsp;                ACCESS_CONTROLLER = false;
&nbsp;            } catch (SecurityException var1) {
&nbsp;                ACCESS_CONTROLLER = true;
&nbsp;            }
&nbsp;
&nbsp;            DISPATCHER = (Dispatcher)doPrivileged(JavaDispatcher.of(Dispatcher.class));
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object var1) {
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
&nbsp;            } else if (this.getClass() != var1.getClass()) {
&nbsp;                return false;
&nbsp;            } else if (!this.target.equals(((UsingInstrumentation)var1).target)) {
&nbsp;                return false;
&nbsp;            } else if (!this.instrumentation.equals(((UsingInstrumentation)var1).instrumentation)) {
&nbsp;                return false;
&nbsp;            } else if (!this.folder.equals(((UsingInstrumentation)var1).folder)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                return this.randomString.equals(((UsingInstrumentation)var1).randomString);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return (((this.getClass().hashCode() * 31 + this.instrumentation.hashCode()) * 31 + this.target.hashCode()) * 31 + this.folder.hashCode()) * 31 + this.randomString.hashCode();
&nbsp;        }
&nbsp;
&nbsp;        public static enum Target {
&nbsp;            BOOTSTRAP((ClassLoader)null) {
&nbsp;                protected void inject(Instrumentation instrumentation, JarFile jarFile) {
&nbsp;                    ClassInjector.UsingInstrumentation.DISPATCHER.appendToBootstrapClassLoaderSearch(instrumentation, jarFile);
&nbsp;                }
<b class="fc">&nbsp;            },</b>
&nbsp;            SYSTEM(ClassLoader.getSystemClassLoader()) {
&nbsp;                protected void inject(Instrumentation instrumentation, JarFile jarFile) {
&nbsp;                    ClassInjector.UsingInstrumentation.DISPATCHER.appendToSystemClassLoaderSearch(instrumentation, jarFile);
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;
<b class="fc">&nbsp;            private Target(@MaybeNull ClassLoader classLoader) {</b>
&nbsp;                this.classLoader = classLoader;
&nbsp;            }
&nbsp;
&nbsp;            @MaybeNull
<b class="fc">&nbsp;            protected ClassLoader getClassLoader() {</b>
&nbsp;                return this.classLoader;
&nbsp;            }
&nbsp;
&nbsp;            protected abstract void inject(Instrumentation var1, JarFile var2);
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Proxied(&quot;java.lang.instrument.Instrumentation&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;            @Proxied(&quot;appendToBootstrapClassLoaderSearch&quot;)
&nbsp;            void appendToBootstrapClassLoaderSearch(Instrumentation var1, JarFile var2);
&nbsp;
<b class="fc">&nbsp;            @Proxied(&quot;appendToSystemClassLoaderSearch&quot;)</b>
&nbsp;            void appendToSystemClassLoaderSearch(Instrumentation var1, JarFile var2);
&nbsp;
&nbsp;            @Proxied(&quot;isModifiableModule&quot;)
&nbsp;            boolean isModifiableModule(Instrumentation var1, @Proxied(&quot;java.lang.Module&quot;) Object var2);
&nbsp;
&nbsp;            @Proxied(&quot;redefineModule&quot;)
&nbsp;            void redefineModule(Instrumentation var1, @Proxied(&quot;java.lang.Module&quot;) Object var2, Set&lt;?&gt; var3, Map&lt;String, Set&lt;?&gt;&gt; var4, Map&lt;String, Set&lt;?&gt;&gt; var5, Set&lt;Class&lt;?&gt;&gt; var6, Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; var7);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    @Enhance
&nbsp;    public static class UsingJna extends AbstractBase {
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;        private static final Object BOOTSTRAP_LOADER_LOCK;
&nbsp;        @MaybeNull
&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;        @MaybeNull
&nbsp;        @ValueHandling(Sort.REVERSE_NULLABILITY)
&nbsp;        private final ProtectionDomain protectionDomain;
&nbsp;        private static final boolean ACCESS_CONTROLLER;
&nbsp;
&nbsp;        public UsingJna(@MaybeNull ClassLoader classLoader) {
&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public UsingJna(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {</b>
&nbsp;            this.classLoader = classLoader;
&nbsp;            this.protectionDomain = protectionDomain;
&nbsp;        }
&nbsp;
&nbsp;        @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;            return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public static boolean isAvailable() {</b>
&nbsp;            return DISPATCHER.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofSystemLoader() {
&nbsp;            return new UsingJna(ClassLoader.getSystemClassLoader());
&nbsp;        }
&nbsp;
&nbsp;        public static ClassInjector ofPlatformLoader() {
&nbsp;            return new UsingJna(ClassLoader.getSystemClassLoader().getParent());
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public static ClassInjector ofBootLoader() {</b>
<b class="fc">&nbsp;            return new UsingJna(ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAlive() {
&nbsp;            return DISPATCHER.isAvailable();
&nbsp;        }
&nbsp;
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Set&lt;String&gt; names, ClassFileLocator classFileLocator) {
&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap();
&nbsp;            synchronized(this.classLoader == null ? BOOTSTRAP_LOADER_LOCK : this.classLoader) {
&nbsp;                for(String name : names) {
&nbsp;                    try {
<b class="fc">&nbsp;                        result.put(name, Class.forName(name, false, this.classLoader));</b>
&nbsp;                    } catch (ClassNotFoundException var11) {
&nbsp;                        try {
&nbsp;                            result.put(name, DISPATCHER.defineClass(this.classLoader, name, classFileLocator.locate(name).resolve(), this.protectionDomain));
&nbsp;                        } catch (IOException exception) {
&nbsp;                            throw new IllegalStateException(&quot;Failed to resolve binary representation of &quot; + name, exception);
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                return result;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        static {</b>
<b class="fc">&nbsp;            try {</b>
<b class="pc">&nbsp;                Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);</b>
&nbsp;                ACCESS_CONTROLLER = Boolean.parseBoolean(java.lang.System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;            } catch (ClassNotFoundException var0) {
<b class="fc">&nbsp;                ACCESS_CONTROLLER = false;</b>
&nbsp;            } catch (SecurityException var1) {
<b class="fc">&nbsp;                ACCESS_CONTROLLER = true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            DISPATCHER = (Dispatcher)doPrivileged(ClassInjector.UsingJna.Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;            BOOTSTRAP_LOADER_LOCK = new Object();
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public boolean equals(@MaybeNull Object var1) {</b>
&nbsp;            if (this == var1) {
&nbsp;                return true;
&nbsp;            } else if (var1 == null) {
&nbsp;                return false;
<b class="nc">&nbsp;            } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                ClassLoader var2 = ((UsingJna)var1).classLoader;
<b class="nc">&nbsp;                ClassLoader var3 = this.classLoader;</b>
&nbsp;                if (var2 != null) {
&nbsp;                    if (var3 == null) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!var3.equals(var2)) {
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } else if (var3 != null) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;
&nbsp;                ProtectionDomain var4 = ((UsingJna)var1).protectionDomain;
&nbsp;                ProtectionDomain var5 = this.protectionDomain;
&nbsp;                if (var4 != null) {
&nbsp;                    if (var5 == null) {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    if (!var5.equals(var4)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                } else if (var5 != null) {
&nbsp;                    return false;
&nbsp;                }
<b class="nc">&nbsp;</b>
&nbsp;                return true;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            int var10000 = this.getClass().hashCode() * 31;
&nbsp;            ClassLoader var1 = this.classLoader;
&nbsp;            if (var1 != null) {
&nbsp;                var10000 += var1.hashCode();
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            var10000 *= 31;
&nbsp;            ProtectionDomain var2 = this.protectionDomain;
&nbsp;            if (var2 != null) {
&nbsp;                var10000 += var2.hashCode();
&nbsp;            }
&nbsp;
&nbsp;            return var10000;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        protected interface Dispatcher {
&nbsp;            boolean isAvailable();
&nbsp;
&nbsp;            Class&lt;?&gt; defineClass(@MaybeNull ClassLoader var1, String var2, byte[] var3, @MaybeNull ProtectionDomain var4);
&nbsp;
&nbsp;            public static enum CreationAction implements PrivilegedAction&lt;Dispatcher&gt; {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private CreationAction() {
&nbsp;                }
&nbsp;
&nbsp;                public Dispatcher run() {
&nbsp;                    if (java.lang.System.getProperty(&quot;java.vm.name&quot;, &quot;&quot;).toUpperCase(Locale.US).contains(&quot;J9&quot;)) {
&nbsp;                        return new Unavailable(&quot;J9 does not support JNA-based class definition&quot;);
&nbsp;                    } else {
&nbsp;                        try {
&nbsp;                            Map&lt;String, Object&gt; options = new HashMap();
&nbsp;                            options.put(&quot;allow-objects&quot;, Boolean.TRUE);
&nbsp;                            if (Platform.isWindows() &amp;&amp; !Platform.is64Bit()) {
&nbsp;                                options.put(&quot;function-mapper&quot;, ClassInjector.UsingJna.Dispatcher.Windows32BitFunctionMapper.INSTANCE);
&nbsp;                            }
&nbsp;
&nbsp;                            return new Enabled((Jvm)Native.loadLibrary(&quot;jvm&quot;, Jvm.class, options));
&nbsp;                        } catch (Throwable throwable) {
&nbsp;                            return new Unavailable(throwable.getMessage());
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            public static enum Windows32BitFunctionMapper implements FunctionMapper {
&nbsp;                INSTANCE;
&nbsp;
&nbsp;                private Windows32BitFunctionMapper() {
&nbsp;                }
&nbsp;
&nbsp;                public String getFunctionName(NativeLibrary library, Method method) {
&nbsp;                    return method.getName().equals(&quot;JVM_DefineClass&quot;) ? &quot;_JVM_DefineClass@24&quot; : method.getName();
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Enabled implements Dispatcher {
<b class="fc">&nbsp;                private final Jvm jvm;</b>
&nbsp;
&nbsp;                protected Enabled(Jvm jvm) {
&nbsp;                    this.jvm = jvm;
&nbsp;                }
<b class="fc">&nbsp;</b>
&nbsp;                public boolean isAvailable() {
&nbsp;                    return true;
&nbsp;                }
&nbsp;
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    return this.jvm.JVM_DefineClass(JNIEnv.CURRENT, name.replace(&#39;.&#39;, &#39;/&#39;), classLoader, binaryRepresentation, binaryRepresentation.length, protectionDomain);
<b class="pc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                public boolean equals(@MaybeNull Object var1) {
&nbsp;                    if (this == var1) {
<b class="fc">&nbsp;                        return true;</b>
<b class="fc">&nbsp;                    } else if (var1 == null) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (this.getClass() != var1.getClass()) {</b>
&nbsp;                        return false;
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return this.jvm.equals(((Enabled)var1).jvm);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.jvm.hashCode();
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Enhance
&nbsp;            public static class Unavailable implements Dispatcher {
&nbsp;                private final String error;
<b class="fc">&nbsp;</b>
&nbsp;                protected Unavailable(String error) {
&nbsp;                    this.error = error;
&nbsp;                }
&nbsp;
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return false;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {</b>
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;JNA is not available and JNA-based injection cannot be used: &quot; + this.error);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                public boolean equals(@MaybeNull Object var1) {</b>
<b class="fc">&nbsp;                    if (this == var1) {</b>
&nbsp;                        return true;
<b class="fc">&nbsp;                    } else if (var1 == null) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else if (this.getClass() != var1.getClass()) {</b>
<b class="fc">&nbsp;                        return false;</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        return this.error.equals(((Unavailable)var1).error);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public int hashCode() {
&nbsp;                    return this.getClass().hashCode() * 31 + this.error.hashCode();
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            public interface Jvm extends Library {</b>
<b class="fc">&nbsp;                Class&lt;?&gt; JVM_DefineClass(JNIEnv var1, String var2, @MaybeNull ClassLoader var3, byte[] var4, int var5, @MaybeNull ProtectionDomain var6) throws LastErrorException;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
