


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ClassWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.jar.asm</a>
</div>

<h1>Coverage Summary for Class: ClassWriter (net.bytebuddy.jar.asm)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassWriter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27%
  </span>
  <span class="absValue">
    (10/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.4%
  </span>
  <span class="absValue">
    (77/166)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40.8%
  </span>
  <span class="absValue">
    (135/331)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.jar.asm;
&nbsp;
&nbsp;public class ClassWriter extends ClassVisitor {
&nbsp;    public static final int COMPUTE_MAXS = 1;
&nbsp;    public static final int COMPUTE_FRAMES = 2;
&nbsp;    private final int flags;
&nbsp;    private int version;
&nbsp;    private final SymbolTable symbolTable;
&nbsp;    private int accessFlags;
&nbsp;    private int thisClass;
&nbsp;    private int superClass;
&nbsp;    private int interfaceCount;
&nbsp;    private int[] interfaces;
&nbsp;    private FieldWriter firstField;
&nbsp;    private FieldWriter lastField;
&nbsp;    private MethodWriter firstMethod;
&nbsp;    private MethodWriter lastMethod;
&nbsp;    private int numberOfInnerClasses;
&nbsp;    private ByteVector innerClasses;
&nbsp;    private int enclosingClassIndex;
&nbsp;    private int enclosingMethodIndex;
&nbsp;    private int signatureIndex;
&nbsp;    private int sourceFileIndex;
&nbsp;    private ByteVector debugExtension;
&nbsp;    private AnnotationWriter lastRuntimeVisibleAnnotation;
&nbsp;    private AnnotationWriter lastRuntimeInvisibleAnnotation;
&nbsp;    private AnnotationWriter lastRuntimeVisibleTypeAnnotation;
&nbsp;    private AnnotationWriter lastRuntimeInvisibleTypeAnnotation;
&nbsp;    private ModuleWriter moduleWriter;
&nbsp;    private int nestHostClassIndex;
&nbsp;    private int numberOfNestMemberClasses;
&nbsp;    private ByteVector nestMemberClasses;
&nbsp;    private int numberOfPermittedSubclasses;
&nbsp;    private ByteVector permittedSubclasses;
&nbsp;    private RecordComponentWriter firstRecordComponent;
&nbsp;    private RecordComponentWriter lastRecordComponent;
&nbsp;    private Attribute firstAttribute;
&nbsp;    private int compute;
&nbsp;
&nbsp;    public ClassWriter(int flags) {
&nbsp;        this((ClassReader)null, flags);
&nbsp;    }
&nbsp;
&nbsp;    public ClassWriter(ClassReader classReader, int flags) {
&nbsp;        super(589824);
&nbsp;        this.flags = flags;
&nbsp;        this.symbolTable = classReader == null ? new SymbolTable(this) : new SymbolTable(this, classReader);
&nbsp;        this.setFlags(flags);
&nbsp;    }
&nbsp;
&nbsp;    public boolean hasFlags(int flags) {
&nbsp;        return (this.flags &amp; flags) == flags;
&nbsp;    }
&nbsp;
&nbsp;    public final void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
&nbsp;        this.version = version;
&nbsp;        this.accessFlags = access;
&nbsp;        this.thisClass = this.symbolTable.setMajorVersionAndClassName(version &amp; &#39;\uffff&#39;, name);
&nbsp;        if (signature != null) {
&nbsp;            this.signatureIndex = this.symbolTable.addConstantUtf8(signature);
&nbsp;        }
&nbsp;
&nbsp;        this.superClass = superName == null ? 0 : this.symbolTable.addConstantClass(superName).index;
&nbsp;        if (interfaces != null &amp;&amp; interfaces.length &gt; 0) {
&nbsp;            this.interfaceCount = interfaces.length;
&nbsp;            this.interfaces = new int[this.interfaceCount];
&nbsp;
&nbsp;            for(int i = 0; i &lt; this.interfaceCount; ++i) {
&nbsp;                this.interfaces[i] = this.symbolTable.addConstantClass(interfaces[i]).index;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        if (this.compute == 1 &amp;&amp; (version &amp; &#39;\uffff&#39;) &gt;= 51) {
&nbsp;            this.compute = 2;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public final void visitSource(String file, String debug) {
&nbsp;        if (file != null) {
&nbsp;            this.sourceFileIndex = this.symbolTable.addConstantUtf8(file);
&nbsp;        }
&nbsp;
&nbsp;        if (debug != null) {
&nbsp;            this.debugExtension = (new ByteVector()).encodeUtf8(debug, 0, Integer.MAX_VALUE);
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public final ModuleVisitor visitModule(String name, int access, String version) {
&nbsp;        return this.moduleWriter = new ModuleWriter(this.symbolTable, this.symbolTable.addConstantModule(name).index, access, version == null ? 0 : this.symbolTable.addConstantUtf8(version));
&nbsp;    }
&nbsp;
&nbsp;    public final void visitNestHost(String nestHost) {
&nbsp;        this.nestHostClassIndex = this.symbolTable.addConstantClass(nestHost).index;
&nbsp;    }
&nbsp;
&nbsp;    public final void visitOuterClass(String owner, String name, String descriptor) {
&nbsp;        this.enclosingClassIndex = this.symbolTable.addConstantClass(owner).index;
&nbsp;        if (name != null &amp;&amp; descriptor != null) {
&nbsp;            this.enclosingMethodIndex = this.symbolTable.addConstantNameAndType(name, descriptor);
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public final AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
&nbsp;        return visible ? (this.lastRuntimeVisibleAnnotation = AnnotationWriter.create(this.symbolTable, descriptor, this.lastRuntimeVisibleAnnotation)) : (this.lastRuntimeInvisibleAnnotation = AnnotationWriter.create(this.symbolTable, descriptor, this.lastRuntimeInvisibleAnnotation));
&nbsp;    }
&nbsp;
&nbsp;    public final AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {
&nbsp;        return visible ? (this.lastRuntimeVisibleTypeAnnotation = AnnotationWriter.create(this.symbolTable, typeRef, typePath, descriptor, this.lastRuntimeVisibleTypeAnnotation)) : (this.lastRuntimeInvisibleTypeAnnotation = AnnotationWriter.create(this.symbolTable, typeRef, typePath, descriptor, this.lastRuntimeInvisibleTypeAnnotation));
&nbsp;    }
&nbsp;
&nbsp;    public final void visitAttribute(Attribute attribute) {
&nbsp;        attribute.nextAttribute = this.firstAttribute;
&nbsp;        this.firstAttribute = attribute;
&nbsp;    }
&nbsp;
&nbsp;    public final void visitNestMember(String nestMember) {
&nbsp;        if (this.nestMemberClasses == null) {
&nbsp;            this.nestMemberClasses = new ByteVector();
&nbsp;        }
&nbsp;
&nbsp;        ++this.numberOfNestMemberClasses;
&nbsp;        this.nestMemberClasses.putShort(this.symbolTable.addConstantClass(nestMember).index);
&nbsp;    }
&nbsp;
&nbsp;    public final void visitPermittedSubclass(String permittedSubclass) {
&nbsp;        if (this.permittedSubclasses == null) {
&nbsp;            this.permittedSubclasses = new ByteVector();
&nbsp;        }
&nbsp;
&nbsp;        ++this.numberOfPermittedSubclasses;
&nbsp;        this.permittedSubclasses.putShort(this.symbolTable.addConstantClass(permittedSubclass).index);
&nbsp;    }
&nbsp;
&nbsp;    public final void visitInnerClass(String name, String outerName, String innerName, int access) {
&nbsp;        if (this.innerClasses == null) {
&nbsp;            this.innerClasses = new ByteVector();
&nbsp;        }
&nbsp;
&nbsp;        Symbol nameSymbol = this.symbolTable.addConstantClass(name);
&nbsp;        if (nameSymbol.info == 0) {
&nbsp;            ++this.numberOfInnerClasses;
&nbsp;            this.innerClasses.putShort(nameSymbol.index);
&nbsp;            this.innerClasses.putShort(outerName == null ? 0 : this.symbolTable.addConstantClass(outerName).index);
&nbsp;            this.innerClasses.putShort(innerName == null ? 0 : this.symbolTable.addConstantUtf8(innerName));
&nbsp;            this.innerClasses.putShort(access);
&nbsp;            nameSymbol.info = this.numberOfInnerClasses;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    public final RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {
&nbsp;        RecordComponentWriter recordComponentWriter = new RecordComponentWriter(this.symbolTable, name, descriptor, signature);
&nbsp;        if (this.firstRecordComponent == null) {
&nbsp;            this.firstRecordComponent = recordComponentWriter;
&nbsp;        } else {
&nbsp;            this.lastRecordComponent.delegate = recordComponentWriter;
&nbsp;        }
&nbsp;
&nbsp;        return this.lastRecordComponent = recordComponentWriter;
&nbsp;    }
&nbsp;
&nbsp;    public final FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
&nbsp;        FieldWriter fieldWriter = new FieldWriter(this.symbolTable, access, name, descriptor, signature, value);
&nbsp;        if (this.firstField == null) {
&nbsp;            this.firstField = fieldWriter;
&nbsp;        } else {
&nbsp;            this.lastField.fv = fieldWriter;
&nbsp;        }
&nbsp;
&nbsp;        return this.lastField = fieldWriter;
&nbsp;    }
&nbsp;
&nbsp;    public final MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
&nbsp;        MethodWriter methodWriter = new MethodWriter(this.symbolTable, access, name, descriptor, signature, exceptions, this.compute);
&nbsp;        if (this.firstMethod == null) {
&nbsp;            this.firstMethod = methodWriter;
&nbsp;        } else {
&nbsp;            this.lastMethod.mv = methodWriter;
&nbsp;        }
&nbsp;
&nbsp;        return this.lastMethod = methodWriter;
&nbsp;    }
&nbsp;
&nbsp;    public final void visitEnd() {
&nbsp;    }
&nbsp;
&nbsp;    public byte[] toByteArray() {
&nbsp;        int size = 24 + 2 * this.interfaceCount;
&nbsp;        int fieldsCount = 0;
&nbsp;
&nbsp;        for(FieldWriter fieldWriter = this.firstField; fieldWriter != null; fieldWriter = (FieldWriter)fieldWriter.fv) {
&nbsp;            ++fieldsCount;
&nbsp;            size += fieldWriter.computeFieldInfoSize();
&nbsp;        }
&nbsp;
&nbsp;        int methodsCount = 0;
&nbsp;
&nbsp;        for(MethodWriter methodWriter = this.firstMethod; methodWriter != null; methodWriter = (MethodWriter)methodWriter.mv) {
&nbsp;            ++methodsCount;
&nbsp;            size += methodWriter.computeMethodInfoSize();
&nbsp;        }
&nbsp;
&nbsp;        int attributesCount = 0;
&nbsp;        if (this.innerClasses != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += 8 + this.innerClasses.length;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;InnerClasses&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.enclosingClassIndex != 0) {
&nbsp;            ++attributesCount;
&nbsp;            size += 10;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;EnclosingMethod&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if ((this.accessFlags &amp; 4096) != 0 &amp;&amp; (this.version &amp; &#39;\uffff&#39;) &lt; 49) {
&nbsp;            ++attributesCount;
&nbsp;            size += 6;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;Synthetic&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.signatureIndex != 0) {
&nbsp;            ++attributesCount;
&nbsp;            size += 8;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;Signature&quot;);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (this.sourceFileIndex != 0) {</b>
&nbsp;            ++attributesCount;
&nbsp;            size += 8;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;SourceFile&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.debugExtension != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += 6 + this.debugExtension.length;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;SourceDebugExtension&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if ((this.accessFlags &amp; 131072) != 0) {
&nbsp;            ++attributesCount;
&nbsp;            size += 6;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;Deprecated&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.lastRuntimeVisibleAnnotation != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += this.lastRuntimeVisibleAnnotation.computeAnnotationsSize(&quot;RuntimeVisibleAnnotations&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.lastRuntimeInvisibleAnnotation != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += this.lastRuntimeInvisibleAnnotation.computeAnnotationsSize(&quot;RuntimeInvisibleAnnotations&quot;);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (this.lastRuntimeVisibleTypeAnnotation != null) {</b>
<b class="fc">&nbsp;            ++attributesCount;</b>
<b class="fc">&nbsp;            size += this.lastRuntimeVisibleTypeAnnotation.computeAnnotationsSize(&quot;RuntimeVisibleTypeAnnotations&quot;);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        if (this.lastRuntimeInvisibleTypeAnnotation != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += this.lastRuntimeInvisibleTypeAnnotation.computeAnnotationsSize(&quot;RuntimeInvisibleTypeAnnotations&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.symbolTable.computeBootstrapMethodsSize() &gt; 0) {
&nbsp;            ++attributesCount;
&nbsp;            size += this.symbolTable.computeBootstrapMethodsSize();
&nbsp;        }
&nbsp;
&nbsp;        if (this.moduleWriter != null) {
&nbsp;            attributesCount += this.moduleWriter.getAttributeCount();
&nbsp;            size += this.moduleWriter.computeAttributesSize();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        if (this.nestHostClassIndex != 0) {
&nbsp;            ++attributesCount;
&nbsp;            size += 8;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;NestHost&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.nestMemberClasses != null) {
&nbsp;            ++attributesCount;
&nbsp;            size += 8 + this.nestMemberClasses.length;
&nbsp;            this.symbolTable.addConstantUtf8(&quot;NestMembers&quot;);
&nbsp;        }
&nbsp;
&nbsp;        if (this.permittedSubclasses != null) {
<b class="fc">&nbsp;            ++attributesCount;</b>
<b class="fc">&nbsp;            size += 8 + this.permittedSubclasses.length;</b>
<b class="fc">&nbsp;            this.symbolTable.addConstantUtf8(&quot;PermittedSubclasses&quot;);</b>
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        int recordComponentCount = 0;
<b class="pc">&nbsp;        int recordSize = 0;</b>
<b class="pc">&nbsp;        if ((this.accessFlags &amp; 65536) != 0 || this.firstRecordComponent != null) {</b>
<b class="fc">&nbsp;            for(RecordComponentWriter recordComponentWriter = this.firstRecordComponent; recordComponentWriter != null; recordComponentWriter = (RecordComponentWriter)recordComponentWriter.delegate) {</b>
<b class="fc">&nbsp;                ++recordComponentCount;</b>
<b class="fc">&nbsp;                recordSize += recordComponentWriter.computeRecordComponentInfoSize();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            ++attributesCount;
<b class="pc">&nbsp;            size += 8 + recordSize;</b>
<b class="nc">&nbsp;            this.symbolTable.addConstantUtf8(&quot;Record&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        if (this.firstAttribute != null) {
&nbsp;            attributesCount += this.firstAttribute.getAttributeCount();
&nbsp;            size += this.firstAttribute.computeAttributesSize(this.symbolTable);
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        size += this.symbolTable.getConstantPoolLength();
<b class="pc">&nbsp;        int constantPoolCount = this.symbolTable.getConstantPoolCount();</b>
<b class="nc">&nbsp;        if (constantPoolCount &gt; 65535) {</b>
&nbsp;            throw new ClassTooLargeException(this.symbolTable.getClassName(), constantPoolCount);
&nbsp;        } else {
&nbsp;            ByteVector result = new ByteVector(size);
&nbsp;            result.putInt(-889275714).putInt(this.version);
&nbsp;            this.symbolTable.putConstantPool(result);
&nbsp;            int mask = (this.version &amp; &#39;\uffff&#39;) &lt; 49 ? 4096 : 0;
<b class="nc">&nbsp;            result.putShort(this.accessFlags &amp; ~mask).putShort(this.thisClass).putShort(this.superClass);</b>
&nbsp;            result.putShort(this.interfaceCount);
&nbsp;
<b class="nc">&nbsp;            for(int i = 0; i &lt; this.interfaceCount; ++i) {</b>
&nbsp;                result.putShort(this.interfaces[i]);
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            result.putShort(fieldsCount);
&nbsp;
&nbsp;            for(FieldWriter var16 = this.firstField; var16 != null; var16 = (FieldWriter)var16.fv) {
<b class="nc">&nbsp;                var16.putFieldInfo(result);</b>
&nbsp;            }
&nbsp;
&nbsp;            result.putShort(methodsCount);
&nbsp;            boolean hasFrames = false;
&nbsp;            boolean hasAsmInstructions = false;
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            for(MethodWriter var17 = this.firstMethod; var17 != null; var17 = (MethodWriter)var17.mv) {</b>
<b class="nc">&nbsp;                hasFrames |= var17.hasFrames();</b>
&nbsp;                hasAsmInstructions |= var17.hasAsmInstructions();
&nbsp;                var17.putMethodInfo(result);
&nbsp;            }
&nbsp;
&nbsp;            result.putShort(attributesCount);
<b class="nc">&nbsp;            if (this.innerClasses != null) {</b>
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;InnerClasses&quot;)).putInt(this.innerClasses.length + 2).putShort(this.numberOfInnerClasses).putByteArray(this.innerClasses.data, 0, this.innerClasses.length);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (this.enclosingClassIndex != 0) {</b>
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;EnclosingMethod&quot;)).putInt(4).putShort(this.enclosingClassIndex).putShort(this.enclosingMethodIndex);</b>
&nbsp;            }
&nbsp;
&nbsp;            if ((this.accessFlags &amp; 4096) != 0 &amp;&amp; (this.version &amp; &#39;\uffff&#39;) &lt; 49) {
&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;Synthetic&quot;)).putInt(0);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (this.signatureIndex != 0) {</b>
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;Signature&quot;)).putInt(2).putShort(this.signatureIndex);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            if (this.sourceFileIndex != 0) {
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;SourceFile&quot;)).putInt(2).putShort(this.sourceFileIndex);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            if (this.debugExtension != null) {
&nbsp;                int length = this.debugExtension.length;
&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;SourceDebugExtension&quot;)).putInt(length).putByteArray(this.debugExtension.data, 0, length);
&nbsp;            }
&nbsp;
&nbsp;            if ((this.accessFlags &amp; 131072) != 0) {
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;Deprecated&quot;)).putInt(0);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            AnnotationWriter.putAnnotations(this.symbolTable, this.lastRuntimeVisibleAnnotation, this.lastRuntimeInvisibleAnnotation, this.lastRuntimeVisibleTypeAnnotation, this.lastRuntimeInvisibleTypeAnnotation, result);
&nbsp;            this.symbolTable.putBootstrapMethods(result);
&nbsp;            if (this.moduleWriter != null) {
<b class="nc">&nbsp;                this.moduleWriter.putAttributes(result);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (this.nestHostClassIndex != 0) {</b>
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;NestHost&quot;)).putInt(2).putShort(this.nestHostClassIndex);</b>
&nbsp;            }
&nbsp;
&nbsp;            if (this.nestMemberClasses != null) {
&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;NestMembers&quot;)).putInt(this.nestMemberClasses.length + 2).putShort(this.numberOfNestMemberClasses).putByteArray(this.nestMemberClasses.data, 0, this.nestMemberClasses.length);
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            if (this.permittedSubclasses != null) {
<b class="nc">&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;PermittedSubclasses&quot;)).putInt(this.permittedSubclasses.length + 2).putShort(this.numberOfPermittedSubclasses).putByteArray(this.permittedSubclasses.data, 0, this.permittedSubclasses.length);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            if ((this.accessFlags &amp; 65536) != 0 || this.firstRecordComponent != null) {
&nbsp;                result.putShort(this.symbolTable.addConstantUtf8(&quot;Record&quot;)).putInt(recordSize + 2).putShort(recordComponentCount);
&nbsp;
&nbsp;                for(RecordComponentWriter recordComponentWriter = this.firstRecordComponent; recordComponentWriter != null; recordComponentWriter = (RecordComponentWriter)recordComponentWriter.delegate) {
<b class="fc">&nbsp;                    recordComponentWriter.putRecordComponentInfo(result);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            if (this.firstAttribute != null) {
&nbsp;                this.firstAttribute.putAttributes(this.symbolTable, result);
&nbsp;            }
&nbsp;
&nbsp;            return hasAsmInstructions ? this.replaceAsmInstructions(result.data, hasFrames) : result.data;
<b class="fc">&nbsp;        }</b>
<b class="pc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    private byte[] replaceAsmInstructions(byte[] classFile, boolean hasFrames) {</b>
<b class="pc">&nbsp;        Attribute[] attributes = this.getAttributePrototypes();</b>
<b class="pc">&nbsp;        this.firstField = null;</b>
<b class="fc">&nbsp;        this.lastField = null;</b>
<b class="fc">&nbsp;        this.firstMethod = null;</b>
&nbsp;        this.lastMethod = null;
&nbsp;        this.lastRuntimeVisibleAnnotation = null;
&nbsp;        this.lastRuntimeInvisibleAnnotation = null;
&nbsp;        this.lastRuntimeVisibleTypeAnnotation = null;
&nbsp;        this.lastRuntimeInvisibleTypeAnnotation = null;
&nbsp;        this.moduleWriter = null;
&nbsp;        this.nestHostClassIndex = 0;
&nbsp;        this.numberOfNestMemberClasses = 0;
<b class="nc">&nbsp;        this.nestMemberClasses = null;</b>
&nbsp;        this.numberOfPermittedSubclasses = 0;
<b class="nc">&nbsp;        this.permittedSubclasses = null;</b>
<b class="nc">&nbsp;        this.firstRecordComponent = null;</b>
&nbsp;        this.lastRecordComponent = null;
<b class="nc">&nbsp;        this.firstAttribute = null;</b>
&nbsp;        this.compute = hasFrames ? 3 : 0;
<b class="nc">&nbsp;        (new ClassReader(classFile, 0, false)).accept(this, attributes, (hasFrames ? 8 : 0) | 256);</b>
&nbsp;        return this.toByteArray();
&nbsp;    }
&nbsp;
&nbsp;    private Attribute[] getAttributePrototypes() {
&nbsp;        Attribute.Set attributePrototypes = new Attribute.Set();
&nbsp;        attributePrototypes.addAttributes(this.firstAttribute);
&nbsp;
&nbsp;        for(FieldWriter fieldWriter = this.firstField; fieldWriter != null; fieldWriter = (FieldWriter)fieldWriter.fv) {
&nbsp;            fieldWriter.collectAttributePrototypes(attributePrototypes);
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        for(MethodWriter methodWriter = this.firstMethod; methodWriter != null; methodWriter = (MethodWriter)methodWriter.mv) {</b>
<b class="fc">&nbsp;            methodWriter.collectAttributePrototypes(attributePrototypes);</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        for(RecordComponentWriter recordComponentWriter = this.firstRecordComponent; recordComponentWriter != null; recordComponentWriter = (RecordComponentWriter)recordComponentWriter.delegate) {
<b class="fc">&nbsp;            recordComponentWriter.collectAttributePrototypes(attributePrototypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        return attributePrototypes.toArray();
&nbsp;    }
&nbsp;
&nbsp;    public int newConst(Object value) {
&nbsp;        return this.symbolTable.addConstant(value).index;
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    public int newUTF8(String value) {</b>
&nbsp;        return this.symbolTable.addConstantUtf8(value);
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    public int newClass(String value) {
<b class="fc">&nbsp;        return this.symbolTable.addConstantClass(value).index;</b>
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public int newMethodType(String methodDescriptor) {
&nbsp;        return this.symbolTable.addConstantMethodType(methodDescriptor).index;
&nbsp;    }
&nbsp;
&nbsp;    public int newModule(String moduleName) {
<b class="fc">&nbsp;        return this.symbolTable.addConstantModule(moduleName).index;</b>
&nbsp;    }
&nbsp;
&nbsp;    public int newPackage(String packageName) {
&nbsp;        return this.symbolTable.addConstantPackage(packageName).index;
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @Deprecated
&nbsp;    public int newHandle(int tag, String owner, String name, String descriptor) {
&nbsp;        return this.newHandle(tag, owner, name, descriptor, tag == 9);
&nbsp;    }
&nbsp;
&nbsp;    public int newHandle(int tag, String owner, String name, String descriptor, boolean isInterface) {
&nbsp;        return this.symbolTable.addConstantMethodHandle(tag, owner, name, descriptor, isInterface).index;
&nbsp;    }
&nbsp;
&nbsp;    public int newConstantDynamic(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {
<b class="fc">&nbsp;        return this.symbolTable.addConstantDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public int newInvokeDynamic(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {</b>
<b class="fc">&nbsp;        return this.symbolTable.addConstantInvokeDynamic(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments).index;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    public int newField(String owner, String name, String descriptor) {
<b class="fc">&nbsp;        return this.symbolTable.addConstantFieldref(owner, name, descriptor).index;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public int newMethod(String owner, String name, String descriptor, boolean isInterface) {</b>
<b class="fc">&nbsp;        return this.symbolTable.addConstantMethodref(owner, name, descriptor, isInterface).index;</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int newNameType(String name, String descriptor) {
&nbsp;        return this.symbolTable.addConstantNameAndType(name, descriptor);
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public final void setFlags(int flags) {</b>
<b class="fc">&nbsp;        if ((flags &amp; 2) != 0) {</b>
<b class="fc">&nbsp;            this.compute = 4;</b>
&nbsp;        } else if ((flags &amp; 1) != 0) {
<b class="pc">&nbsp;            this.compute = 1;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            this.compute = 0;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="pc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected String getCommonSuperClass(String type1, String type2) {</b>
<b class="nc">&nbsp;        ClassLoader classLoader = this.getClassLoader();</b>
&nbsp;
<b class="pc">&nbsp;        Class&lt;?&gt; class1;</b>
<b class="nc">&nbsp;        try {</b>
<b class="nc">&nbsp;            class1 = Class.forName(type1.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);</b>
<b class="nc">&nbsp;        } catch (ClassNotFoundException e) {</b>
&nbsp;            throw new TypeNotPresentException(type1, e);
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        Class&lt;?&gt; class2;</b>
<b class="fc">&nbsp;        try {</b>
&nbsp;            class2 = Class.forName(type2.replace(&#39;/&#39;, &#39;.&#39;), false, classLoader);
<b class="pc">&nbsp;        } catch (ClassNotFoundException e) {</b>
<b class="nc">&nbsp;            throw new TypeNotPresentException(type2, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        if (class1.isAssignableFrom(class2)) {
<b class="pc">&nbsp;            return type1;</b>
<b class="nc">&nbsp;        } else if (class2.isAssignableFrom(class1)) {</b>
<b class="nc">&nbsp;            return type2;</b>
<b class="nc">&nbsp;        } else if (!class1.isInterface() &amp;&amp; !class2.isInterface()) {</b>
&nbsp;            do {
<b class="pc">&nbsp;                class1 = class1.getSuperclass();</b>
<b class="nc">&nbsp;            } while(!class1.isAssignableFrom(class2));</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return class1.getName().replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;        } else {
&nbsp;            return &quot;java/lang/Object&quot;;
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected ClassLoader getClassLoader() {</b>
&nbsp;        return this.getClass().getClassLoader();
&nbsp;    }
<b class="pc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
