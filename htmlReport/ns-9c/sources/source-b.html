


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > SubclassBytecodeGenerator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.creation.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: SubclassBytecodeGenerator (org.mockito.internal.creation.bytebuddy)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SubclassBytecodeGenerator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.2%
  </span>
  <span class="absValue">
    (6/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33%
  </span>
  <span class="absValue">
    (33/100)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.3%
  </span>
  <span class="absValue">
    (89/161)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.creation.bytebuddy;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Comparator;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Set;
&nbsp;import java.util.SortedSet;
&nbsp;import java.util.TreeSet;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.SynchronizationState;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.Transformer.ForMethod;
&nbsp;import net.bytebuddy.dynamic.loading.MultipleParentClassLoader;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.implementation.FieldAccessor;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodDelegation;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender.ForInstrumentedMethod;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender.NoOp;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.mockito.codegen.InjectionBase;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.internal.util.StringUtil;
&nbsp;import org.mockito.mock.SerializableMode;
&nbsp;
&nbsp;class SubclassBytecodeGenerator implements BytecodeGenerator {
&nbsp;    private static final String CODEGEN_PACKAGE = &quot;org.mockito.codegen.&quot;;
&nbsp;    private final SubclassLoader loader;
&nbsp;    private final ModuleHandler handler;
&nbsp;    private final ByteBuddy byteBuddy;
&nbsp;    private final Implementation readReplace;
&nbsp;    private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;    private final Implementation dispatcher;
&nbsp;    private final Implementation hashCode;
&nbsp;    private final Implementation equals;
&nbsp;    private final Implementation writeReplace;
&nbsp;
&nbsp;    public SubclassBytecodeGenerator() {
&nbsp;        this(new SubclassInjectionLoader());
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public SubclassBytecodeGenerator(SubclassLoader loader) {</b>
<b class="fc">&nbsp;        this(loader, (Implementation)null, ElementMatchers.any());</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public SubclassBytecodeGenerator(Implementation readReplace, ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
&nbsp;        this(new SubclassInjectionLoader(), readReplace, matcher);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    protected SubclassBytecodeGenerator(SubclassLoader loader, Implementation readReplace, ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
&nbsp;        this.dispatcher = MethodDelegation.to(MockMethodInterceptor.DispatcherDefaultingToRealMethod.class);
&nbsp;        this.hashCode = MethodDelegation.to(MockMethodInterceptor.ForHashCode.class);
&nbsp;        this.equals = MethodDelegation.to(MockMethodInterceptor.ForEquals.class);
&nbsp;        this.writeReplace = MethodDelegation.to(MockMethodInterceptor.ForWriteReplace.class);
<b class="fc">&nbsp;        this.loader = loader;</b>
&nbsp;        this.readReplace = readReplace;
&nbsp;        this.matcher = matcher;
&nbsp;        this.byteBuddy = (new ByteBuddy()).with(TypeValidation.DISABLED);
&nbsp;        this.handler = ModuleHandler.make(this.byteBuddy, loader);
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    private static boolean needsSamePackageClassLoader(MockFeatures&lt;?&gt; features) {</b>
<b class="fc">&nbsp;        if (Modifier.isPublic(features.mockedType.getModifiers()) &amp;&amp; features.mockedType.isInterface()) {</b>
<b class="fc">&nbsp;            if (hasNonPublicTypeReference(features.mockedType)) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else {</b>
&nbsp;                for(Class&lt;?&gt; iface : features.interfaces) {
&nbsp;                    if (!Modifier.isPublic(iface.getModifiers())) {
&nbsp;                        return true;
<b class="pc">&nbsp;                    }</b>
<b class="pc">&nbsp;</b>
&nbsp;                    if (hasNonPublicTypeReference(iface)) {
&nbsp;                        return true;
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        } else {
<b class="pc">&nbsp;            return true;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    private static boolean hasNonPublicTypeReference(Class&lt;?&gt; iface) {</b>
<b class="nc">&nbsp;        for(Method method : iface.getMethods()) {</b>
&nbsp;            if (!Modifier.isPublic(method.getReturnType().getModifiers())) {
&nbsp;                return true;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            for(Class&lt;?&gt; param : method.getParameterTypes()) {
&nbsp;                if (!Modifier.isPublic(param.getModifiers())) {
<b class="fc">&nbsp;                    return true;</b>
<b class="pc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;        return false;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public &lt;T&gt; Class&lt;? extends T&gt; mockClass(MockFeatures&lt;T&gt; features) {
&nbsp;        MultipleParentClassLoader.Builder loaderBuilder = (new MultipleParentClassLoader.Builder()).appendMostSpecific(new Class[]{features.mockedType}).appendMostSpecific(features.interfaces).appendMostSpecific(new Class[]{MockAccess.class, MockMethodInterceptor.DispatcherDefaultingToRealMethod.class}).appendMostSpecific(new Class[]{MockMethodInterceptor.class, MockMethodInterceptor.ForHashCode.class, MockMethodInterceptor.ForEquals.class});
<b class="fc">&nbsp;        ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();</b>
&nbsp;        boolean shouldIncludeContextLoader = true;
&nbsp;        if (needsSamePackageClassLoader(features)) {
&nbsp;            ClassLoader candidateLoader = loaderBuilder.build();
&nbsp;
<b class="fc">&nbsp;            for(ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {</b>
&nbsp;                if (parent == candidateLoader) {
<b class="fc">&nbsp;                    shouldIncludeContextLoader = false;</b>
<b class="fc">&nbsp;                    break;</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        if (shouldIncludeContextLoader) {
&nbsp;            loaderBuilder = loaderBuilder.appendMostSpecific(new ClassLoader[]{contextLoader});
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;        ClassLoader classLoader = loaderBuilder.build();</b>
&nbsp;        boolean localMock = classLoader == features.mockedType.getClassLoader() &amp;&amp; features.serializableMode != SerializableMode.ACROSS_CLASSLOADERS &amp;&amp; !this.isComingFromJDK(features.mockedType) &amp;&amp; (this.loader.isDisrespectingOpenness() || this.handler.isOpened(features.mockedType, MockAccess.class)) &amp;&amp; !GraalImageCode.getCurrent().isDefined();
&nbsp;        String typeName;
&nbsp;        if (!localMock &amp;&amp; (!(this.loader instanceof MultipleParentClassLoader) || this.isComingFromJDK(features.mockedType))) {
&nbsp;            String var10000 = InjectionBase.class.getPackage().getName();
&nbsp;            typeName = var10000 + &quot;.&quot; + features.mockedType.getSimpleName();
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            typeName = features.mockedType.getName();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        String name = String.format(&quot;%s$%s$%s&quot;, typeName, &quot;MockitoMock&quot;, GraalImageCode.getCurrent().isDefined() ? suffix(features) : RandomString.make());
&nbsp;        if (localMock) {
&nbsp;            this.handler.adjustModuleGraph(features.mockedType, MockAccess.class, false, true);
&nbsp;
<b class="pc">&nbsp;            for(Class&lt;?&gt; iFace : features.interfaces) {</b>
<b class="fc">&nbsp;                this.handler.adjustModuleGraph(iFace, features.mockedType, true, false);</b>
&nbsp;                this.handler.adjustModuleGraph(features.mockedType, iFace, false, true);
<b class="fc">&nbsp;            }</b>
&nbsp;        } else {
&nbsp;            boolean exported = this.handler.isExported(features.mockedType);
&nbsp;
&nbsp;            for(Iterator&lt;Class&lt;?&gt;&gt; it = features.interfaces.iterator(); exported &amp;&amp; it.hasNext(); exported = this.handler.isExported((Class)it.next())) {
&nbsp;            }
&nbsp;
&nbsp;            if (exported) {
&nbsp;                assertVisibility(features.mockedType);
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                for(Class&lt;?&gt; iFace : features.interfaces) {</b>
&nbsp;                    assertVisibility(iFace);
<b class="pc">&nbsp;                }</b>
<b class="pc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                Class&lt;?&gt; hook = this.handler.injectionBase(classLoader, typeName);</b>
<b class="fc">&nbsp;                assertVisibility(features.mockedType);</b>
&nbsp;                this.handler.adjustModuleGraph(features.mockedType, hook, true, false);
<b class="pc">&nbsp;</b>
&nbsp;                for(Class&lt;?&gt; iFace : features.interfaces) {
<b class="nc">&nbsp;                    assertVisibility(iFace);</b>
<b class="fc">&nbsp;                    this.handler.adjustModuleGraph(iFace, hook, true, false);</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        Class&lt;T&gt; target = GraalImageCode.getCurrent().isDefined() &amp;&amp; features.mockedType.isInterface() ? Object.class : features.mockedType;</b>
&nbsp;        Annotation[] annotationsOnType;
<b class="fc">&nbsp;        if (features.stripAnnotations) {</b>
<b class="fc">&nbsp;            annotationsOnType = new Annotation[0];</b>
&nbsp;        } else if (features.mockedType.isInterface() &amp;&amp; !features.interfaces.isEmpty()) {
&nbsp;            annotationsOnType = new Annotation[0];
&nbsp;        } else {
<b class="pc">&nbsp;            annotationsOnType = features.mockedType.getAnnotations();</b>
<b class="nc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        DynamicType.Builder&lt;T&gt; builder = this.byteBuddy.subclass(target).name(name).ignoreAlso(BytecodeGenerator.isGroovyMethod(false)).annotateType(annotationsOnType).implement(new ArrayList((Collection)(GraalImageCode.getCurrent().isDefined() ? sortedSerializable(features.interfaces, GraalImageCode.getCurrent().isDefined() &amp;&amp; features.mockedType.isInterface() ? features.mockedType : Void.TYPE) : features.interfaces))).method(this.matcher).intercept(this.dispatcher).transform(ForMethod.withModifiers(new ModifierContributor.ForMethod[]{SynchronizationState.PLAIN})).attribute((MethodAttributeAppender.Factory)(features.stripAnnotations ? NoOp.INSTANCE : ForInstrumentedMethod.INCLUDING_RECEIVER)).serialVersionUid(42L).defineField(&quot;mockitoInterceptor&quot;, MockMethodInterceptor.class, new ModifierContributor.ForField[]{Visibility.PRIVATE}).implement(new Type[]{MockAccess.class}).intercept(FieldAccessor.ofBeanProperty()).method(ElementMatchers.isHashCode()).intercept(this.hashCode).method(ElementMatchers.isEquals()).intercept(this.equals);
<b class="pc">&nbsp;        if (features.serializableMode == SerializableMode.ACROSS_CLASSLOADERS) {</b>
<b class="fc">&nbsp;            builder = builder.implement(new Type[]{ByteBuddyCrossClassLoaderSerializationSupport.CrossClassLoaderSerializableMock.class}).intercept(this.writeReplace);</b>
<b class="pc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        if (this.readReplace != null) {</b>
&nbsp;            builder = builder.defineMethod(&quot;readObject&quot;, Void.TYPE, new ModifierContributor.ForMethod[]{Visibility.PRIVATE}).withParameters(new Type[]{ObjectInputStream.class}).throwing(new Type[]{ClassNotFoundException.class, IOException.class}).intercept(this.readReplace);
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        if (name.startsWith(&quot;org.mockito.codegen.&quot;) || classLoader instanceof MultipleParentClassLoader) {</b>
<b class="nc">&nbsp;            builder = builder.ignoreAlso(ElementMatchers.isPackagePrivate().or(ElementMatchers.returns(ElementMatchers.isPackagePrivate())).or(ElementMatchers.hasParameters(ElementMatchers.whereAny(ElementMatchers.hasType(ElementMatchers.isPackagePrivate())))));</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return builder.make().load(classLoader, this.loader.resolveStrategy(features.mockedType, classLoader, localMock)).getLoaded();
&nbsp;    }
&nbsp;
&nbsp;    private static CharSequence suffix(MockFeatures&lt;?&gt; features) {
&nbsp;        StringBuilder sb = new StringBuilder();
<b class="nc">&nbsp;        Set&lt;String&gt; names = new TreeSet();</b>
<b class="nc">&nbsp;        names.add(features.mockedType.getName());</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        for(Class&lt;?&gt; type : features.interfaces) {</b>
&nbsp;            names.add(type.getName());
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        return sb.append(RandomString.hashOf(names.hashCode())).append(RandomString.hashOf(features.serializableMode.name().hashCode())).append(features.stripAnnotations ? &quot;S&quot; : &quot;N&quot;);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static Collection&lt;? extends Type&gt; sortedSerializable(Collection&lt;Class&lt;?&gt;&gt; interfaces, Class&lt;?&gt; mockedType) {</b>
<b class="nc">&nbsp;        SortedSet&lt;Class&lt;?&gt;&gt; types = new TreeSet(Comparator.comparing(Class::getName));</b>
&nbsp;        types.addAll(interfaces);
&nbsp;        if (mockedType != Void.TYPE) {
&nbsp;            types.add(mockedType);
&nbsp;        }
&nbsp;
&nbsp;        types.add(Serializable.class);
&nbsp;        return types;
&nbsp;    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;    public void mockClassStatic(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;        throw new MockitoException(&quot;The subclass byte code generator cannot create static mocks&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    public void mockClassConstruction(Class&lt;?&gt; type) {
&nbsp;        throw new MockitoException(&quot;The subclass byte code generator cannot create construction mocks&quot;);
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    private boolean isComingFromJDK(Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;        return type.getPackage() != null &amp;&amp; &quot;Java Runtime Environment&quot;.equalsIgnoreCase(type.getPackage().getImplementationTitle()) || type.getName().startsWith(&quot;java.&quot;) || type.getName().startsWith(&quot;javax.&quot;);</b>
<b class="pc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    private static void assertVisibility(Class&lt;?&gt; type) {
<b class="nc">&nbsp;        if (!Modifier.isPublic(type.getModifiers())) {</b>
&nbsp;            throw new MockitoException(StringUtil.join(new Object[]{&quot;Cannot create mock for &quot; + String.valueOf(type), &quot;&quot;, &quot;The type is not public and its mock class is loaded by a different class loader.&quot;, &quot;This can have multiple reasons:&quot;, &quot; - You are mocking a class with additional interfaces of another class loader&quot;, &quot; - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)&quot;, &quot; - The thread&#39;s context class loader is different than the mock&#39;s class loader&quot;}));
<b class="fc">&nbsp;        }</b>
&nbsp;    }
<b class="fc">&nbsp;}</b>
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:43</div>
</div>
</body>
</html>
