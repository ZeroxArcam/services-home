


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ReflectionUtils</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.junit.platform.commons.util</a>
</div>

<h1>Coverage Summary for Class: ReflectionUtils (org.junit.platform.commons.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ReflectionUtils</td>
<td class="coverageStat">
  <span class="percent">
    35.4%
  </span>
  <span class="absValue">
    (46/130)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (42/252)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.6%
  </span>
  <span class="absValue">
    (192/497)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ReflectionUtils$HierarchyTraversalMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    36.4%
  </span>
  <span class="absValue">
    (48/132)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (42/252)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39%
  </span>
  <span class="absValue">
    (195/500)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.junit.platform.commons.util;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Executable;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.GenericArrayType;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Member;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.net.URI;
&nbsp;import java.nio.file.Files;
&nbsp;import java.nio.file.LinkOption;
&nbsp;import java.nio.file.Path;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Optional;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.Stream;
&nbsp;import org.apiguardian.api.API;
&nbsp;import org.apiguardian.api.API.Status;
&nbsp;import org.junit.platform.commons.JUnitException;
&nbsp;import org.junit.platform.commons.function.Try;
&nbsp;import org.junit.platform.commons.logging.Logger;
&nbsp;import org.junit.platform.commons.logging.LoggerFactory;
&nbsp;import org.junit.platform.commons.support.Resource;
&nbsp;
&nbsp;@API(
&nbsp;    status = Status.INTERNAL,
&nbsp;    since = &quot;1.0&quot;
&nbsp;)
&nbsp;public final class ReflectionUtils {
&nbsp;    private static final String USE_LEGACY_SEARCH_SEMANTICS_PROPERTY_NAME = &quot;junit.platform.reflection.search.useLegacySemantics&quot;;
&nbsp;    private static final Logger logger = LoggerFactory.getLogger(ReflectionUtils.class);
&nbsp;    private static final Pattern VM_INTERNAL_OBJECT_ARRAY_PATTERN = Pattern.compile(&quot;^(\\[+)L(.+);$&quot;);
&nbsp;    private static final Pattern VM_INTERNAL_PRIMITIVE_ARRAY_PATTERN = Pattern.compile(&quot;^(\\[+)(\\[[ZBCDFIJS])$&quot;);
&nbsp;    private static final Pattern SOURCE_CODE_SYNTAX_ARRAY_PATTERN = Pattern.compile(&quot;^([^\\[\\]]+)((?&gt;\\[\\])++)$&quot;);
&nbsp;    private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class[0];
&nbsp;    private static final ClasspathScanner classpathScanner = new ClasspathScanner(ClassLoaderUtils::getDefaultClassLoader, ReflectionUtils::tryToLoadClass);
&nbsp;    private static final Map&lt;Method, Method&gt; interfaceMethodCache = Collections.synchronizedMap(new LruCache(255));
&nbsp;    private static final Set&lt;String&gt; noCyclesDetectedCache = ConcurrentHashMap.newKeySet();
&nbsp;    private static final Map&lt;String, Class&lt;?&gt;&gt; classNameToTypeMap;
&nbsp;    private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitiveToWrapperMap;
&nbsp;    static volatile boolean useLegacySearchSemantics;
&nbsp;
&nbsp;    private ReflectionUtils() {
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPublic(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isPublic(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPublic(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isPublic(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrivate(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isPrivate(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isPrivate(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isPrivate(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static boolean isNotPrivate(Class&lt;?&gt; clazz) {
&nbsp;        return !isPrivate(clazz);
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.1&quot;
&nbsp;    )
<b class="fc">&nbsp;    public static boolean isNotPrivate(Member member) {</b>
&nbsp;        return !isPrivate(member);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAbstract(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return Modifier.isAbstract(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAbstract(Member member) {
<b class="fc">&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);</b>
&nbsp;        return Modifier.isAbstract(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isStatic(Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);</b>
&nbsp;        return Modifier.isStatic(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
<b class="fc">&nbsp;        status = Status.INTERNAL,</b>
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static boolean isNotStatic(Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;        return !isStatic(clazz);</b>
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isStatic(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
&nbsp;        return Modifier.isStatic(member.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.1&quot;
&nbsp;    )
<b class="fc">&nbsp;    public static boolean isNotStatic(Member member) {</b>
&nbsp;        return !isStatic(member);
&nbsp;    }
&nbsp;
&nbsp;    @API(
<b class="fc">&nbsp;        status = Status.INTERNAL,</b>
&nbsp;        since = &quot;1.5&quot;
<b class="fc">&nbsp;    )</b>
&nbsp;    public static boolean isFinal(Class&lt;?&gt; clazz) {
<b class="fc">&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);</b>
&nbsp;        return Modifier.isFinal(clazz.getModifiers());
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
<b class="fc">&nbsp;    public static boolean isNotFinal(Class&lt;?&gt; clazz) {</b>
&nbsp;        return !isFinal(clazz);
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isFinal(Member member) {
&nbsp;        Preconditions.notNull(member, &quot;Member must not be null&quot;);
<b class="fc">&nbsp;        return Modifier.isFinal(member.getModifiers());</b>
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.5&quot;
&nbsp;    )
&nbsp;    public static boolean isNotFinal(Member member) {
&nbsp;        return !isFinal(member);
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isInnerClass(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        return !isStatic(clazz) &amp;&amp; clazz.isMemberClass();
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static boolean returnsPrimitiveVoid(Method method) {
&nbsp;        return method.getReturnType() == Void.TYPE;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isArray(Object obj) {
&nbsp;        return obj != null &amp;&amp; obj.getClass().isArray();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.3.2&quot;
&nbsp;    )
&nbsp;    public static boolean isMultidimensionalArray(Object obj) {
&nbsp;        return obj != null &amp;&amp; obj.getClass().isArray() &amp;&amp; obj.getClass().getComponentType().isArray();
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAssignableTo(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.notNull(sourceType, &quot;source type must not be null&quot;);
&nbsp;        Preconditions.condition(!sourceType.isPrimitive(), &quot;source type must not be a primitive type&quot;);
&nbsp;        Preconditions.notNull(targetType, &quot;target type must not be null&quot;);
&nbsp;        if (targetType.isAssignableFrom(sourceType)) {
&nbsp;            return true;
&nbsp;        } else if (!targetType.isPrimitive()) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            return sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isAssignableTo(Object obj, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.notNull(targetType, &quot;target type must not be null&quot;);
&nbsp;        if (obj == null) {
&nbsp;            return !targetType.isPrimitive();
&nbsp;        } else if (targetType.isInstance(obj)) {
&nbsp;            return true;
&nbsp;        } else if (!targetType.isPrimitive()) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            Class&lt;?&gt; sourceType = obj.getClass();
&nbsp;            return sourceType == primitiveToWrapperMap.get(targetType) || isWideningConversion(sourceType, targetType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    static boolean isWideningConversion(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType) {
&nbsp;        Preconditions.condition(targetType.isPrimitive(), &quot;targetType must be primitive&quot;);
&nbsp;        boolean isPrimitive = sourceType.isPrimitive();
&nbsp;        boolean isWrapper = primitiveToWrapperMap.containsValue(sourceType);
&nbsp;        if (!isPrimitive &amp;&amp; !isWrapper) {
&nbsp;            return false;
&nbsp;        } else {
&nbsp;            if (isPrimitive) {
&nbsp;                sourceType = (Class)primitiveToWrapperMap.get(sourceType);
&nbsp;            }
&nbsp;
&nbsp;            if (sourceType == Byte.class) {
&nbsp;                return targetType == Short.TYPE || targetType == Integer.TYPE || targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;
&nbsp;            } else if (sourceType != Short.class &amp;&amp; sourceType != Character.class) {
&nbsp;                if (sourceType == Integer.class) {
<b class="fc">&nbsp;                    return targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;</b>
&nbsp;                } else if (sourceType != Long.class) {
<b class="fc">&nbsp;                    if (sourceType == Float.class) {</b>
<b class="fc">&nbsp;                        return targetType == Double.TYPE;</b>
<b class="fc">&nbsp;                    } else {</b>
&nbsp;                        return false;
&nbsp;                    }
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    return targetType == Float.TYPE || targetType == Double.TYPE;
<b class="fc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return targetType == Integer.TYPE || targetType == Long.TYPE || targetType == Float.TYPE || targetType == Double.TYPE;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static Class&lt;?&gt; getWrapperType(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;        return (Class)primitiveToWrapperMap.get(type);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    public static &lt;T&gt; T newInstance(Class&lt;T&gt; clazz, Object... args) {</b>
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(args, &quot;Argument array must not be null&quot;);
<b class="fc">&nbsp;        Preconditions.containsNoNullElements(args, &quot;Individual arguments must not be null&quot;);</b>
&nbsp;
&nbsp;        try {
<b class="fc">&nbsp;            Class&lt;?&gt;[] parameterTypes = (Class[])Arrays.stream(args).map(Object::getClass).toArray((x$0) -&gt; new Class[x$0]);</b>
<b class="fc">&nbsp;            return (T)newInstance(clazz.getDeclaredConstructor(parameterTypes), args);</b>
&nbsp;        } catch (Throwable t) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    public static &lt;T&gt; T newInstance(Constructor&lt;T&gt; constructor, Object... args) {
&nbsp;        Preconditions.notNull(constructor, &quot;Constructor must not be null&quot;);
&nbsp;
<b class="fc">&nbsp;        try {</b>
<b class="fc">&nbsp;            return (T)((Constructor)makeAccessible(constructor)).newInstance(args);</b>
&nbsp;        } catch (Throwable t) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));
&nbsp;        }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
<b class="nc">&nbsp;    )</b>
&nbsp;    @Deprecated
&nbsp;    public static &lt;T&gt; Optional&lt;Object&gt; readFieldValue(Class&lt;T&gt; clazz, String fieldName, T instance) {
&nbsp;        return tryToReadFieldValue(clazz, fieldName, instance).toOptional();
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
<b class="fc">&nbsp;    )</b>
<b class="fc">&nbsp;    public static &lt;T&gt; Try&lt;Object&gt; tryToReadFieldValue(Class&lt;T&gt; clazz, String fieldName, T instance) {</b>
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(fieldName, &quot;Field name must not be null or blank&quot;);
&nbsp;        return Try.call(() -&gt; clazz.getDeclaredField(fieldName)).andThen((field) -&gt; tryToReadFieldValue(field, instance));
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
<b class="fc">&nbsp;        since = &quot;1.4&quot;</b>
<b class="fc">&nbsp;    )</b>
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Object&gt; readFieldValue(Field field) {
&nbsp;        return tryToReadFieldValue(field).toOptional();
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
<b class="fc">&nbsp;    )</b>
<b class="fc">&nbsp;    public static Try&lt;Object&gt; tryToReadFieldValue(Field field) {</b>
&nbsp;        return tryToReadFieldValue(field, (Object)null);
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
<b class="fc">&nbsp;    @API(</b>
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Object&gt; readFieldValue(Field field, Object instance) {
&nbsp;        return tryToReadFieldValue(field, instance).toOptional();
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @API(</b>
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Object&gt; tryToReadFieldValue(Field field, Object instance) {
&nbsp;        Preconditions.notNull(field, &quot;Field must not be null&quot;);
&nbsp;        Preconditions.condition(instance != null || isStatic(field), () -&gt; String.format(&quot;Cannot read non-static field [%s] on a null instance.&quot;, field));
&nbsp;        return Try.call(() -&gt; makeAccessible(field).get(instance));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static List&lt;Object&gt; readFieldValues(List&lt;Field&gt; fields, Object instance) {
&nbsp;        return readFieldValues(fields, instance, (field) -&gt; true);
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Object&gt; readFieldValues(List&lt;Field&gt; fields, Object instance, Predicate&lt;Field&gt; predicate) {
&nbsp;        Preconditions.notNull(fields, &quot;fields list must not be null&quot;);
<b class="nc">&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);</b>
<b class="nc">&nbsp;        return (List)fields.stream().filter(predicate).map((field) -&gt; tryToReadFieldValue(field, instance).getOrThrow(ExceptionUtils::throwAsUncheckedException)).collect(CollectionUtils.toUnmodifiableList());</b>
&nbsp;    }
&nbsp;
&nbsp;    public static Object invokeMethod(Method method, Object target, Object... args) {
&nbsp;        Preconditions.notNull(method, &quot;Method must not be null&quot;);
&nbsp;        Preconditions.condition(target != null || isStatic(method), () -&gt; String.format(&quot;Cannot invoke non-static method [%s] on a null target.&quot;, method.toGenericString()));
&nbsp;
&nbsp;        try {
<b class="nc">&nbsp;            return ((Method)makeAccessible(method)).invoke(target, args);</b>
&nbsp;        } catch (Throwable t) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Class&lt;?&gt;&gt; loadClass(String name) {
&nbsp;        return tryToLoadClass(name).toOptional();
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    @API(</b>
<b class="pc">&nbsp;        status = Status.INTERNAL,</b>
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Class&lt;?&gt;&gt; tryToLoadClass(String name) {
&nbsp;        return tryToLoadClass(name, ClassLoaderUtils.getDefaultClassLoader());
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
<b class="pc">&nbsp;        since = &quot;1.4&quot;</b>
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    public static Optional&lt;Class&lt;?&gt;&gt; loadClass(String name, ClassLoader classLoader) {
&nbsp;        return tryToLoadClass(name, classLoader).toOptional();
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.11&quot;
<b class="nc">&nbsp;    )</b>
&nbsp;    public static Class&lt;?&gt; loadRequiredClass(String name, ClassLoader classLoader) throws JUnitException {
&nbsp;        return (Class)tryToLoadClass(name, classLoader).getOrThrow((cause) -&gt; new JUnitException(String.format(&quot;Could not load class [%s]&quot;, name), cause));
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Class&lt;?&gt;&gt; tryToLoadClass(String name, ClassLoader classLoader) {
&nbsp;        Preconditions.notBlank(name, &quot;Class name must not be null or blank&quot;);
&nbsp;        Preconditions.notNull(classLoader, &quot;ClassLoader must not be null&quot;);
<b class="nc">&nbsp;        String trimmedName = name.trim();</b>
&nbsp;        return classNameToTypeMap.containsKey(trimmedName) ? Try.success((Class)classNameToTypeMap.get(trimmedName)) : Try.call(() -&gt; {
&nbsp;            Matcher matcher = VM_INTERNAL_PRIMITIVE_ARRAY_PATTERN.matcher(trimmedName);
&nbsp;            if (matcher.matches()) {
&nbsp;                String brackets = matcher.group(1);
&nbsp;                String componentTypeName = matcher.group(2);
&nbsp;                int dimensions = brackets.length();
&nbsp;                return loadArrayType(classLoader, componentTypeName, dimensions);
&nbsp;            } else {
&nbsp;                matcher = VM_INTERNAL_OBJECT_ARRAY_PATTERN.matcher(trimmedName);
&nbsp;                if (matcher.matches()) {
&nbsp;                    String brackets = matcher.group(1);
&nbsp;                    String componentTypeName = matcher.group(2);
&nbsp;                    int dimensions = brackets.length();
&nbsp;                    return loadArrayType(classLoader, componentTypeName, dimensions);
&nbsp;                } else {
&nbsp;                    matcher = SOURCE_CODE_SYNTAX_ARRAY_PATTERN.matcher(trimmedName);
&nbsp;                    if (matcher.matches()) {
&nbsp;                        String componentTypeName = matcher.group(1);
&nbsp;                        String bracketPairs = matcher.group(2);
&nbsp;                        int dimensions = bracketPairs.length() / 2;
&nbsp;                        return loadArrayType(classLoader, componentTypeName, dimensions);
&nbsp;                    } else {
&nbsp;                        return Class.forName(trimmedName, false, classLoader);
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        });
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private static Class&lt;?&gt; loadArrayType(ClassLoader classLoader, String componentTypeName, int dimensions) throws ClassNotFoundException {
&nbsp;        Class&lt;?&gt; componentType = classNameToTypeMap.containsKey(componentTypeName) ? (Class)classNameToTypeMap.get(componentTypeName) : Class.forName(componentTypeName, false, classLoader);
<b class="nc">&nbsp;        return Array.newInstance(componentType, new int[dimensions]).getClass();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static String getFullyQualifiedMethodName(Class&lt;?&gt; clazz, Method method) {
<b class="nc">&nbsp;        Preconditions.notNull(method, &quot;Method must not be null&quot;);</b>
&nbsp;        return getFullyQualifiedMethodName(clazz, method.getName(), method.getParameterTypes());
&nbsp;    }
&nbsp;
&nbsp;    public static String getFullyQualifiedMethodName(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return getFullyQualifiedMethodName(clazz.getName(), methodName, ClassUtils.nullSafeToString(parameterTypes));
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.11&quot;
&nbsp;    )
&nbsp;    public static String getFullyQualifiedMethodName(String className, String methodName, String parameterTypeNames) {
&nbsp;        Preconditions.notBlank(className, &quot;Class name must not be null or blank&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        Preconditions.notNull(parameterTypeNames, &quot;Parameter type names must not be null&quot;);
&nbsp;        return String.format(&quot;%s#%s(%s)&quot;, className, methodName, parameterTypeNames);
&nbsp;    }
&nbsp;
&nbsp;    public static String[] parseFullyQualifiedMethodName(String fullyQualifiedMethodName) {
&nbsp;        Preconditions.notBlank(fullyQualifiedMethodName, &quot;fullyQualifiedMethodName must not be null or blank&quot;);
&nbsp;        int indexOfFirstHashtag = fullyQualifiedMethodName.indexOf(35);
&nbsp;        boolean validSyntax = indexOfFirstHashtag &gt; 0 &amp;&amp; indexOfFirstHashtag &lt; fullyQualifiedMethodName.length() - 1;
&nbsp;        Preconditions.condition(validSyntax, () -&gt; &quot;[&quot; + fullyQualifiedMethodName + &quot;] is not a valid fully qualified method name: it must start with a fully qualified class name followed by a &#39;#&#39; and then the method name, optionally followed by a parameter list enclosed in parentheses.&quot;);
<b class="fc">&nbsp;        String className = fullyQualifiedMethodName.substring(0, indexOfFirstHashtag);</b>
&nbsp;        String methodPart = fullyQualifiedMethodName.substring(indexOfFirstHashtag + 1);
<b class="pc">&nbsp;        String methodName = methodPart;</b>
<b class="nc">&nbsp;        String methodParameters = &quot;&quot;;</b>
&nbsp;        if (methodPart.endsWith(&quot;()&quot;)) {
&nbsp;            methodName = methodPart.substring(0, methodPart.length() - 2);
<b class="pc">&nbsp;        } else if (methodPart.endsWith(&quot;)&quot;)) {</b>
<b class="fc">&nbsp;            int indexOfLastOpeningParenthesis = methodPart.lastIndexOf(40);</b>
&nbsp;            if (indexOfLastOpeningParenthesis &gt; 0 &amp;&amp; indexOfLastOpeningParenthesis &lt; methodPart.length() - 1) {
&nbsp;                methodName = methodPart.substring(0, indexOfLastOpeningParenthesis);
<b class="nc">&nbsp;                methodParameters = methodPart.substring(indexOfLastOpeningParenthesis + 1, methodPart.length() - 1);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return new String[]{className, methodName, methodParameters};
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.11&quot;
&nbsp;    )
&nbsp;    public static String[] parseFullyQualifiedFieldName(String fullyQualifiedFieldName) {
&nbsp;        Preconditions.notBlank(fullyQualifiedFieldName, &quot;fullyQualifiedFieldName must not be null or blank&quot;);
<b class="nc">&nbsp;        int indexOfHashtag = fullyQualifiedFieldName.indexOf(35);</b>
&nbsp;        boolean validSyntax = indexOfHashtag &gt; 0 &amp;&amp; indexOfHashtag &lt; fullyQualifiedFieldName.length() - 1;
<b class="nc">&nbsp;        Preconditions.condition(validSyntax, () -&gt; &quot;[&quot; + fullyQualifiedFieldName + &quot;] is not a valid fully qualified field name: it must start with a fully qualified class name followed by a &#39;#&#39; and then the field name.&quot;);</b>
<b class="nc">&nbsp;        return fullyQualifiedFieldName.split(&quot;#&quot;);</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Set&lt;Path&gt; getAllClasspathRootDirectories() {</b>
<b class="nc">&nbsp;        String fullClassPath = System.getProperty(&quot;java.class.path&quot;);</b>
&nbsp;        return (Set)Arrays.stream(fullClassPath.split(File.pathSeparator)).map((x$0) -&gt; Paths.get(x$0)).filter((x$0) -&gt; Files.isDirectory(x$0, new LinkOption[0])).collect(Collectors.toSet());
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInClasspathRoot(URI root, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {</b>
&nbsp;        return findAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInClasspathRoot(URI root, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {</b>
<b class="nc">&nbsp;        return streamAllClassesInClasspathRoot(root, ClassFilter.of(classNameFilter, classFilter));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForClassesInClasspathRoot(root, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Resource&gt; findAllResourcesInClasspathRoot(URI root, Predicate&lt;Resource&gt; resourceFilter) {
<b class="nc">&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForResourcesInClasspathRoot(root, resourceFilter));</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInClasspathRoot(URI root, ClassFilter classFilter) {
&nbsp;        return findAllClassesInClasspathRoot(root, classFilter).stream();
&nbsp;    }
&nbsp;
&nbsp;    public static Stream&lt;Resource&gt; streamAllResourcesInClasspathRoot(URI root, Predicate&lt;Resource&gt; resourceFilter) {
<b class="nc">&nbsp;        return findAllResourcesInClasspathRoot(root, resourceFilter).stream();</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInPackage(String basePackageName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return findAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInPackage(String basePackageName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {</b>
<b class="nc">&nbsp;        return streamAllClassesInPackage(basePackageName, ClassFilter.of(classNameFilter, classFilter));</b>
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInPackage(String basePackageName, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForClassesInPackage(basePackageName, classFilter));
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    public static List&lt;Resource&gt; findAllResourcesInPackage(String basePackageName, Predicate&lt;Resource&gt; resourceFilter) {
&nbsp;        return Collections.unmodifiableList(classpathScanner.scanForResourcesInPackage(basePackageName, resourceFilter));
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInPackage(String basePackageName, ClassFilter classFilter) {</b>
&nbsp;        return findAllClassesInPackage(basePackageName, classFilter).stream();
&nbsp;    }
&nbsp;
&nbsp;    public static Stream&lt;Resource&gt; streamAllResourcesInPackage(String basePackageName, Predicate&lt;Resource&gt; resourceFilter) {
&nbsp;        return findAllResourcesInPackage(basePackageName, resourceFilter).stream();
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInModule(String moduleName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return findAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInModule(String moduleName, Predicate&lt;Class&lt;?&gt;&gt; classFilter, Predicate&lt;String&gt; classNameFilter) {
&nbsp;        return streamAllClassesInModule(moduleName, ClassFilter.of(classNameFilter, classFilter));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findAllClassesInModule(String moduleName, ClassFilter classFilter) {
&nbsp;        return Collections.unmodifiableList(ModuleUtils.findAllClassesInModule(moduleName, classFilter));
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static List&lt;Resource&gt; findAllResourcesInModule(String moduleName, Predicate&lt;Resource&gt; resourceFilter) {</b>
<b class="nc">&nbsp;        return Collections.unmodifiableList(ModuleUtils.findAllResourcesInModule(moduleName, resourceFilter));</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamAllClassesInModule(String moduleName, ClassFilter classFilter) {</b>
<b class="nc">&nbsp;        return findAllClassesInModule(moduleName, classFilter).stream();</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    public static Stream&lt;Resource&gt; streamAllResourcesInModule(String moduleName, Predicate&lt;Resource&gt; resourceFilter) {</b>
&nbsp;        return findAllResourcesInModule(moduleName, resourceFilter).stream();
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Class&lt;?&gt;&gt; findNestedClasses(Class&lt;?&gt; clazz, Predicate&lt;Class&lt;?&gt;&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Set&lt;Class&lt;?&gt;&gt; candidates = new LinkedHashSet();
&nbsp;        findNestedClasses(clazz, predicate, candidates);
&nbsp;        return Collections.unmodifiableList(new ArrayList(candidates));
&nbsp;    }
&nbsp;
&nbsp;    public static Stream&lt;Class&lt;?&gt;&gt; streamNestedClasses(Class&lt;?&gt; clazz, Predicate&lt;Class&lt;?&gt;&gt; predicate) {
&nbsp;        return findNestedClasses(clazz, predicate).stream();
&nbsp;    }
&nbsp;
&nbsp;    private static void findNestedClasses(Class&lt;?&gt; clazz, Predicate&lt;Class&lt;?&gt;&gt; predicate, Set&lt;Class&lt;?&gt;&gt; candidates) {
&nbsp;        if (isSearchable(clazz)) {
&nbsp;            if (isInnerClass(clazz) &amp;&amp; predicate.test(clazz)) {
<b class="fc">&nbsp;                detectInnerClassCycle(clazz);</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            try {</b>
&nbsp;                for(Class&lt;?&gt; nestedClass : clazz.getDeclaredClasses()) {
&nbsp;                    if (predicate.test(nestedClass)) {
<b class="nc">&nbsp;                        detectInnerClassCycle(nestedClass);</b>
&nbsp;                        candidates.add(nestedClass);
&nbsp;                    }
&nbsp;                }
&nbsp;            } catch (NoClassDefFoundError error) {
&nbsp;                logger.debug(error, () -&gt; &quot;Failed to retrieve declared classes for &quot; + clazz.getName());
&nbsp;            }
&nbsp;
&nbsp;            findNestedClasses(clazz.getSuperclass(), predicate, candidates);
&nbsp;
&nbsp;            for(Class&lt;?&gt; ifc : clazz.getInterfaces()) {
&nbsp;                findNestedClasses(ifc, predicate, candidates);
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static void detectInnerClassCycle(Class&lt;?&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        String className = clazz.getName();
&nbsp;        if (!noCyclesDetectedCache.contains(className)) {
&nbsp;            Class&lt;?&gt; superclass = clazz.getSuperclass();
<b class="nc">&nbsp;            if (isInnerClass(clazz) &amp;&amp; isSearchable(superclass)) {</b>
&nbsp;                for(Class&lt;?&gt; enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {
&nbsp;                    if (superclass.equals(enclosing)) {
&nbsp;                        throw new JUnitException(String.format(&quot;Detected cycle in inner class hierarchy between %s and %s&quot;, className, enclosing.getName()));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            noCyclesDetectedCache.add(className);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static &lt;T&gt; Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;T&gt; clazz) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            List&lt;Constructor&lt;?&gt;&gt; constructors = (List)Arrays.stream(clazz.getDeclaredConstructors()).filter((ctor) -&gt; !ctor.isSynthetic()).collect(Collectors.toList());
&nbsp;            Preconditions.condition(constructors.size() == 1, () -&gt; String.format(&quot;Class [%s] must declare a single constructor&quot;, clazz.getName()));
&nbsp;            return (Constructor)constructors.get(0);
<b class="nc">&nbsp;        } catch (Throwable t) {</b>
<b class="nc">&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));</b>
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static List&lt;Constructor&lt;?&gt;&gt; findConstructors(Class&lt;?&gt; clazz, Predicate&lt;Constructor&lt;?&gt;&gt; predicate) {</b>
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;
&nbsp;        try {
&nbsp;            return (List)Arrays.stream(clazz.getDeclaredConstructors()).filter(predicate).collect(CollectionUtils.toUnmodifiableList());
&nbsp;        } catch (Throwable t) {
&nbsp;            throw ExceptionUtils.throwAsUncheckedException(getUnderlyingCause(t));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Field&gt; findFields(Class&lt;?&gt; clazz, Predicate&lt;Field&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        return (List)streamFields(clazz, predicate, traversalMode).collect(CollectionUtils.toUnmodifiableList());
&nbsp;    }
&nbsp;
&nbsp;    public static Stream&lt;Field&gt; streamFields(Class&lt;?&gt; clazz, Predicate&lt;Field&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        return findAllFieldsInHierarchy(clazz, traversalMode).stream().filter(predicate).distinct();
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static List&lt;Field&gt; findAllFieldsInHierarchy(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        List&lt;Field&gt; localFields = (List)getDeclaredFields(clazz).stream().filter((field) -&gt; !field.isSynthetic()).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; superclassFields = (List)getSuperclassFields(clazz, traversalMode).stream().filter((field) -&gt; !isFieldShadowedByLocalFields(field, localFields)).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; interfaceFields = (List)getInterfaceFields(clazz, traversalMode).stream().filter((field) -&gt; !isFieldShadowedByLocalFields(field, localFields)).collect(Collectors.toList());
&nbsp;        List&lt;Field&gt; fields = new ArrayList();
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;            fields.addAll(superclassFields);
&nbsp;            fields.addAll(interfaceFields);
&nbsp;        }
&nbsp;
&nbsp;        fields.addAll(localFields);
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
<b class="nc">&nbsp;            fields.addAll(interfaceFields);</b>
&nbsp;            fields.addAll(superclassFields);
&nbsp;        }
&nbsp;
&nbsp;        return fields;
&nbsp;    }
&nbsp;
&nbsp;    public static boolean isMethodPresent(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        return findMethod(clazz, predicate).isPresent();
&nbsp;    }
&nbsp;
&nbsp;    /** @deprecated */
&nbsp;    @API(
&nbsp;        status = Status.DEPRECATED,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    @Deprecated
&nbsp;    static Optional&lt;Method&gt; getMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        return tryToGetMethod(clazz, methodName, parameterTypes).toOptional();
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.4&quot;
&nbsp;    )
&nbsp;    public static Try&lt;Method&gt; tryToGetMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return Try.call(() -&gt; clazz.getMethod(methodName, parameterTypes));
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @API(</b>
<b class="nc">&nbsp;        status = Status.INTERNAL,</b>
&nbsp;        since = &quot;1.11&quot;
<b class="nc">&nbsp;    )</b>
&nbsp;    public static Method getInterfaceMethodIfPossible(Method method, Class&lt;?&gt; targetClass) {
&nbsp;        if (isPublic(method) &amp;&amp; !method.getDeclaringClass().isInterface()) {
&nbsp;            Method result = (Method)interfaceMethodCache.computeIfAbsent(method, (m) -&gt; findInterfaceMethodIfPossible(m, m.getParameterTypes(), m.getDeclaringClass(), Object.class));
&nbsp;            if (result == method &amp;&amp; targetClass != null) {
&nbsp;                result = findInterfaceMethodIfPossible(method, method.getParameterTypes(), targetClass, method.getDeclaringClass());
&nbsp;            }
&nbsp;
&nbsp;            return result;
&nbsp;        } else {
&nbsp;            return method;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static Method findInterfaceMethodIfPossible(Method method, Class&lt;?&gt;[] parameterTypes, Class&lt;?&gt; startClass, Class&lt;?&gt; endClass) {
<b class="nc">&nbsp;        for(Class&lt;?&gt; current = startClass; current != null &amp;&amp; current != endClass; current = current.getSuperclass()) {</b>
&nbsp;            for(Class&lt;?&gt; ifc : current.getInterfaces()) {
&nbsp;                try {
&nbsp;                    return ifc.getMethod(method.getName(), parameterTypes);
&nbsp;                } catch (NoSuchMethodException var10) {
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return method;
&nbsp;    }
&nbsp;
&nbsp;    public static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, String methodName, String parameterTypeNames) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
&nbsp;        return findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    @API(</b>
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.10&quot;
<b class="nc">&nbsp;    )</b>
<b class="nc">&nbsp;    public static Class&lt;?&gt;[] resolveParameterTypes(Class&lt;?&gt; clazz, String methodName, String parameterTypeNames) {</b>
<b class="nc">&nbsp;        return StringUtils.isBlank(parameterTypeNames) ? EMPTY_CLASS_ARRAY : (Class[])Arrays.stream(parameterTypeNames.split(&quot;,&quot;)).map(String::trim).map((typeName) -&gt; loadRequiredParameterType(clazz, methodName, typeName)).toArray((x$0) -&gt; new Class[x$0]);</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static Class&lt;?&gt; loadRequiredParameterType(Class&lt;?&gt; clazz, String methodName, String typeName) {</b>
&nbsp;        ClassLoader classLoader = ClassLoaderUtils.getClassLoader(clazz);
&nbsp;        return (Class)tryToLoadClass(typeName, classLoader).getOrThrow((cause) -&gt; new JUnitException(String.format(&quot;Failed to load parameter type [%s] for method [%s] in class [%s].&quot;, typeName, methodName, clazz.getName()), cause));
&nbsp;    }
&nbsp;
&nbsp;    public static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notBlank(methodName, &quot;Method name must not be null or blank&quot;);
<b class="fc">&nbsp;        Preconditions.notNull(parameterTypes, &quot;Parameter types array must not be null&quot;);</b>
<b class="pc">&nbsp;        Preconditions.containsNoNullElements(parameterTypes, &quot;Individual parameter types must not be null&quot;);</b>
<b class="nc">&nbsp;        return findMethod(clazz, (method) -&gt; hasCompatibleSignature(method, methodName, parameterTypes));</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static Optional&lt;Method&gt; findMethod(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {</b>
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
<b class="nc">&nbsp;</b>
&nbsp;        for(Class&lt;?&gt; current = clazz; isSearchable(current); current = current.getSuperclass()) {
&nbsp;            for(Method method : current.isInterface() ? getMethods(current) : getDeclaredMethods(current, ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP)) {
&nbsp;                if (predicate.test(method)) {
&nbsp;                    return Optional.of(method);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            for(Class&lt;?&gt; ifc : current.getInterfaces()) {
&nbsp;                Optional&lt;Method&gt; optional = findMethod(ifc, predicate);
&nbsp;                if (optional.isPresent()) {
<b class="nc">&nbsp;                    return optional;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return Optional.empty();
&nbsp;    }
&nbsp;
&nbsp;    @API(
<b class="fc">&nbsp;        status = Status.STABLE,</b>
&nbsp;        since = &quot;1.7&quot;
&nbsp;    )
&nbsp;    public static Method getRequiredMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
&nbsp;        return (Method)findMethod(clazz, methodName, parameterTypes).orElseThrow(() -&gt; new JUnitException(String.format(&quot;Could not find method [%s] in class [%s]&quot;, methodName, clazz.getName())));
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Method&gt; findMethods(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate) {
&nbsp;        return findMethods(clazz, predicate, ReflectionUtils.HierarchyTraversalMode.TOP_DOWN);
&nbsp;    }
&nbsp;
&nbsp;    public static List&lt;Method&gt; findMethods(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        return (List)streamMethods(clazz, predicate, traversalMode).collect(CollectionUtils.toUnmodifiableList());
&nbsp;    }
&nbsp;
&nbsp;    public static Stream&lt;Method&gt; streamMethods(Class&lt;?&gt; clazz, Predicate&lt;Method&gt; predicate, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(predicate, &quot;Predicate must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
<b class="nc">&nbsp;        return findAllMethodsInHierarchy(clazz, traversalMode).stream().filter(predicate).distinct();</b>
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; findAllMethodsInHierarchy(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);
&nbsp;        Preconditions.notNull(traversalMode, &quot;HierarchyTraversalMode must not be null&quot;);
&nbsp;        List&lt;Method&gt; localMethods = (List)getDeclaredMethods(clazz, traversalMode).stream().filter((method) -&gt; !method.isSynthetic()).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; superclassMethods = (List)getSuperclassMethods(clazz, traversalMode).stream().filter((method) -&gt; !isMethodOverriddenByLocalMethods(method, localMethods)).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; interfaceMethods = (List)getInterfaceMethods(clazz, traversalMode).stream().filter((method) -&gt; !isMethodOverriddenByLocalMethods(method, localMethods)).collect(Collectors.toList());
&nbsp;        List&lt;Method&gt; methods = new ArrayList();
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
&nbsp;            methods.addAll(superclassMethods);
&nbsp;            methods.addAll(interfaceMethods);
&nbsp;        }
&nbsp;
&nbsp;        methods.addAll(localMethods);
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;            methods.addAll(interfaceMethods);
<b class="nc">&nbsp;            methods.addAll(superclassMethods);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return methods;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getFields(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getFields());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getDeclaredFields(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getDeclaredFields());
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getMethods(Class&lt;?&gt; clazz) {
&nbsp;        return toSortedMutableList(clazz.getMethods());
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static List&lt;Method&gt; getDeclaredMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {</b>
<b class="fc">&nbsp;        List&lt;Method&gt; defaultMethods = getDefaultMethods(clazz);</b>
<b class="fc">&nbsp;        List&lt;Method&gt; declaredMethods = toSortedMutableList(clazz.getDeclaredMethods());</b>
&nbsp;        if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
<b class="pc">&nbsp;            declaredMethods.addAll(defaultMethods);</b>
<b class="nc">&nbsp;            return declaredMethods;</b>
&nbsp;        } else {
&nbsp;            defaultMethods.addAll(declaredMethods);
<b class="fc">&nbsp;            return defaultMethods;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static List&lt;Method&gt; getDefaultMethods(Class&lt;?&gt; clazz) {</b>
<b class="pc">&nbsp;        List&lt;Method&gt; visibleDefaultMethods = (List)Arrays.stream(clazz.getMethods()).filter(Method::isDefault).collect(Collectors.toCollection(ArrayList::new));</b>
<b class="nc">&nbsp;        if (visibleDefaultMethods.isEmpty()) {</b>
<b class="nc">&nbsp;            return visibleDefaultMethods;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            Stream var10000 = Arrays.stream(clazz.getInterfaces()).map(ReflectionUtils::getMethods).flatMap(Collection::stream);</b>
&nbsp;            Objects.requireNonNull(visibleDefaultMethods);
<b class="nc">&nbsp;            return (List)var10000.filter(visibleDefaultMethods::contains).collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    private static List&lt;Field&gt; toSortedMutableList(Field[] fields) {</b>
<b class="pc">&nbsp;        return (List)Arrays.stream(fields).sorted(ReflectionUtils::defaultFieldSorter).collect(Collectors.toCollection(ArrayList::new));</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private static List&lt;Method&gt; toSortedMutableList(Method[] methods) {
<b class="nc">&nbsp;        return (List)Arrays.stream(methods).sorted(ReflectionUtils::defaultMethodSorter).collect(Collectors.toCollection(ArrayList::new));</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private static int defaultFieldSorter(Field field1, Field field2) {
&nbsp;        return Integer.compare(field1.getName().hashCode(), field2.getName().hashCode());
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;    private static int defaultMethodSorter(Method method1, Method method2) {</b>
<b class="nc">&nbsp;        String name1 = method1.getName();</b>
<b class="nc">&nbsp;        String name2 = method2.getName();</b>
&nbsp;        int comparison = Integer.compare(name1.hashCode(), name2.hashCode());
<b class="nc">&nbsp;        if (comparison == 0) {</b>
&nbsp;            comparison = name1.compareTo(name2);
<b class="nc">&nbsp;            if (comparison == 0) {</b>
&nbsp;                comparison = method1.toString().compareTo(method2.toString());
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        return comparison;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Method&gt; getInterfaceMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        List&lt;Method&gt; allInterfaceMethods = new ArrayList();
&nbsp;
<b class="nc">&nbsp;        for(Class&lt;?&gt; ifc : clazz.getInterfaces()) {</b>
<b class="nc">&nbsp;            List&lt;Method&gt; localInterfaceMethods = (List)getMethods(ifc).stream().filter((m) -&gt; !isAbstract(m)).collect(Collectors.toList());</b>
<b class="nc">&nbsp;            List&lt;Method&gt; superinterfaceMethods = (List)getInterfaceMethods(ifc, traversalMode).stream().filter((method) -&gt; !isMethodOverriddenByLocalMethods(method, localInterfaceMethods)).collect(Collectors.toList());</b>
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
<b class="nc">&nbsp;                allInterfaceMethods.addAll(superinterfaceMethods);</b>
&nbsp;            }
&nbsp;
&nbsp;            allInterfaceMethods.addAll(localInterfaceMethods);
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;                allInterfaceMethods.addAll(superinterfaceMethods);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return allInterfaceMethods;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getInterfaceFields(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        List&lt;Field&gt; allInterfaceFields = new ArrayList();
&nbsp;
&nbsp;        for(Class&lt;?&gt; ifc : clazz.getInterfaces()) {
&nbsp;            List&lt;Field&gt; localInterfaceFields = getFields(ifc);
<b class="nc">&nbsp;            List&lt;Field&gt; superinterfaceFields = (List)getInterfaceFields(ifc, traversalMode).stream().filter((field) -&gt; !isFieldShadowedByLocalFields(field, localInterfaceFields)).collect(Collectors.toList());</b>
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.TOP_DOWN) {
<b class="nc">&nbsp;                allInterfaceFields.addAll(superinterfaceFields);</b>
&nbsp;            }
&nbsp;
&nbsp;            allInterfaceFields.addAll(localInterfaceFields);
&nbsp;            if (traversalMode == ReflectionUtils.HierarchyTraversalMode.BOTTOM_UP) {
&nbsp;                allInterfaceFields.addAll(superinterfaceFields);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return allInterfaceFields;
&nbsp;    }
&nbsp;
&nbsp;    private static List&lt;Field&gt; getSuperclassFields(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;        return !isSearchable(superclass) ? Collections.emptyList() : findAllFieldsInHierarchy(superclass, traversalMode);
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static boolean isFieldShadowedByLocalFields(Field field, List&lt;Field&gt; localFields) {</b>
&nbsp;        return useLegacySearchSemantics ? localFields.stream().anyMatch((local) -&gt; local.getName().equals(field.getName())) : false;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static List&lt;Method&gt; getSuperclassMethods(Class&lt;?&gt; clazz, HierarchyTraversalMode traversalMode) {
&nbsp;        Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp;        return !isSearchable(superclass) ? Collections.emptyList() : findAllMethodsInHierarchy(superclass, traversalMode);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isMethodOverriddenByLocalMethods(Method method, List&lt;Method&gt; localMethods) {
&nbsp;        return localMethods.stream().anyMatch((local) -&gt; isMethodOverriddenBy(method, local));
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isMethodOverriddenBy(Method upper, Method lower) {
&nbsp;        if (!useLegacySearchSemantics) {
&nbsp;            if (Modifier.isStatic(lower.getModifiers())) {
&nbsp;                return false;
&nbsp;            }
&nbsp;
&nbsp;            int modifiers = upper.getModifiers();
<b class="nc">&nbsp;            if (Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers)) {</b>
<b class="nc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            if (isPackagePrivate(upper) &amp;&amp; !declaredInSamePackage(upper, lower)) {</b>
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        return hasCompatibleSignature(upper, lower.getName(), lower.getParameterTypes());
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isPackagePrivate(Member member) {
&nbsp;        int modifiers = member.getModifiers();
&nbsp;        return !Modifier.isPublic(modifiers) &amp;&amp; !Modifier.isProtected(modifiers) &amp;&amp; !Modifier.isPrivate(modifiers);
&nbsp;    }
&nbsp;
&nbsp;    private static boolean declaredInSamePackage(Method m1, Method m2) {
&nbsp;        return PackageNameUtils.getPackageName(m1.getDeclaringClass()).equals(PackageNameUtils.getPackageName(m2.getDeclaringClass()));
&nbsp;    }
&nbsp;
&nbsp;    private static boolean hasCompatibleSignature(Method candidate, String methodName, Class&lt;?&gt;[] parameterTypes) {
&nbsp;        if (!methodName.equals(candidate.getName())) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        } else if (parameterTypes.length != candidate.getParameterCount()) {
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Class&lt;?&gt;[] candidateParameterTypes = candidate.getParameterTypes();</b>
&nbsp;            if (Arrays.equals(parameterTypes, candidateParameterTypes)) {
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                for(int i = 0; i &lt; parameterTypes.length; ++i) {
&nbsp;                    Class&lt;?&gt; lowerType = parameterTypes[i];
&nbsp;                    Class&lt;?&gt; upperType = candidateParameterTypes[i];
<b class="nc">&nbsp;                    if (!upperType.isAssignableFrom(lowerType)) {</b>
<b class="nc">&nbsp;                        return false;</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
<b class="nc">&nbsp;                if (isGeneric(candidate)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    static boolean isGeneric(Method method) {
<b class="nc">&nbsp;        return isGeneric(method.getGenericReturnType()) || Arrays.stream(method.getGenericParameterTypes()).anyMatch(ReflectionUtils::isGeneric);</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isGeneric(Type type) {
&nbsp;        return type instanceof TypeVariable || type instanceof GenericArrayType;
&nbsp;    }
&nbsp;
&nbsp;    @API(
&nbsp;        status = Status.INTERNAL,
&nbsp;        since = &quot;1.11&quot;
&nbsp;    )
&nbsp;    public static &lt;T extends Executable&gt; T makeAccessible(T executable) {
&nbsp;        if ((!isPublic(executable) || !isPublic(executable.getDeclaringClass())) &amp;&amp; !executable.isAccessible()) {
&nbsp;            executable.setAccessible(true);
&nbsp;        }
&nbsp;
&nbsp;        return executable;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @API(</b>
&nbsp;        status = Status.INTERNAL,
<b class="nc">&nbsp;        since = &quot;1.11&quot;</b>
<b class="nc">&nbsp;    )</b>
<b class="nc">&nbsp;    public static Field makeAccessible(Field field) {</b>
<b class="nc">&nbsp;        if ((!isPublic(field) || !isPublic(field.getDeclaringClass()) || isFinal(field)) &amp;&amp; !field.isAccessible()) {</b>
&nbsp;            field.setAccessible(true);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        return field;
&nbsp;    }
&nbsp;
&nbsp;    public static Set&lt;Class&lt;?&gt;&gt; getAllAssignmentCompatibleClasses(Class&lt;?&gt; clazz) {
<b class="nc">&nbsp;        Preconditions.notNull(clazz, &quot;Class must not be null&quot;);</b>
&nbsp;        Set&lt;Class&lt;?&gt;&gt; result = new LinkedHashSet();
<b class="nc">&nbsp;        getAllAssignmentCompatibleClasses(clazz, result);</b>
<b class="nc">&nbsp;        return result;</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
&nbsp;    private static void getAllAssignmentCompatibleClasses(Class&lt;?&gt; clazz, Set&lt;Class&lt;?&gt;&gt; result) {
&nbsp;        for(Class&lt;?&gt; current = clazz; current != null; current = current.getSuperclass()) {
&nbsp;            result.add(current);
&nbsp;
&nbsp;            for(Class&lt;?&gt; interfaceClass : current.getInterfaces()) {
&nbsp;                if (!result.contains(interfaceClass)) {
&nbsp;                    getAllAssignmentCompatibleClasses(interfaceClass, result);
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    private static boolean isSearchable(Class&lt;?&gt; clazz) {
&nbsp;        return clazz != null &amp;&amp; clazz != Object.class;
&nbsp;    }
&nbsp;
&nbsp;    private static Throwable getUnderlyingCause(Throwable t) {
<b class="nc">&nbsp;        return t instanceof InvocationTargetException ? getUnderlyingCause(((InvocationTargetException)t).getTargetException()) : t;</b>
&nbsp;    }
&nbsp;
&nbsp;    private static boolean getLegacySearchSemanticsFlag() {
&nbsp;        String rawValue = System.getProperty(&quot;junit.platform.reflection.search.useLegacySemantics&quot;);
&nbsp;        if (StringUtils.isBlank(rawValue)) {
&nbsp;            return false;
<b class="nc">&nbsp;        } else {</b>
&nbsp;            String value = rawValue.trim().toLowerCase();
&nbsp;            boolean isTrue = &quot;true&quot;.equals(value);
&nbsp;            Preconditions.condition(isTrue || &quot;false&quot;.equals(value), () -&gt; &quot;junit.platform.reflection.search.useLegacySemantics property must be &#39;true&#39; or &#39;false&#39; (ignoring case): &quot; + rawValue);
&nbsp;            return isTrue;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    static {
&nbsp;        List&lt;Class&lt;?&gt;&gt; commonTypes = Arrays.asList(Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE, boolean[].class, byte[].class, char[].class, short[].class, int[].class, long[].class, float[].class, double[].class, boolean[][].class, byte[][].class, char[][].class, short[][].class, int[][].class, long[][].class, float[][].class, double[][].class, Boolean.class, Byte.class, Character.class, Short.class, Integer.class, Long.class, Float.class, Double.class, String.class, Boolean[].class, Byte[].class, Character[].class, Short[].class, Integer[].class, Long[].class, Float[].class, Double[].class, String[].class, Boolean[][].class, Byte[][].class, Character[][].class, Short[][].class, Integer[][].class, Long[][].class, Float[][].class, Double[][].class, String[][].class);
&nbsp;        Map&lt;String, Class&lt;?&gt;&gt; classNamesToTypes = new HashMap(64);
&nbsp;        commonTypes.forEach((type) -&gt; {
&nbsp;            classNamesToTypes.put(type.getName(), type);
&nbsp;            classNamesToTypes.put(type.getCanonicalName(), type);
<b class="nc">&nbsp;        });</b>
&nbsp;        classNameToTypeMap = Collections.unmodifiableMap(classNamesToTypes);
&nbsp;        Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; primitivesToWrappers = new IdentityHashMap(8);
&nbsp;        primitivesToWrappers.put(Boolean.TYPE, Boolean.class);
&nbsp;        primitivesToWrappers.put(Byte.TYPE, Byte.class);
&nbsp;        primitivesToWrappers.put(Character.TYPE, Character.class);
&nbsp;        primitivesToWrappers.put(Short.TYPE, Short.class);
<b class="nc">&nbsp;        primitivesToWrappers.put(Integer.TYPE, Integer.class);</b>
&nbsp;        primitivesToWrappers.put(Long.TYPE, Long.class);
&nbsp;        primitivesToWrappers.put(Float.TYPE, Float.class);
&nbsp;        primitivesToWrappers.put(Double.TYPE, Double.class);
&nbsp;        primitiveToWrapperMap = Collections.unmodifiableMap(primitivesToWrappers);
&nbsp;        useLegacySearchSemantics = getLegacySearchSemanticsFlag();
&nbsp;    }
&nbsp;
&nbsp;    public static enum HierarchyTraversalMode {
<b class="nc">&nbsp;        TOP_DOWN,</b>
&nbsp;        BOTTOM_UP;
&nbsp;
&nbsp;        private HierarchyTraversalMode() {
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
