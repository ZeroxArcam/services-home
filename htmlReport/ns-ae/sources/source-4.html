


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > GenericMetadataSupport</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.mockito.internal.util.reflection</a>
</div>

<h1>Coverage Summary for Class: GenericMetadataSupport (org.mockito.internal.util.reflection)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GenericMetadataSupport</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37%
  </span>
  <span class="absValue">
    (20/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.3%
  </span>
  <span class="absValue">
    (43/91)
  </span>
</td>
</tr>
  <tr>
    <td class="name">GenericMetadataSupport$BoundedType</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$FromClassGenericMetadataSupport</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$FromParameterizedTypeGenericMetadataSupport</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$GenericArrayReturnType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$NotGenericReturnTypeSupport</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$ParameterizedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">GenericMetadataSupport$TypeVariableReturnType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/40)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (15/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25.6%
  </span>
  <span class="absValue">
    (20/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.1%
  </span>
  <span class="absValue">
    (61/169)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.mockito.internal.util.reflection;
&nbsp;
&nbsp;import java.lang.reflect.GenericArrayType;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.ParameterizedType;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.lang.reflect.TypeVariable;
&nbsp;import java.lang.reflect.WildcardType;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Queue;
&nbsp;import java.util.Set;
&nbsp;import org.mockito.exceptions.base.MockitoException;
&nbsp;import org.mockito.internal.util.Checks;
&nbsp;
&nbsp;public abstract class GenericMetadataSupport {
&nbsp;    protected Map&lt;TypeVariable&lt;?&gt;, Type&gt; contextualActualTypeParameters = new HashMap();
&nbsp;
&nbsp;    public GenericMetadataSupport() {
&nbsp;    }
&nbsp;
&nbsp;    protected void registerAllTypeVariables(Type classType) {
&nbsp;        Queue&lt;Type&gt; typesToRegister = new LinkedList();
&nbsp;        Set&lt;Type&gt; registeredTypes = new HashSet();
&nbsp;        typesToRegister.add(classType);
&nbsp;
&nbsp;        while(!typesToRegister.isEmpty()) {
&nbsp;            Type typeToRegister = (Type)typesToRegister.poll();
&nbsp;            if (typeToRegister != null &amp;&amp; !registeredTypes.contains(typeToRegister)) {
&nbsp;                this.registerTypeVariablesOn(typeToRegister);
&nbsp;                registeredTypes.add(typeToRegister);
&nbsp;                Class&lt;?&gt; rawType = this.extractRawTypeOf(typeToRegister);
&nbsp;                typesToRegister.add(rawType.getGenericSuperclass());
&nbsp;                typesToRegister.addAll(Arrays.asList(rawType.getGenericInterfaces()));
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    protected Class&lt;?&gt; extractRawTypeOf(Type type) {
&nbsp;        if (type instanceof Class) {
&nbsp;            return (Class)type;
&nbsp;        } else if (type instanceof ParameterizedType) {
&nbsp;            return (Class)((ParameterizedType)type).getRawType();
&nbsp;        } else if (type instanceof BoundedType) {
&nbsp;            return this.extractRawTypeOf(((BoundedType)type).firstBound());
&nbsp;        } else if (type instanceof TypeVariable) {
&nbsp;            return this.extractRawTypeOf((Type)this.contextualActualTypeParameters.get(type));
&nbsp;        } else {
&nbsp;            throw new MockitoException(&quot;Raw extraction not supported for : &#39;&quot; + String.valueOf(type) + &quot;&#39;&quot;);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected void registerTypeVariablesOn(Type classType) {
&nbsp;        if (classType instanceof ParameterizedType) {
<b class="fc">&nbsp;            ParameterizedType parameterizedType = (ParameterizedType)classType;</b>
&nbsp;            TypeVariable&lt;?&gt;[] typeParameters = ((Class)parameterizedType.getRawType()).getTypeParameters();
&nbsp;            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
&nbsp;
&nbsp;            for(int i = 0; i &lt; actualTypeArguments.length; ++i) {
<b class="fc">&nbsp;                TypeVariable&lt;?&gt; typeParameter = typeParameters[i];</b>
&nbsp;                Type actualTypeArgument = actualTypeArguments[i];
&nbsp;                if (actualTypeArgument instanceof TypeVariable) {
&nbsp;                    this.registerTypeVariableIfNotPresent((TypeVariable)actualTypeArgument);
&nbsp;                    if (this.contextualActualTypeParameters.containsKey(typeParameter)) {
&nbsp;                        continue;
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;</b>
&nbsp;                if (actualTypeArgument instanceof WildcardType) {
<b class="fc">&nbsp;                    this.contextualActualTypeParameters.put(typeParameter, this.boundsOf((WildcardType)actualTypeArgument));</b>
<b class="fc">&nbsp;                } else if (typeParameter != actualTypeArgument) {</b>
<b class="pc">&nbsp;                    this.contextualActualTypeParameters.put(typeParameter, actualTypeArgument);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
<b class="fc">&nbsp;    protected void registerTypeParametersOn(TypeVariable&lt;?&gt;[] typeParameters) {</b>
<b class="fc">&nbsp;        for(TypeVariable&lt;?&gt; type : typeParameters) {</b>
<b class="fc">&nbsp;            this.registerTypeVariableIfNotPresent(type);</b>
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    private void registerTypeVariableIfNotPresent(TypeVariable&lt;?&gt; typeVariable) {</b>
<b class="fc">&nbsp;        if (!this.contextualActualTypeParameters.containsKey(typeVariable)) {</b>
&nbsp;            this.contextualActualTypeParameters.put(typeVariable, this.boundsOf(typeVariable));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private BoundedType boundsOf(TypeVariable&lt;?&gt; typeParameter) {</b>
&nbsp;        return (BoundedType)(typeParameter.getBounds()[0] instanceof TypeVariable ? this.boundsOf((TypeVariable)typeParameter.getBounds()[0]) : new TypeVarBoundedType(typeParameter));
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private BoundedType boundsOf(WildcardType wildCard) {
&nbsp;        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);
&nbsp;        return (BoundedType)(wildCardBoundedType.firstBound() instanceof TypeVariable ? this.boundsOf((TypeVariable)wildCardBoundedType.firstBound()) : wildCardBoundedType);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public abstract Class&lt;?&gt; rawType();
<b class="nc">&nbsp;</b>
&nbsp;    public List&lt;Type&gt; extraInterfaces() {
&nbsp;        return Collections.emptyList();
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public Class&lt;?&gt;[] rawExtraInterfaces() {
&nbsp;        return new Class[0];
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public boolean hasRawExtraInterfaces() {</b>
<b class="fc">&nbsp;        return this.rawExtraInterfaces().length &gt; 0;</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public Map&lt;TypeVariable&lt;?&gt;, Type&gt; actualTypeArguments() {</b>
&nbsp;        TypeVariable&lt;?&gt;[] typeParameters = this.rawType().getTypeParameters();
<b class="pc">&nbsp;        LinkedHashMap&lt;TypeVariable&lt;?&gt;, Type&gt; actualTypeArguments = new LinkedHashMap();</b>
&nbsp;
&nbsp;        for(TypeVariable&lt;?&gt; typeParameter : typeParameters) {
&nbsp;            Type actualType = this.getActualTypeArgumentFor(typeParameter);
&nbsp;            actualTypeArguments.put(typeParameter, actualType);
&nbsp;        }
&nbsp;
&nbsp;        return actualTypeArguments;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected Type getActualTypeArgumentFor(TypeVariable&lt;?&gt; typeParameter) {
&nbsp;        Type type = (Type)this.contextualActualTypeParameters.get(typeParameter);
&nbsp;        if (type instanceof TypeVariable) {
&nbsp;            TypeVariable&lt;?&gt; typeVariable = (TypeVariable)type;
<b class="nc">&nbsp;            return this.getActualTypeArgumentFor(typeVariable);</b>
&nbsp;        } else {
&nbsp;            return type;
&nbsp;        }
&nbsp;    }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;    public GenericMetadataSupport resolveGenericReturnType(Method method) {</b>
<b class="nc">&nbsp;        Type genericReturnType = method.getGenericReturnType();</b>
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;        int arity;</b>
&nbsp;        for(arity = 0; genericReturnType instanceof GenericArrayType; genericReturnType = ((GenericArrayType)genericReturnType).getGenericComponentType()) {
&nbsp;            ++arity;
&nbsp;        }
&nbsp;
&nbsp;        GenericMetadataSupport genericMetadataSupport = this.resolveGenericType(genericReturnType, method);
&nbsp;        return (GenericMetadataSupport)(arity == 0 ? genericMetadataSupport : new GenericArrayReturnType(genericMetadataSupport, arity));
&nbsp;    }
&nbsp;
<b class="pc">&nbsp;    private GenericMetadataSupport resolveGenericType(Type type, Method method) {</b>
<b class="nc">&nbsp;        if (type instanceof Class) {</b>
&nbsp;            return new NotGenericReturnTypeSupport(this, type);
&nbsp;        } else if (type instanceof ParameterizedType) {
&nbsp;            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType)type);
&nbsp;        } else if (type instanceof TypeVariable) {
<b class="nc">&nbsp;            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable)type);</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            String var10002 = type.getClass().getCanonicalName();
&nbsp;            throw new MockitoException(&quot;Ouch, it shouldn&#39;t happen, type &#39;&quot; + var10002 + &quot;&#39; on method : &#39;&quot; + method.toGenericString() + &quot;&#39; is not supported : &quot; + String.valueOf(type));
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static GenericMetadataSupport inferFrom(Type type) {
&nbsp;        Checks.checkNotNull(type, &quot;type&quot;);
&nbsp;        if (type instanceof Class) {
&nbsp;            return new FromClassGenericMetadataSupport((Class)type);
&nbsp;        } else if (type instanceof ParameterizedType) {
&nbsp;            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType)type);
&nbsp;        } else {
<b class="nc">&nbsp;            String var10002 = type.getClass().getCanonicalName();</b>
<b class="nc">&nbsp;            throw new MockitoException(&quot;Type meta-data for this Type (&quot; + var10002 + &quot;) is not supported : &quot; + String.valueOf(type));</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {
&nbsp;        private final Class&lt;?&gt; clazz;
&nbsp;
&nbsp;        public FromClassGenericMetadataSupport(Class&lt;?&gt; clazz) {
&nbsp;            this.clazz = clazz;
&nbsp;            this.registerTypeParametersOn(clazz.getTypeParameters());
&nbsp;            this.registerAllTypeVariables(clazz);
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt; rawType() {
&nbsp;            return this.clazz;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {
&nbsp;        private final ParameterizedType parameterizedType;
&nbsp;
<b class="nc">&nbsp;        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {</b>
<b class="nc">&nbsp;            this.parameterizedType = parameterizedType;</b>
<b class="nc">&nbsp;            this.readActualTypeParameters();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private void readActualTypeParameters() {</b>
&nbsp;            this.registerAllTypeVariables(this.parameterizedType);
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt; rawType() {
&nbsp;            return (Class)this.parameterizedType.getRawType();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class ParameterizedReturnType extends GenericMetadataSupport {
&nbsp;        private final ParameterizedType parameterizedType;
&nbsp;        private final TypeVariable&lt;?&gt;[] typeParameters;
<b class="nc">&nbsp;</b>
&nbsp;        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable&lt;?&gt;[] typeParameters, ParameterizedType parameterizedType) {
&nbsp;            this.parameterizedType = parameterizedType;
&nbsp;            this.typeParameters = typeParameters;
&nbsp;            this.contextualActualTypeParameters = source.contextualActualTypeParameters;
&nbsp;            this.readTypeParameters();
&nbsp;            this.readTypeVariables();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        private void readTypeParameters() {
&nbsp;            this.registerTypeParametersOn(this.typeParameters);
&nbsp;        }
&nbsp;
&nbsp;        private void readTypeVariables() {
<b class="nc">&nbsp;            this.registerTypeVariablesOn(this.parameterizedType);</b>
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt; rawType() {
&nbsp;            return (Class)this.parameterizedType.getRawType();
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private static class TypeVariableReturnType extends GenericMetadataSupport {</b>
&nbsp;        private final TypeVariable&lt;?&gt; typeVariable;
<b class="nc">&nbsp;        private final TypeVariable&lt;?&gt;[] typeParameters;</b>
&nbsp;        private Class&lt;?&gt; rawType;
<b class="nc">&nbsp;        private List&lt;Type&gt; extraInterfaces;</b>
&nbsp;
<b class="nc">&nbsp;        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable&lt;?&gt;[] typeParameters, TypeVariable&lt;?&gt; typeVariable) {</b>
&nbsp;            this.typeParameters = typeParameters;
&nbsp;            this.typeVariable = typeVariable;
&nbsp;            this.contextualActualTypeParameters = source.contextualActualTypeParameters;
&nbsp;            this.readTypeParameters();
&nbsp;            this.readTypeVariables();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        private void readTypeParameters() {
&nbsp;            this.registerTypeParametersOn(this.typeParameters);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private void readTypeVariables() {</b>
<b class="nc">&nbsp;            for(Type type : this.typeVariable.getBounds()) {</b>
&nbsp;                this.registerTypeVariablesOn(type);
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            this.registerTypeParametersOn(new TypeVariable[]{this.typeVariable});
&nbsp;            this.registerTypeVariablesOn(this.getActualTypeArgumentFor(this.typeVariable));
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt; rawType() {
&nbsp;            if (this.rawType == null) {
&nbsp;                this.rawType = this.extractRawTypeOf(this.typeVariable);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return this.rawType;</b>
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;Type&gt; extraInterfaces() {
&nbsp;            if (this.extraInterfaces != null) {
<b class="fc">&nbsp;                return this.extraInterfaces;</b>
<b class="pc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                Type type = this.extractActualBoundedTypeOf(this.typeVariable);</b>
<b class="nc">&nbsp;                if (type instanceof BoundedType) {</b>
&nbsp;                    return this.extraInterfaces = Arrays.asList(((BoundedType)type).interfaceBounds());
&nbsp;                } else if (type instanceof ParameterizedType) {
<b class="fc">&nbsp;                    return this.extraInterfaces = Collections.singletonList(type);</b>
<b class="fc">&nbsp;                } else if (type instanceof Class) {</b>
<b class="pc">&nbsp;                    return this.extraInterfaces = Collections.emptyList();</b>
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    String var10002 = String.valueOf(this.typeVariable);
<b class="nc">&nbsp;                    throw new MockitoException(&quot;Cannot extract extra-interfaces from &#39;&quot; + var10002 + &quot;&#39; : &#39;&quot; + String.valueOf(type) + &quot;&#39;&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt;[] rawExtraInterfaces() {
<b class="fc">&nbsp;            List&lt;Type&gt; extraInterfaces = this.extraInterfaces();</b>
<b class="fc">&nbsp;            List&lt;Class&lt;?&gt;&gt; rawExtraInterfaces = new ArrayList();</b>
&nbsp;
<b class="pc">&nbsp;            for(Type extraInterface : extraInterfaces) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt; rawInterface = this.extractRawTypeOf(extraInterface);</b>
<b class="fc">&nbsp;                if (!this.rawType().equals(rawInterface)) {</b>
&nbsp;                    rawExtraInterfaces.add(rawInterface);
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
&nbsp;            return (Class[])rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        private Type extractActualBoundedTypeOf(Type type) {
<b class="nc">&nbsp;            if (type instanceof TypeVariable) {</b>
&nbsp;                return this.extractActualBoundedTypeOf((Type)this.contextualActualTypeParameters.get(type));
<b class="nc">&nbsp;            } else if (type instanceof BoundedType) {</b>
&nbsp;                Type actualFirstBound = this.extractActualBoundedTypeOf(((BoundedType)type).firstBound());
&nbsp;                return !(actualFirstBound instanceof BoundedType) ? type : actualFirstBound;
&nbsp;            } else {
&nbsp;                return type;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class GenericArrayReturnType extends GenericMetadataSupport {
&nbsp;        private final GenericMetadataSupport genericArrayType;
&nbsp;        private final int arity;
&nbsp;
&nbsp;        public GenericArrayReturnType(GenericMetadataSupport genericArrayType, int arity) {
&nbsp;            this.genericArrayType = genericArrayType;
&nbsp;            this.arity = arity;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Class&lt;?&gt; rawType() {</b>
<b class="pc">&nbsp;            Class&lt;?&gt; rawComponentType = this.genericArrayType.rawType();</b>
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
&nbsp;
<b class="nc">&nbsp;            for(int i = 0; i &lt; this.arity; ++i) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot;[&quot;);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            try {</b>
&nbsp;                return Class.forName(stringBuilder.append(&quot;L&quot;).append(rawComponentType.getName()).append(&quot;;&quot;).toString(), false, rawComponentType.getClassLoader());
<b class="nc">&nbsp;            } catch (ClassNotFoundException e) {</b>
&nbsp;                throw new IllegalStateException(&quot;This was not supposed to happen.&quot;, e);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {
&nbsp;        private final Class&lt;?&gt; returnType;
&nbsp;
&nbsp;        public NotGenericReturnTypeSupport(GenericMetadataSupport source, Type genericReturnType) {
&nbsp;            this.returnType = (Class)genericReturnType;
&nbsp;            this.contextualActualTypeParameters = source.contextualActualTypeParameters;
&nbsp;            this.registerAllTypeVariables(this.returnType);
&nbsp;        }
&nbsp;
&nbsp;        public Class&lt;?&gt; rawType() {
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public static class TypeVarBoundedType implements BoundedType {</b>
&nbsp;        private final TypeVariable&lt;?&gt; typeVariable;
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public TypeVarBoundedType(TypeVariable&lt;?&gt; typeVariable) {</b>
&nbsp;            this.typeVariable = typeVariable;
&nbsp;        }
&nbsp;
&nbsp;        public Type firstBound() {
<b class="nc">&nbsp;            return this.typeVariable.getBounds()[0];</b>
&nbsp;        }
&nbsp;
&nbsp;        public Type[] interfaceBounds() {
&nbsp;            Type[] interfaceBounds = new Type[this.typeVariable.getBounds().length - 1];
&nbsp;            System.arraycopy(this.typeVariable.getBounds(), 1, interfaceBounds, 0, this.typeVariable.getBounds().length - 1);
&nbsp;            return interfaceBounds;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(Object o) {
&nbsp;            if (this == o) {
&nbsp;                return true;
&nbsp;            } else {
&nbsp;                return o != null &amp;&amp; this.getClass() == o.getClass() ? this.typeVariable.equals(((TypeVarBoundedType)o).typeVariable) : false;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.typeVariable.hashCode();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public String toString() {</b>
&nbsp;            String var10000 = String.valueOf(this.firstBound());
&nbsp;            return &quot;{firstBound=&quot; + var10000 + &quot;, interfaceBounds=&quot; + Arrays.deepToString(this.interfaceBounds()) + &quot;}&quot;;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public TypeVariable&lt;?&gt; typeVariable() {
&nbsp;            return this.typeVariable;
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public static class WildCardBoundedType implements BoundedType {
&nbsp;        private final WildcardType wildcard;
&nbsp;
&nbsp;        public WildCardBoundedType(WildcardType wildcard) {
&nbsp;            this.wildcard = wildcard;
&nbsp;        }
&nbsp;
&nbsp;        public Type firstBound() {
&nbsp;            Type[] lowerBounds = this.wildcard.getLowerBounds();
&nbsp;            Type[] upperBounds = this.wildcard.getUpperBounds();
&nbsp;            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public Type[] interfaceBounds() {</b>
<b class="fc">&nbsp;            return new Type[0];</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public boolean equals(Object o) {
<b class="fc">&nbsp;            if (this == o) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            } else {
&nbsp;                return o != null &amp;&amp; this.getClass() == o.getClass() ? this.wildcard.equals(((TypeVarBoundedType)o).typeVariable) : false;
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return this.wildcard.hashCode();
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return &quot;{firstBound=&quot; + String.valueOf(this.firstBound()) + &quot;, interfaceBounds=[]}&quot;;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public WildcardType wildCard() {
&nbsp;            return this.wildcard;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface BoundedType extends Type {
&nbsp;        Type firstBound();
&nbsp;
&nbsp;        Type[] interfaceBounds();
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
