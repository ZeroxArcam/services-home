


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > MethodDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: MethodDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    47.7%
  </span>
  <span class="absValue">
    (21/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    15.6%
  </span>
  <span class="absValue">
    (52/334)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.3%
  </span>
  <span class="absValue">
    (66/251)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedConstructor</td>
<td class="coverageStat">
  <span class="percent">
    72.2%
  </span>
  <span class="absValue">
    (13/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.2%
  </span>
  <span class="absValue">
    (13/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedMethod</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (16/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (4/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (20/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase$Executable</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase$ForLoadedExecutable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent$TypeInitializer</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    35.7%
  </span>
  <span class="absValue">
    (5/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    51.5%
  </span>
  <span class="absValue">
    (17/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (15/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    7.5%
  </span>
  <span class="absValue">
    (3/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59%
  </span>
  <span class="absValue">
    (36/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.1%
  </span>
  <span class="absValue">
    (11/18)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    73.9%
  </span>
  <span class="absValue">
    (119/161)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    18.2%
  </span>
  <span class="absValue">
    (77/422)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49.4%
  </span>
  <span class="absValue">
    (244/494)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.GenericDeclaration;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.security.AccessController;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin.Enhance;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.DeclaredByType;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription.ForLoadedAnnotation;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor.Resolver;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.description.type.TypeDefinition.Sort;
&nbsp;import net.bytebuddy.description.type.TypeDescription.ForLoadedType;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure;
&nbsp;import net.bytebuddy.description.type.TypeDescription.Generic.Visitor.Substitutor.ForAttachment;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForDetachedTypes;
&nbsp;import net.bytebuddy.description.type.TypeList.Generic.ForLoadedTypes.OfTypeVariables;
&nbsp;import net.bytebuddy.jar.asm.Type;
&nbsp;import net.bytebuddy.jar.asm.signature.SignatureWriter;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Defaults;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher.Proxied;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;public interface MethodDescription extends TypeVariableSource, ModifierReviewable.ForMethodDescription, DeclaredByType.WithMandatoryDeclaration, ByteCodeElement.Member, ByteCodeElement.TypeDependant&lt;InDefinedShape, Token&gt; {
&nbsp;    String CONSTRUCTOR_INTERNAL_NAME = &quot;&lt;init&gt;&quot;;
&nbsp;    String TYPE_INITIALIZER_INTERNAL_NAME = &quot;&lt;clinit&gt;&quot;;
&nbsp;    int TYPE_INITIALIZER_MODIFIER = 8;
&nbsp;    @AlwaysNull
&nbsp;    InDefinedShape UNDEFINED = null;
&nbsp;
&nbsp;    @Nonnull
&nbsp;    TypeDefinition getDeclaringType();
&nbsp;
&nbsp;    TypeDescription.Generic getReturnType();
&nbsp;
&nbsp;    ParameterList&lt;?&gt; getParameters();
&nbsp;
&nbsp;    TypeList.Generic getExceptionTypes();
&nbsp;
&nbsp;    int getActualModifiers();
&nbsp;
&nbsp;    int getActualModifiers(boolean var1);
&nbsp;
&nbsp;    int getActualModifiers(boolean var1, Visibility var2);
&nbsp;
&nbsp;    boolean isConstructor();
&nbsp;
&nbsp;    boolean isMethod();
&nbsp;
<b class="fc">&nbsp;    boolean isTypeInitializer();</b>
&nbsp;
&nbsp;    boolean represents(Method var1);
&nbsp;
&nbsp;    boolean represents(Constructor&lt;?&gt; var1);
&nbsp;
&nbsp;    boolean isVirtual();
&nbsp;
&nbsp;    int getStackSize();
&nbsp;
&nbsp;    boolean isDefaultMethod();
&nbsp;
&nbsp;    boolean isSpecializableFor(TypeDescription var1);
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    AnnotationValue&lt;?, ?&gt; getDefaultValue();
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    &lt;T&gt; T getDefaultValue(Class&lt;T&gt; var1);
&nbsp;
&nbsp;    boolean isInvokableOn(TypeDescription var1);
&nbsp;
&nbsp;    boolean isInvokeBootstrap();
&nbsp;
&nbsp;    boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;    boolean isConstantBootstrap();
&nbsp;
&nbsp;    boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; var1);
&nbsp;
&nbsp;    boolean isDefaultValue();
&nbsp;
&nbsp;    boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; var1);
&nbsp;
&nbsp;    @MaybeNull
&nbsp;    TypeDescription.Generic getReceiverType();
&nbsp;
&nbsp;    SignatureToken asSignatureToken();
&nbsp;
&nbsp;    TypeToken asTypeToken();
&nbsp;
&nbsp;    boolean isBridgeCompatible(TypeToken var1);
&nbsp;
&nbsp;    public abstract static class AbstractBase extends TypeVariableSource.AbstractBase implements MethodDescription {
&nbsp;        private static final int SOURCE_MODIFIERS = 1343;
&nbsp;
&nbsp;        public AbstractBase() {
&nbsp;        }
&nbsp;
&nbsp;        public int getStackSize() {
&nbsp;            return this.getParameters().asTypeList().getStackSize() + (this.isStatic() ? 0 : 1);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isMethod() {
&nbsp;            return !this.isConstructor() &amp;&amp; !this.isTypeInitializer();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstructor() {
&nbsp;            return &quot;&lt;init&gt;&quot;.equals(this.getInternalName());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return &quot;&lt;clinit&gt;&quot;.equals(this.getInternalName());
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Method method) {
&nbsp;            return this.equals(new ForLoadedMethod(method));
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
&nbsp;            return this.equals(new ForLoadedConstructor(constructor));
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return this.isMethod() ? this.getInternalName() : this.getDeclaringType().asErasure().getName();
&nbsp;        }
&nbsp;
&nbsp;        public String getActualName() {
&nbsp;            return this.isMethod() ? this.getName() : &quot;&quot;;
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder descriptor = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;
&nbsp;            for(TypeDescription parameterType : this.getParameters().asTypeList().asErasures()) {
&nbsp;                descriptor.append(parameterType.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return descriptor.append(&#39;)&#39;).append(this.getReturnType().asErasure().getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();
&nbsp;                boolean generic = false;
&nbsp;
&nbsp;                for(TypeDescription.Generic typeVariable : this.getTypeVariables()) {
&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());
&nbsp;                    boolean classBound = true;
&nbsp;
&nbsp;                    for(TypeDescription.Generic upperBound : typeVariable.getUpperBounds()) {
&nbsp;                        upperBound.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(classBound ? signatureWriter.visitClassBound() : signatureWriter.visitInterfaceBound()));
&nbsp;                        classBound = false;
&nbsp;                    }
&nbsp;
&nbsp;                    generic = true;
&nbsp;                }
&nbsp;
&nbsp;                for(TypeDescription.Generic parameterType : this.getParameters().asTypeList()) {
&nbsp;                    parameterType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitParameterType()));
&nbsp;                    generic = generic || !parameterType.getSort().isNonGeneric();
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription.Generic returnType = this.getReturnType();
&nbsp;                returnType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitReturnType()));
&nbsp;                generic = generic || !returnType.getSort().isNonGeneric();
&nbsp;                TypeList.Generic exceptionTypes = this.getExceptionTypes();
&nbsp;                if (!((TypeList.Generic)exceptionTypes.filter(ElementMatchers.not(ElementMatchers.ofSort(Sort.NON_GENERIC)))).isEmpty()) {
&nbsp;                    for(TypeDescription.Generic exceptionType : exceptionTypes) {
&nbsp;                        exceptionType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitExceptionType()));
&nbsp;                        generic = generic || !exceptionType.getSort().isNonGeneric();
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                return generic ? signatureWriter.toString() : NON_GENERIC_SIGNATURE;
&nbsp;            } catch (GenericSignatureFormatError var8) {
&nbsp;                return NON_GENERIC_SIGNATURE;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers() {
&nbsp;            return this.getModifiers() | (this.getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? 131072 : 0);
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean manifest) {
&nbsp;            int modifiers = this.getActualModifiers();
&nbsp;            if (manifest) {
&nbsp;                return modifiers &amp; -1281;
&nbsp;            } else {
&nbsp;                return (modifiers &amp; 1280) == 0 ? modifiers | 1024 : modifiers;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public int getActualModifiers(boolean manifest, Visibility visibility) {
&nbsp;            return Resolver.of(Collections.singleton(this.getVisibility().expandTo(visibility))).resolve(this.getActualModifiers(manifest));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
&nbsp;            return this.getDeclaringType().asErasure().equals(typeDescription) || this.isPublic() &amp;&amp; this.getDeclaringType().isPublic() || (this.isPublic() || this.isProtected()) &amp;&amp; this.getDeclaringType().asErasure().isAssignableFrom(typeDescription) || !this.isPrivate() &amp;&amp; this.getDeclaringType().asErasure().isSamePackage(typeDescription) || this.isPrivate() &amp;&amp; this.getDeclaringType().asErasure().isNestMateOf(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
&nbsp;            return this.getDeclaringType().asErasure().equals(typeDescription) || this.isPublic() &amp;&amp; this.getDeclaringType().isPublic() || !this.isPrivate() &amp;&amp; this.getDeclaringType().asErasure().isSamePackage(typeDescription) || this.isPrivate() &amp;&amp; this.getDeclaringType().asErasure().isNestMateOf(typeDescription);
&nbsp;        }
&nbsp;
&nbsp;        public boolean isVirtual() {
&nbsp;            return !this.isConstructor() &amp;&amp; !this.isPrivate() &amp;&amp; !this.isStatic() &amp;&amp; !this.isTypeInitializer();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isDefaultMethod() {
&nbsp;            return !this.isAbstract() &amp;&amp; !this.isBridge() &amp;&amp; this.getDeclaringType().isInterface();
&nbsp;        }
&nbsp;
&nbsp;        public boolean isSpecializableFor(TypeDescription targetType) {
&nbsp;            if (this.isStatic()) {
&nbsp;                return false;
&nbsp;            } else if (!this.isPrivate() &amp;&amp; !this.isConstructor()) {
&nbsp;                return !this.isAbstract() &amp;&amp; this.getDeclaringType().asErasure().isAssignableFrom(targetType);
&nbsp;            } else {
&nbsp;                return this.getDeclaringType().equals(targetType);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type) {
&nbsp;            return (T)type.cast(this.getDefaultValue());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokableOn(TypeDescription typeDescription) {
&nbsp;            boolean var10000;
&nbsp;            label29: {
&nbsp;                if (!this.isStatic() &amp;&amp; !this.isTypeInitializer() &amp;&amp; this.isVisibleTo(typeDescription)) {
&nbsp;                    if (this.isVirtual()) {
&nbsp;                        if (this.getDeclaringType().asErasure().isAssignableFrom(typeDescription)) {
&nbsp;                            break label29;
&nbsp;                        }
&nbsp;                    } else if (this.getDeclaringType().asErasure().equals(typeDescription)) {
&nbsp;                        break label29;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                var10000 = false;
&nbsp;                return var10000;
&nbsp;            }
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        private boolean isBootstrap(TypeDescription bootstrapped) {
&nbsp;            TypeList parameterTypes = this.getParameters().asTypeList().asErasures();
&nbsp;            switch (parameterTypes.size()) {
&nbsp;                case 0:
&nbsp;                    return false;
&nbsp;                case 1:
&nbsp;                    return ((TypeDescription)parameterTypes.getOnly()).represents(Object[].class);
&nbsp;                case 2:
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; ((TypeDescription)parameterTypes.get(1)).represents(Object[].class);
&nbsp;                case 3:
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; (((TypeDescription)parameterTypes.get(1)).represents(Object.class) || ((TypeDescription)parameterTypes.get(1)).represents(String.class)) &amp;&amp; (((TypeDescription)parameterTypes.get(2)).isArray() &amp;&amp; ((TypeDescription)parameterTypes.get(2)).getComponentType().isAssignableFrom(bootstrapped) || ((TypeDescription)parameterTypes.get(2)).isAssignableFrom(bootstrapped));
&nbsp;                default:
&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo((TypeDescription)parameterTypes.get(0)) &amp;&amp; (((TypeDescription)parameterTypes.get(1)).represents(Object.class) || ((TypeDescription)parameterTypes.get(1)).represents(String.class)) &amp;&amp; ((TypeDescription)parameterTypes.get(2)).isAssignableFrom(bootstrapped);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @SuppressFBWarnings(
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;            justification = &quot;Assuming component type for array type.&quot;
&nbsp;        )
&nbsp;        private boolean isBootstrapping(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            TypeList targets = this.getParameters().asTypeList().asErasures();
&nbsp;            if (targets.size() &lt; 4) {
&nbsp;                if (arguments.isEmpty()) {
&nbsp;                    return true;
&nbsp;                } else if (((TypeDescription)targets.get(targets.size() - 1)).isArray()) {
&nbsp;                    for(TypeDefinition argument : arguments) {
&nbsp;                        if (!argument.asErasure().isAssignableTo(((TypeDescription)targets.get(targets.size() - 1)).getComponentType())) {
&nbsp;                            return false;
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            } else {
&nbsp;                Iterator&lt;TypeDescription&gt; iterator = ((TypeList)targets.subList(3, targets.size())).iterator();
&nbsp;
&nbsp;                for(TypeDefinition type : arguments) {
&nbsp;                    if (!iterator.hasNext()) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;
&nbsp;                    TypeDescription target = (TypeDescription)iterator.next();
&nbsp;                    if (!iterator.hasNext() &amp;&amp; target.isArray()) {
&nbsp;                        return true;
&nbsp;                    }
&nbsp;
&nbsp;                    if (!type.asErasure().isAssignableTo(target)) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                if (!iterator.hasNext()) {
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    return ((TypeDescription)iterator.next()).isArray() &amp;&amp; !iterator.hasNext();
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokeBootstrap() {
&nbsp;            TypeDescription returnType = this.getReturnType().asErasure();
<b class="fc">&nbsp;            return (!this.isMethod() || this.isStatic() &amp;&amp; (JavaType.CALL_SITE.getTypeStub().isAssignableFrom(returnType) || JavaType.CALL_SITE.getTypeStub().isAssignableTo(returnType))) &amp;&amp; (!this.isConstructor() || JavaType.CALL_SITE.getTypeStub().isAssignableFrom(this.getDeclaringType().asErasure())) ? this.isBootstrap(JavaType.METHOD_TYPE.getTypeStub()) : false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            return this.isInvokeBootstrap() &amp;&amp; this.isBootstrapping(arguments);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isConstantBootstrap() {
&nbsp;            return this.isBootstrap(ForLoadedType.of(Class.class));
&nbsp;        }
&nbsp;
&nbsp;        public boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
&nbsp;            return this.isConstantBootstrap() &amp;&amp; this.isBootstrapping(arguments);
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public boolean isDefaultValue() {</b>
<b class="fc">&nbsp;            return !this.isConstructor() &amp;&amp; !this.isStatic() &amp;&amp; this.getReturnType().asErasure().isAnnotationReturnType() &amp;&amp; this.getParameters().isEmpty();</b>
<b class="fc">&nbsp;        }</b>
<b class="pc">&nbsp;</b>
<b class="fc">&nbsp;        @SuppressFBWarnings(</b>
&nbsp;            value = {&quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
<b class="nc">&nbsp;            justification = &quot;Assuming component type for array type.&quot;</b>
<b class="nc">&nbsp;        )</b>
<b class="nc">&nbsp;        public boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {</b>
&nbsp;            if (!this.isDefaultValue()) {
&nbsp;                return false;
<b class="fc">&nbsp;            } else {</b>
&nbsp;                TypeDescription returnType = this.getReturnType().asErasure();
&nbsp;                Object value = annotationValue.resolve();
&nbsp;                return returnType.represents(Boolean.TYPE) &amp;&amp; value instanceof Boolean || returnType.represents(Byte.TYPE) &amp;&amp; value instanceof Byte || returnType.represents(Character.TYPE) &amp;&amp; value instanceof Character || returnType.represents(Short.TYPE) &amp;&amp; value instanceof Short || returnType.represents(Integer.TYPE) &amp;&amp; value instanceof Integer || returnType.represents(Long.TYPE) &amp;&amp; value instanceof Long || returnType.represents(Float.TYPE) &amp;&amp; value instanceof Float || returnType.represents(Double.TYPE) &amp;&amp; value instanceof Double || returnType.represents(String.class) &amp;&amp; value instanceof String || returnType.isAssignableTo(Enum.class) &amp;&amp; value instanceof EnumerationDescription &amp;&amp; isEnumerationType(returnType, (EnumerationDescription)value) || returnType.isAssignableTo(Annotation.class) &amp;&amp; value instanceof AnnotationDescription &amp;&amp; isAnnotationType(returnType, (AnnotationDescription)value) || returnType.represents(Class.class) &amp;&amp; value instanceof TypeDescription || returnType.represents(boolean[].class) &amp;&amp; value instanceof boolean[] || returnType.represents(byte[].class) &amp;&amp; value instanceof byte[] || returnType.represents(char[].class) &amp;&amp; value instanceof char[] || returnType.represents(short[].class) &amp;&amp; value instanceof short[] || returnType.represents(int[].class) &amp;&amp; value instanceof int[] || returnType.represents(long[].class) &amp;&amp; value instanceof long[] || returnType.represents(float[].class) &amp;&amp; value instanceof float[] || returnType.represents(double[].class) &amp;&amp; value instanceof double[] || returnType.represents(String[].class) &amp;&amp; value instanceof String[] || returnType.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[] &amp;&amp; isEnumerationType(returnType.getComponentType(), (EnumerationDescription[])value) || returnType.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[] &amp;&amp; isAnnotationType(returnType.getComponentType(), (AnnotationDescription[])value) || returnType.represents(Class[].class) &amp;&amp; value instanceof TypeDescription[];
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private static boolean isEnumerationType(TypeDescription enumerationType, EnumerationDescription... enumerationDescription) {
&nbsp;            for(EnumerationDescription anEnumerationDescription : enumerationDescription) {
&nbsp;                if (!anEnumerationDescription.getEnumerationType().equals(enumerationType)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        private static boolean isAnnotationType(TypeDescription annotationType, AnnotationDescription... annotationDescription) {
&nbsp;            for(AnnotationDescription anAnnotationDescription : annotationDescription) {
&nbsp;                if (!anAnnotationDescription.getAnnotationType().equals(annotationType)) {
&nbsp;                    return false;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return true;
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        @MaybeNull</b>
&nbsp;        public TypeVariableSource getEnclosingSource() {
&nbsp;            return (TypeVariableSource)(this.isStatic() ? TypeVariableSource.UNDEFINED : this.getDeclaringType().asErasure());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isInferrable() {
&nbsp;            return true;
&nbsp;        }
&nbsp;
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
&nbsp;            return (T)visitor.onMethod((InDefinedShape)this.asDefined());
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean isGenerified() {
&nbsp;            return !this.getTypeVariables().isEmpty();
&nbsp;        }
&nbsp;
&nbsp;        public Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
&nbsp;            TypeDescription.Generic receiverType = this.getReceiverType();
<b class="fc">&nbsp;            return new Token(this.getInternalName(), this.getModifiers(), this.getTypeVariables().asTokenList(matcher), (TypeDescription.Generic)this.getReturnType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)), this.getParameters().asTokenList(matcher), this.getExceptionTypes().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)), this.getDeclaredAnnotations(), this.getDefaultValue(), receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)receiverType.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public SignatureToken asSignatureToken() {</b>
&nbsp;            return new SignatureToken(this.getInternalName(), this.getReturnType().asErasure(), this.getParameters().asTypeList().asErasures());
&nbsp;        }
&nbsp;
&nbsp;        public TypeToken asTypeToken() {
&nbsp;            return new TypeToken(this.getReturnType().asErasure(), this.getParameters().asTypeList().asErasures());
&nbsp;        }
&nbsp;
&nbsp;        public boolean isBridgeCompatible(TypeToken typeToken) {
&nbsp;            List&lt;TypeDescription&gt; types = this.getParameters().asTypeList().asErasures();
&nbsp;            List&lt;TypeDescription&gt; bridgeTypes = typeToken.getParameterTypes();
&nbsp;            if (types.size() != bridgeTypes.size()) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                for(int index = 0; index &lt; types.size(); ++index) {
&nbsp;                    if (!((TypeDescription)types.get(index)).equals(bridgeTypes.get(index)) &amp;&amp; (((TypeDescription)types.get(index)).isPrimitive() || ((TypeDescription)bridgeTypes.get(index)).isPrimitive())) {
&nbsp;                        return false;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                TypeDescription returnType = this.getReturnType().asErasure();
&nbsp;                TypeDescription bridgeReturnType = typeToken.getReturnType();
&nbsp;                return returnType.equals(bridgeReturnType) || !returnType.isPrimitive() &amp;&amp; !bridgeReturnType.isPrimitive();
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        @Enhance(&quot;hashCode&quot;)</b>
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int hashCode = 17 + this.getDeclaringType().hashCode();
&nbsp;                hashCode = 31 * hashCode + this.getInternalName().hashCode();
&nbsp;                hashCode = 31 * hashCode + this.getReturnType().asErasure().hashCode();
&nbsp;                var10000 = 31 * hashCode + this.getParameters().asTypeList().asErasures().hashCode();
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            } else if (!(other instanceof MethodDescription)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                MethodDescription methodDescription = (MethodDescription)other;
&nbsp;                return this.getInternalName().equals(methodDescription.getInternalName()) &amp;&amp; this.getDeclaringType().equals(methodDescription.getDeclaringType()) &amp;&amp; this.getReturnType().asErasure().equals(methodDescription.getReturnType().asErasure()) &amp;&amp; this.getParameters().asTypeList().asErasures().equals(methodDescription.getParameters().asTypeList().asErasures());
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public String toGenericString() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder();
&nbsp;            int modifiers = this.getModifiers() &amp; 1343;
&nbsp;            if (modifiers != 0) {
&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            if (this.isMethod()) {
&nbsp;                stringBuilder.append(this.getReturnType().getActualName()).append(&#39; &#39;);
&nbsp;                stringBuilder.append(this.getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            stringBuilder.append(this.getName()).append(&#39;(&#39;);</b>
&nbsp;            boolean first = true;
&nbsp;
&nbsp;            for(TypeDescription.Generic typeDescription : this.getParameters().asTypeList()) {
&nbsp;                if (!first) {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                } else {
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                }
&nbsp;
&nbsp;                stringBuilder.append(typeDescription.getActualName());
&nbsp;            }
&nbsp;
&nbsp;            stringBuilder.append(&#39;)&#39;);
<b class="pc">&nbsp;            TypeList.Generic exceptionTypes = this.getExceptionTypes();</b>
<b class="fc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&quot; throws &quot;);</b>
&nbsp;                first = true;
&nbsp;
&nbsp;                for(TypeDescription.Generic typeDescription : exceptionTypes) {
&nbsp;                    if (!first) {
&nbsp;                        stringBuilder.append(&#39;,&#39;);
&nbsp;                    } else {
<b class="fc">&nbsp;                        first = false;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    stringBuilder.append(typeDescription.getActualName());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.toString();
&nbsp;        }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        public String toString() {</b>
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
&nbsp;            int modifiers = this.getModifiers() &amp; 1343;
<b class="fc">&nbsp;            if (modifiers != 0) {</b>
&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);
&nbsp;            }
&nbsp;
&nbsp;            if (this.isMethod()) {
&nbsp;                stringBuilder.append(this.getReturnType().asErasure().getActualName()).append(&#39; &#39;);
&nbsp;                stringBuilder.append(this.getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            stringBuilder.append(this.getName()).append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            boolean first = true;</b>
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            for(TypeDescription typeDescription : this.getParameters().asTypeList().asErasures()) {</b>
<b class="nc">&nbsp;                if (!first) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    first = false;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                stringBuilder.append(typeDescription.getActualName());
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            stringBuilder.append(&#39;)&#39;);</b>
<b class="fc">&nbsp;            TypeList exceptionTypes = this.getExceptionTypes().asErasures();</b>
<b class="pc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
&nbsp;                stringBuilder.append(&quot; throws &quot;);
<b class="fc">&nbsp;                first = true;</b>
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;                for(TypeDescription typeDescription : exceptionTypes) {</b>
<b class="fc">&nbsp;                    if (!first) {</b>
<b class="pc">&nbsp;                        stringBuilder.append(&#39;,&#39;);</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="nc">&nbsp;                        first = false;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    stringBuilder.append(typeDescription.getActualName());
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            return stringBuilder.toString();
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        protected String toSafeString() {
&nbsp;            StringBuilder stringBuilder = new StringBuilder();
&nbsp;            int modifiers = this.getModifiers() &amp; 1343;
&nbsp;            if (modifiers != 0) {
&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);
&nbsp;            }
<b class="pc">&nbsp;</b>
&nbsp;            if (this.isMethod()) {
&nbsp;                stringBuilder.append(&#39;?&#39;).append(&#39; &#39;);
&nbsp;                stringBuilder.append(this.getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(this.getName()).append(&quot;(?)&quot;).toString();
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
<b class="pc">&nbsp;    public static class ForLoadedConstructor extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Constructor&lt;?&gt;&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {</b>
<b class="fc">&nbsp;        public ForLoadedConstructor(Constructor&lt;?&gt; constructor) {</b>
<b class="nc">&nbsp;            super(constructor);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        @Nonnull</b>
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return ForLoadedType.of(((Constructor)this.executable).getDeclaringClass());
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Void.TYPE);
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        @Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            ParameterList var1 = this.parameters;
&nbsp;            ParameterList var2 = var1 != null ? null : net.bytebuddy.description.method.ParameterList.ForLoadedExecutable.of(this.executable, this);
&nbsp;            if (var2 == null) {
&nbsp;                var2 = this.parameters;
<b class="fc">&nbsp;            } else {</b>
<b class="pc">&nbsp;                this.parameters = var2;</b>
<b class="pc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="pc">&nbsp;            return var2;</b>
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return new TypeList.Generic.OfConstructorExceptionTypes(this.executable);
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public boolean isConstructor() {</b>
<b class="pc">&nbsp;            return true;</b>
<b class="pc">&nbsp;        }</b>
<b class="pc">&nbsp;</b>
&nbsp;        public boolean isTypeInitializer() {
&nbsp;            return false;
&nbsp;        }
&nbsp;
&nbsp;        public boolean represents(Method method) {
&nbsp;            return false;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
&nbsp;            return ((Constructor)this.executable).equals(constructor) || this.equals(new ForLoadedConstructor(constructor));
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return ((Constructor)this.executable).getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return ((Constructor)this.executable).getModifiers();
&nbsp;        }
&nbsp;
<b class="pc">&nbsp;        public boolean isSynthetic() {</b>
<b class="nc">&nbsp;            return ((Constructor)this.executable).isSynthetic();</b>
<b class="pc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return &quot;&lt;init&gt;&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return Type.getConstructorDescriptor(this.executable);
&nbsp;        }
&nbsp;
&nbsp;        @AlwaysNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;            return AnnotationValue.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            AnnotationList var1 = this.declaredAnnotations;
&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(((Constructor)this.executable).getDeclaredAnnotations());
<b class="pc">&nbsp;            if (var2 == null) {</b>
<b class="pc">&nbsp;                var2 = this.declaredAnnotations;</b>
<b class="pc">&nbsp;            } else {</b>
<b class="pc">&nbsp;                this.declaredAnnotations = (AnnotationList)var2;</b>
<b class="pc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getTypeVariables() {
&nbsp;            return OfTypeVariables.of((GenericDeclaration)this.executable);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
&nbsp;            Annotation[][] var1 = this.parameterAnnotations;
<b class="nc">&nbsp;            Annotation[][] var2 = var1 != null ? null : ((Constructor)this.executable).getParameterAnnotations();</b>
<b class="nc">&nbsp;            if (var2 == null) {</b>
&nbsp;                var2 = this.parameterAnnotations;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                this.parameterAnnotations = var2;
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return var2;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static class ForLoadedMethod extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Method&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {</b>
<b class="nc">&nbsp;        public ForLoadedMethod(Method method) {</b>
&nbsp;            super(method);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Nonnull</b>
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return ForLoadedType.of(((Method)this.executable).getDeclaringClass());
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(((Method)this.executable).getReturnType()) : new TypeDescription.Generic.LazyProjection.ForLoadedReturnType(this.executable));
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            ParameterList var1 = this.parameters;
&nbsp;            ParameterList var2 = var1 != null ? null : net.bytebuddy.description.method.ParameterList.ForLoadedExecutable.of(this.executable, this);
<b class="nc">&nbsp;            if (var2 == null) {</b>
<b class="nc">&nbsp;                var2 = this.parameters;</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                this.parameters = var2;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return var2;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="nc">&nbsp;            return (TypeList.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? new TypeList.Generic.ForLoadedTypes(((Method)this.executable).getExceptionTypes()) : new TypeList.Generic.OfMethodExceptionTypes(this.executable));</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public boolean isConstructor() {
&nbsp;            return false;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isTypeInitializer() {</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isBridge() {</b>
<b class="nc">&nbsp;            return ((Method)this.executable).isBridge();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public boolean represents(Method method) {
&nbsp;            return ((Method)this.executable).equals(method) || this.equals(new ForLoadedMethod(method));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        public String getName() {
&nbsp;            return ((Method)this.executable).getName();
&nbsp;        }
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return ((Method)this.executable).getModifiers();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isSynthetic() {</b>
<b class="nc">&nbsp;            return ((Method)this.executable).isSynthetic();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public String getInternalName() {</b>
&nbsp;            return ((Method)this.executable).getName();
&nbsp;        }
&nbsp;
&nbsp;        public String getDescriptor() {
&nbsp;            return Type.getMethodDescriptor(this.executable);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Method getLoadedMethod() {
&nbsp;            return this.executable;
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;            AnnotationList var1 = this.declaredAnnotations;</b>
&nbsp;            Object var2 = var1 != null ? null : new AnnotationList.ForLoadedAnnotations(((Method)this.executable).getDeclaredAnnotations());
&nbsp;            if (var2 == null) {
&nbsp;                var2 = this.declaredAnnotations;
&nbsp;            } else {
&nbsp;                this.declaredAnnotations = (AnnotationList)var2;
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            return (AnnotationList)var2;
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            Object value = ((Method)this.executable).getDefaultValue();
<b class="nc">&nbsp;            return value == null ? AnnotationValue.UNDEFINED : ForLoadedAnnotation.asValue(value, ((Method)this.executable).getReturnType());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public TypeList.Generic getTypeVariables() {</b>
&nbsp;            return (TypeList.Generic)(net.bytebuddy.description.type.TypeDescription.AbstractBase.RAW_TYPES ? new TypeList.Generic.Empty() : OfTypeVariables.of((GenericDeclaration)this.executable));
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
&nbsp;            Annotation[][] var1 = this.parameterAnnotations;
&nbsp;            Annotation[][] var2 = var1 != null ? null : ((Method)this.executable).getParameterAnnotations();
<b class="nc">&nbsp;            if (var2 == null) {</b>
<b class="nc">&nbsp;                var2 = this.parameterAnnotations;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                this.parameterAnnotations = var2;</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;            return var2;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static class Latent extends InDefinedShape.AbstractBase {</b>
<b class="nc">&nbsp;        private final TypeDescription declaringType;</b>
<b class="nc">&nbsp;        private final String internalName;</b>
<b class="nc">&nbsp;        private final int modifiers;</b>
<b class="nc">&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariables;</b>
<b class="nc">&nbsp;        private final TypeDescription.Generic returnType;</b>
<b class="nc">&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;</b>
<b class="nc">&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;</b>
<b class="nc">&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;</b>
<b class="nc">&nbsp;        @MaybeNull</b>
<b class="nc">&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;</b>
<b class="nc">&nbsp;        @MaybeNull</b>
<b class="nc">&nbsp;        private final TypeDescription.Generic receiverType;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Latent(TypeDescription declaringType, Token token) {</b>
<b class="nc">&nbsp;            this(declaringType, token.getName(), token.getModifiers(), token.getTypeVariableTokens(), token.getReturnType(), token.getParameterTokens(), token.getExceptionTypes(), token.getAnnotations(), token.getDefaultValue(), token.getReceiverType());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Latent(TypeDescription declaringType, String internalName, int modifiers, List&lt;? extends TypeVariableToken&gt; typeVariables, TypeDescription.Generic returnType, List&lt;? extends ParameterDescription.Token&gt; parameterTokens, List&lt;? extends TypeDescription.Generic&gt; exceptionTypes, List&lt;? extends AnnotationDescription&gt; declaredAnnotations, @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue, @MaybeNull TypeDescription.Generic receiverType) {</b>
&nbsp;            this.declaringType = declaringType;
&nbsp;            this.internalName = internalName;
&nbsp;            this.modifiers = modifiers;
&nbsp;            this.typeVariables = typeVariables;
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTokens = parameterTokens;
&nbsp;            this.exceptionTypes = exceptionTypes;
&nbsp;            this.declaredAnnotations = declaredAnnotations;
&nbsp;            this.defaultValue = defaultValue;
&nbsp;            this.receiverType = receiverType;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public TypeList.Generic getTypeVariables() {</b>
&nbsp;            return ForDetachedTypes.attachVariables(this, this.typeVariables);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)this.returnType.accept(ForAttachment.of(this));
&nbsp;        }
&nbsp;
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;            return new ParameterList.ForTokens(this, this.parameterTokens);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return ForDetachedTypes.attach(this, this.exceptionTypes);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public AnnotationList getDeclaredAnnotations() {</b>
&nbsp;            return new AnnotationList.Explicit(this.declaredAnnotations);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public String getInternalName() {
&nbsp;            return this.internalName;
&nbsp;        }
&nbsp;
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
&nbsp;            return this.declaringType;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public int getModifiers() {</b>
&nbsp;            return this.modifiers;
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return this.defaultValue;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription.Generic getReceiverType() {
&nbsp;            return this.receiverType == null ? super.getReceiverType() : (TypeDescription.Generic)this.receiverType.accept(ForAttachment.of(this));
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public static class TypeInitializer extends InDefinedShape.AbstractBase {</b>
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            public TypeInitializer(TypeDescription typeDescription) {
&nbsp;                this.typeDescription = typeDescription;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            public TypeDescription.Generic getReturnType() {</b>
&nbsp;                return net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Void.TYPE);
&nbsp;            }
&nbsp;
&nbsp;            public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
&nbsp;                return new ParameterList.Empty();
&nbsp;            }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            public TypeList.Generic getExceptionTypes() {</b>
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;            @AlwaysNull</b>
<b class="fc">&nbsp;            public AnnotationValue&lt;?, ?&gt; getDefaultValue() {</b>
<b class="fc">&nbsp;                return AnnotationValue.UNDEFINED;</b>
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            public AnnotationList getDeclaredAnnotations() {
&nbsp;                return new AnnotationList.Empty();
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            @Nonnull</b>
&nbsp;            public TypeDescription getDeclaringType() {
&nbsp;                return this.typeDescription;
&nbsp;            }
&nbsp;
&nbsp;            public int getModifiers() {
&nbsp;                return 8;
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            public String getInternalName() {
&nbsp;                return &quot;&lt;clinit&gt;&quot;;
&nbsp;            }
&nbsp;        }
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    public static class TypeSubstituting extends AbstractBase implements InGenericShape {</b>
<b class="nc">&nbsp;        private final TypeDescription.Generic declaringType;</b>
&nbsp;        private final MethodDescription methodDescription;
<b class="nc">&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType, MethodDescription methodDescription, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
&nbsp;            this.declaringType = declaringType;
&nbsp;            this.methodDescription = methodDescription;
<b class="nc">&nbsp;            this.visitor = visitor;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public TypeDescription.Generic getReturnType() {
&nbsp;            return (TypeDescription.Generic)this.methodDescription.getReturnType().accept(this.visitor);
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public TypeList.Generic getTypeVariables() {</b>
<b class="fc">&nbsp;            return (TypeList.Generic)this.methodDescription.getTypeVariables().accept(this.visitor).filter(ElementMatchers.ofSort(Sort.VARIABLE));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
&nbsp;        public ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters() {
&nbsp;            return new ParameterList.TypeSubstituting(this, this.methodDescription.getParameters(), this.visitor);
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TypeList.Generic getExceptionTypes() {</b>
<b class="nc">&nbsp;            return new TypeList.Generic.ForDetachedTypes(this.methodDescription.getExceptionTypes(), this.visitor);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        @MaybeNull
<b class="nc">&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {</b>
<b class="nc">&nbsp;            return this.methodDescription.getDefaultValue();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public TypeDescription.Generic getReceiverType() {</b>
&nbsp;            TypeDescription.Generic receiverType = this.methodDescription.getReceiverType();
&nbsp;            return receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)receiverType.accept(this.visitor);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getDeclaredAnnotations() {
&nbsp;            return this.methodDescription.getDeclaredAnnotations();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Nonnull</b>
<b class="nc">&nbsp;        public TypeDescription.Generic getDeclaringType() {</b>
&nbsp;            return this.declaringType;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int getModifiers() {</b>
&nbsp;            return this.methodDescription.getModifiers();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public String getInternalName() {</b>
<b class="nc">&nbsp;            return this.methodDescription.getInternalName();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public InDefinedShape asDefined() {</b>
&nbsp;            return (InDefinedShape)this.methodDescription.asDefined();
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public boolean isConstructor() {</b>
<b class="nc">&nbsp;            return this.methodDescription.isConstructor();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean isMethod() {</b>
<b class="nc">&nbsp;            return this.methodDescription.isMethod();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public boolean isTypeInitializer() {
<b class="nc">&nbsp;            return this.methodDescription.isTypeInitializer();</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public static class Token implements ByteCodeElement.Token&lt;Token&gt; {
<b class="nc">&nbsp;        private final String name;</b>
&nbsp;        private final int modifiers;
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
<b class="nc">&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;</b>
<b class="nc">&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;</b>
<b class="nc">&nbsp;        @MaybeNull</b>
<b class="nc">&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;</b>
&nbsp;        @MaybeNull
<b class="nc">&nbsp;        private final TypeDescription.Generic receiverType;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Token(int modifiers) {</b>
&nbsp;            this(&quot;&lt;init&gt;&quot;, modifiers, net.bytebuddy.description.type.TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Void.TYPE));
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType) {</b>
<b class="nc">&nbsp;            this(name, modifiers, returnType, Collections.emptyList());</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType, List&lt;? extends TypeDescription.Generic&gt; parameterTypes) {</b>
&nbsp;            this(name, modifiers, Collections.emptyList(), returnType, new ParameterDescription.TypeList(parameterTypes), Collections.emptyList(), Collections.emptyList(), AnnotationValue.UNDEFINED, Generic.UNDEFINED);
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Token(String name, int modifiers, List&lt;? extends TypeVariableToken&gt; typeVariableTokens, TypeDescription.Generic returnType, List&lt;? extends ParameterDescription.Token&gt; parameterTokens, List&lt;? extends TypeDescription.Generic&gt; exceptionTypes, List&lt;? extends AnnotationDescription&gt; annotations, @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue, @MaybeNull TypeDescription.Generic receiverType) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.modifiers = modifiers;</b>
<b class="nc">&nbsp;            this.typeVariableTokens = typeVariableTokens;</b>
<b class="nc">&nbsp;            this.returnType = returnType;</b>
<b class="nc">&nbsp;            this.parameterTokens = parameterTokens;</b>
<b class="nc">&nbsp;            this.exceptionTypes = exceptionTypes;</b>
<b class="nc">&nbsp;            this.annotations = annotations;</b>
&nbsp;            this.defaultValue = defaultValue;
<b class="nc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public String getName() {
&nbsp;            return this.name;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int getModifiers() {
&nbsp;            return this.modifiers;
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public ByteCodeElement.TokenList&lt;TypeVariableToken&gt; getTypeVariableTokens() {</b>
<b class="nc">&nbsp;            return new ByteCodeElement.TokenList(this.typeVariableTokens);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public TypeDescription.Generic getReturnType() {</b>
<b class="nc">&nbsp;            return this.returnType;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public ByteCodeElement.TokenList&lt;ParameterDescription.Token&gt; getParameterTokens() {</b>
&nbsp;            return new ByteCodeElement.TokenList(this.parameterTokens);
&nbsp;        }
&nbsp;
&nbsp;        public TypeList.Generic getExceptionTypes() {
&nbsp;            return new TypeList.Generic.Explicit(this.exceptionTypes);
&nbsp;        }
&nbsp;
&nbsp;        public AnnotationList getAnnotations() {
&nbsp;            return new AnnotationList.Explicit(this.annotations);
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
&nbsp;            return this.defaultValue;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription.Generic getReceiverType() {
&nbsp;            return this.receiverType;
&nbsp;        }
&nbsp;
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(this.name, this.modifiers, this.getTypeVariableTokens().accept(visitor), (TypeDescription.Generic)this.returnType.accept(visitor), this.getParameterTokens().accept(visitor), this.getExceptionTypes().accept(visitor), this.annotations, this.defaultValue, this.receiverType == null ? Generic.UNDEFINED : (TypeDescription.Generic)this.receiverType.accept(visitor));</b>
&nbsp;        }
&nbsp;
&nbsp;        public SignatureToken asSignatureToken(TypeDescription declaringType) {
&nbsp;            TypeDescription.Generic.Visitor&lt;TypeDescription&gt; visitor = new TypeDescription.Generic.Visitor.Reducing(declaringType, this.typeVariableTokens);
&nbsp;            List&lt;TypeDescription&gt; parameters = new ArrayList(this.parameterTokens.size());
&nbsp;
<b class="fc">&nbsp;            for(ParameterDescription.Token parameter : this.parameterTokens) {</b>
&nbsp;                parameters.add(parameter.getType().accept(visitor));
&nbsp;            }
&nbsp;
&nbsp;            return new SignatureToken(this.name, (TypeDescription)this.returnType.accept(visitor), parameters);
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
<b class="fc">&nbsp;        public int hashCode() {</b>
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = this.name.hashCode();
<b class="fc">&nbsp;                result = 31 * result + this.modifiers;</b>
&nbsp;                result = 31 * result + this.typeVariableTokens.hashCode();
&nbsp;                result = 31 * result + this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTokens.hashCode();
&nbsp;                result = 31 * result + this.exceptionTypes.hashCode();
&nbsp;                result = 31 * result + this.annotations.hashCode();
&nbsp;                result = 31 * result + (this.defaultValue != null ? this.defaultValue.hashCode() : 0);
<b class="fc">&nbsp;                result = 31 * result + (this.receiverType != null ? this.receiverType.hashCode() : 0);</b>
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
<b class="fc">&nbsp;            } else {</b>
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public boolean equals(@MaybeNull Object other) {</b>
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (other != null &amp;&amp; this.getClass() == other.getClass()) {
&nbsp;                boolean var10000;
&nbsp;                label74: {
&nbsp;                    Token token = (Token)other;
<b class="nc">&nbsp;                    if (this.modifiers == token.modifiers &amp;&amp; this.name.equals(token.name) &amp;&amp; this.typeVariableTokens.equals(token.typeVariableTokens) &amp;&amp; this.returnType.equals(token.returnType) &amp;&amp; this.parameterTokens.equals(token.parameterTokens) &amp;&amp; this.exceptionTypes.equals(token.exceptionTypes) &amp;&amp; this.annotations.equals(token.annotations)) {</b>
&nbsp;                        label68: {
&nbsp;                            if (this.defaultValue != null) {
&nbsp;                                if (!this.defaultValue.equals(token.defaultValue)) {
&nbsp;                                    break label68;
&nbsp;                                }
&nbsp;                            } else if (token.defaultValue != null) {
<b class="nc">&nbsp;                                break label68;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            if (this.receiverType != null) {
&nbsp;                                if (this.receiverType.equals(token.receiverType)) {
&nbsp;                                    break label74;
&nbsp;                                }
<b class="fc">&nbsp;                            } else if (token.receiverType == null) {</b>
&nbsp;                                break label74;
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    var10000 = false;
<b class="nc">&nbsp;                    return var10000;</b>
&nbsp;                }
&nbsp;
&nbsp;                var10000 = true;
&nbsp;                return var10000;
&nbsp;            } else {
&nbsp;                return false;
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            return &quot;MethodDescription.Token{name=&#39;&quot; + this.name + &#39;\&#39;&#39; + &quot;, modifiers=&quot; + this.modifiers + &quot;, typeVariableTokens=&quot; + this.typeVariableTokens + &quot;, returnType=&quot; + this.returnType + &quot;, parameterTokens=&quot; + this.parameterTokens + &quot;, exceptionTypes=&quot; + this.exceptionTypes + &quot;, annotations=&quot; + this.annotations + &quot;, defaultValue=&quot; + this.defaultValue + &quot;, receiverType=&quot; + this.receiverType + &#39;}&#39;;
&nbsp;        }
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    public static class SignatureToken {
&nbsp;        private final String name;
&nbsp;        private final TypeDescription returnType;
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        public SignatureToken(String name, TypeDescription returnType, TypeDescription... parameterType) {
&nbsp;            this(name, returnType, Arrays.asList(parameterType));
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public SignatureToken(String name, TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            this.name = name;
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTypes = parameterTypes;
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        public String getName() {</b>
&nbsp;            return this.name;
&nbsp;        }
&nbsp;
&nbsp;        public TypeDescription getReturnType() {
&nbsp;            return this.returnType;
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
&nbsp;            return this.parameterTypes;
&nbsp;        }
&nbsp;
&nbsp;        public TypeToken asTypeToken() {
&nbsp;            return new TypeToken(this.returnType, this.parameterTypes);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public String getDescriptor() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);
&nbsp;
&nbsp;            for(TypeDescription typeDescription : this.parameterTypes) {
&nbsp;                stringBuilder.append(typeDescription.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
&nbsp;        }
&nbsp;
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
<b class="fc">&nbsp;            if (var1 != 0) {</b>
&nbsp;                var10000 = 0;
&nbsp;            } else {
&nbsp;                int result = this.name.hashCode();
&nbsp;                result = 31 * result + this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTypes.hashCode();
&nbsp;                var10000 = result;
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            int var2 = var10000;
&nbsp;            if (var2 == 0) {
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            return var2;</b>
&nbsp;        }
<b class="fc">&nbsp;</b>
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof SignatureToken)) {
&nbsp;                return false;
&nbsp;            } else {
&nbsp;                SignatureToken signatureToken = (SignatureToken)other;
<b class="fc">&nbsp;                return this.name.equals(signatureToken.name) &amp;&amp; this.returnType.equals(signatureToken.returnType) &amp;&amp; this.parameterTypes.equals(signatureToken.parameterTypes);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(this.returnType).append(&#39; &#39;).append(this.name).append(&#39;(&#39;);
&nbsp;            boolean first = true;
<b class="pc">&nbsp;</b>
<b class="nc">&nbsp;            for(TypeDescription parameterType : this.parameterTypes) {</b>
&nbsp;                if (first) {
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                } else {
&nbsp;                    stringBuilder.append(&#39;,&#39;);
&nbsp;                }
&nbsp;
&nbsp;                stringBuilder.append(parameterType);
&nbsp;            }
<b class="fc">&nbsp;</b>
&nbsp;            return stringBuilder.append(&#39;)&#39;).toString();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public static class TypeToken {
&nbsp;        private final TypeDescription returnType;
<b class="fc">&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;</b>
&nbsp;
&nbsp;        public TypeToken(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
&nbsp;            this.returnType = returnType;
&nbsp;            this.parameterTypes = parameterTypes;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        public TypeDescription getReturnType() {</b>
&nbsp;            return this.returnType;
&nbsp;        }
&nbsp;
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
&nbsp;            return this.parameterTypes;
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
&nbsp;            int var1 = this.hashCode;
&nbsp;            int var10000;
&nbsp;            if (var1 != 0) {
&nbsp;                var10000 = 0;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                int result = this.returnType.hashCode();
&nbsp;                result = 31 * result + this.parameterTypes.hashCode();
&nbsp;                var10000 = result;
&nbsp;            }
&nbsp;
&nbsp;            int var2 = var10000;
<b class="fc">&nbsp;            if (var2 == 0) {</b>
&nbsp;                var2 = this.hashCode;
&nbsp;            } else {
&nbsp;                this.hashCode = var2;
&nbsp;            }
&nbsp;
&nbsp;            return var2;
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public boolean equals(@MaybeNull Object other) {
&nbsp;            if (this == other) {
&nbsp;                return true;
&nbsp;            } else if (!(other instanceof TypeToken)) {
&nbsp;                return false;
<b class="nc">&nbsp;            } else {</b>
&nbsp;                TypeToken typeToken = (TypeToken)other;
&nbsp;                return this.returnType.equals(typeToken.returnType) &amp;&amp; this.parameterTypes.equals(typeToken.parameterTypes);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public String toString() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = (new StringBuilder()).append(&#39;(&#39;);</b>
&nbsp;
&nbsp;            for(TypeDescription parameterType : this.parameterTypes) {
&nbsp;                stringBuilder.append(parameterType.getDescriptor());
&nbsp;            }
&nbsp;
&nbsp;            return stringBuilder.append(&#39;)&#39;).append(this.returnType.getDescriptor()).toString();
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public interface InDefinedShape extends MethodDescription {
&nbsp;        @Nonnull
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters();
&nbsp;
<b class="fc">&nbsp;        public abstract static class AbstractBase extends AbstractBase implements InDefinedShape {</b>
&nbsp;            public AbstractBase() {
&nbsp;            }
&nbsp;
&nbsp;            public InDefinedShape asDefined() {
&nbsp;                return this;
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            @MaybeNull</b>
&nbsp;            public TypeDescription.Generic getReceiverType() {
&nbsp;                if (this.isStatic()) {
&nbsp;                    return Generic.UNDEFINED;
&nbsp;                } else if (this.isConstructor()) {
&nbsp;                    TypeDescription declaringType = this.getDeclaringType();
&nbsp;                    TypeDescription enclosingDeclaringType = this.getDeclaringType().getEnclosingType();
&nbsp;                    if (enclosingDeclaringType == null) {
<b class="fc">&nbsp;                        return ForGenerifiedErasure.of(declaringType);</b>
<b class="pc">&nbsp;                    } else {</b>
&nbsp;                        return declaringType.isStatic() ? enclosingDeclaringType.asGenericType() : ForGenerifiedErasure.of(enclosingDeclaringType);
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
&nbsp;                    return ForGenerifiedErasure.of(this.getDeclaringType());
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected abstract static class ForLoadedExecutable&lt;T extends AnnotatedElement&gt; extends AbstractBase {
<b class="pc">&nbsp;                protected static final Executable EXECUTABLE;</b>
<b class="nc">&nbsp;                protected final T executable;</b>
&nbsp;                private static final boolean ACCESS_CONTROLLER;
<b class="fc">&nbsp;</b>
&nbsp;                protected ForLoadedExecutable(T executable) {
&nbsp;                    this.executable = executable;
&nbsp;                }
&nbsp;
&nbsp;                @net.bytebuddy.build.AccessControllerPlugin.Enhance
&nbsp;                private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;                    return (T)(ACCESS_CONTROLLER ? AccessController.doPrivileged(action) : action.run());
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                public TypeDescription.Generic getReceiverType() {
&nbsp;                    AnnotatedElement element = EXECUTABLE.getAnnotatedReceiverType(this.executable);
&nbsp;                    return element == null ? super.getReceiverType() : Sort.describeAnnotated(element);
&nbsp;                }
&nbsp;
&nbsp;                static {
&nbsp;                    try {
&nbsp;                        Class.forName(&quot;java.security.AccessController&quot;, false, (ClassLoader)null);
&nbsp;                        ACCESS_CONTROLLER = Boolean.parseBoolean(System.getProperty(&quot;net.bytebuddy.securitymanager&quot;, &quot;true&quot;));
&nbsp;                    } catch (ClassNotFoundException var0) {
&nbsp;                        ACCESS_CONTROLLER = false;
&nbsp;                    } catch (SecurityException var1) {
&nbsp;                        ACCESS_CONTROLLER = true;
&nbsp;                    }
&nbsp;
&nbsp;                    EXECUTABLE = (Executable)doPrivileged(JavaDispatcher.of(Executable.class));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;            protected interface Executable {
&nbsp;                @MaybeNull
&nbsp;                @Defaults
&nbsp;                @Proxied(&quot;getAnnotatedReceiverType&quot;)
&nbsp;                AnnotatedElement getAnnotatedReceiverType(Object var1);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    public interface InGenericShape extends MethodDescription {
&nbsp;        @Nonnull
&nbsp;        TypeDescription.Generic getDeclaringType();
&nbsp;
&nbsp;        ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters();
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:42</div>
</div>
</body>
</html>
