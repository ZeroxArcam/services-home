


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > ConcurrentReferenceHashMap</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.springframework.util</a>
</div>

<h1>Coverage Summary for Class: ConcurrentReferenceHashMap (org.springframework.util)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ConcurrentReferenceHashMap</td>
<td class="coverageStat">
  <span class="percent">
    18.8%
  </span>
  <span class="absValue">
    (6/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.1%
  </span>
  <span class="absValue">
    (8/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    32.1%
  </span>
  <span class="absValue">
    (26/81)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$Reference</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$ReferenceManager</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$ReferenceType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$Segment</td>
<td class="coverageStat">
  <span class="percent">
    16.7%
  </span>
  <span class="absValue">
    (2/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.8%
  </span>
  <span class="absValue">
    (7/103)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ConcurrentReferenceHashMap$Task</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    17.5%
  </span>
  <span class="absValue">
    (11/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.1%
  </span>
  <span class="absValue">
    (8/132)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    16.5%
  </span>
  <span class="absValue">
    (38/230)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;//
&nbsp;// Source code recreated from a .class file by IntelliJ IDEA
&nbsp;// (powered by FernFlower decompiler)
&nbsp;//
&nbsp;
&nbsp;package org.springframework.util;
&nbsp;
&nbsp;import java.lang.ref.ReferenceQueue;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.lang.ref.WeakReference;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.util.AbstractMap;
&nbsp;import java.util.AbstractSet;
&nbsp;import java.util.Collections;
&nbsp;import java.util.EnumSet;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;import org.springframework.lang.Nullable;
&nbsp;
&nbsp;public class ConcurrentReferenceHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt; {
&nbsp;    private static final int DEFAULT_INITIAL_CAPACITY = 16;
&nbsp;    private static final float DEFAULT_LOAD_FACTOR = 0.75F;
&nbsp;    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;
&nbsp;    private static final ReferenceType DEFAULT_REFERENCE_TYPE;
&nbsp;    private static final int MAXIMUM_CONCURRENCY_LEVEL = 65536;
&nbsp;    private static final int MAXIMUM_SEGMENT_SIZE = 1073741824;
&nbsp;    private final ConcurrentReferenceHashMap&lt;K, V&gt;.Segment[] segments;
&nbsp;    private final float loadFactor;
&nbsp;    private final ReferenceType referenceType;
&nbsp;    private final int shift;
&nbsp;    @Nullable
&nbsp;    private volatile Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap() {
&nbsp;        this(16, 0.75F, 16, DEFAULT_REFERENCE_TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity) {
&nbsp;        this(initialCapacity, 0.75F, 16, DEFAULT_REFERENCE_TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {
&nbsp;        this(initialCapacity, loadFactor, 16, DEFAULT_REFERENCE_TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {
&nbsp;        this(initialCapacity, 0.75F, concurrencyLevel, DEFAULT_REFERENCE_TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {
&nbsp;        this(initialCapacity, 0.75F, 16, referenceType);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {
&nbsp;        this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE);
&nbsp;    }
&nbsp;
&nbsp;    public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {
&nbsp;        Assert.isTrue(initialCapacity &gt;= 0, &quot;Initial capacity must not be negative&quot;);
&nbsp;        Assert.isTrue(loadFactor &gt; 0.0F, &quot;Load factor must be positive&quot;);
&nbsp;        Assert.isTrue(concurrencyLevel &gt; 0, &quot;Concurrency level must be positive&quot;);
&nbsp;        Assert.notNull(referenceType, &quot;Reference type must not be null&quot;);
&nbsp;        this.loadFactor = loadFactor;
&nbsp;        this.shift = calculateShift(concurrencyLevel, 65536);
&nbsp;        int size = 1 &lt;&lt; this.shift;
<b class="fc">&nbsp;        this.referenceType = referenceType;</b>
&nbsp;        int roundedUpSegmentCapacity = (int)(((long)(initialCapacity + size) - 1L) / (long)size);
&nbsp;        int initialSize = 1 &lt;&lt; calculateShift(roundedUpSegmentCapacity, 1073741824);
&nbsp;        ConcurrentReferenceHashMap&lt;K, V&gt;.Segment[] segments = (Segment[])Array.newInstance(Segment.class, size);
&nbsp;        int resizeThreshold = (int)((float)initialSize * this.getLoadFactor());
&nbsp;
&nbsp;        for(int i = 0; i &lt; segments.length; ++i) {
&nbsp;            segments[i] = new Segment(initialSize, resizeThreshold);
&nbsp;        }
&nbsp;
&nbsp;        this.segments = segments;
&nbsp;    }
&nbsp;
&nbsp;    protected final float getLoadFactor() {
&nbsp;        return this.loadFactor;
&nbsp;    }
&nbsp;
&nbsp;    protected final int getSegmentsSize() {
&nbsp;        return this.segments.length;
&nbsp;    }
&nbsp;
&nbsp;    protected final ConcurrentReferenceHashMap&lt;K, V&gt;.Segment getSegment(int index) {
&nbsp;        return this.segments[index];
&nbsp;    }
&nbsp;
&nbsp;    protected ConcurrentReferenceHashMap&lt;K, V&gt;.ReferenceManager createReferenceManager() {
&nbsp;        return new ReferenceManager();
&nbsp;    }
&nbsp;
&nbsp;    protected int getHash(@Nullable Object o) {
&nbsp;        int hash = o != null ? o.hashCode() : 0;
&nbsp;        hash += hash &lt;&lt; 15 ^ -12931;
&nbsp;        hash ^= hash &gt;&gt;&gt; 10;
&nbsp;        hash += hash &lt;&lt; 3;
&nbsp;        hash ^= hash &gt;&gt;&gt; 6;
&nbsp;        hash += (hash &lt;&lt; 2) + (hash &lt;&lt; 14);
&nbsp;        hash ^= hash &gt;&gt;&gt; 16;
&nbsp;        return hash;
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    @Nullable
&nbsp;    public V get(@Nullable Object key) {
&nbsp;        Reference&lt;K, V&gt; ref = this.getReference(key, ConcurrentReferenceHashMap.Restructure.WHEN_NECESSARY);
&nbsp;        Entry&lt;K, V&gt; entry = ref != null ? ref.get() : null;
&nbsp;        return (V)(entry != null ? entry.getValue() : null);
&nbsp;    }
<b class="fc">&nbsp;</b>
&nbsp;    @Nullable
&nbsp;    public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {
&nbsp;        Reference&lt;K, V&gt; ref = this.getReference(key, ConcurrentReferenceHashMap.Restructure.WHEN_NECESSARY);
&nbsp;        Entry&lt;K, V&gt; entry = ref != null ? ref.get() : null;
&nbsp;        return (V)(entry != null ? entry.getValue() : defaultValue);
&nbsp;    }
&nbsp;
&nbsp;    public boolean containsKey(@Nullable Object key) {
&nbsp;        Reference&lt;K, V&gt; ref = this.getReference(key, ConcurrentReferenceHashMap.Restructure.WHEN_NECESSARY);
<b class="nc">&nbsp;        Entry&lt;K, V&gt; entry = ref != null ? ref.get() : null;</b>
&nbsp;        return entry != null &amp;&amp; ObjectUtils.nullSafeEquals(entry.getKey(), key);
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    protected final Reference&lt;K, V&gt; getReference(@Nullable Object key, Restructure restructure) {
&nbsp;        int hash = this.getHash(key);
&nbsp;        return this.getSegmentForHash(hash).getReference(key, hash, restructure);
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Nullable</b>
&nbsp;    public V put(@Nullable K key, @Nullable V value) {
&nbsp;        return (V)this.put(key, value, true);
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public V putIfAbsent(@Nullable K key, @Nullable V value) {
&nbsp;        return (V)this.put(key, value, false);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    @Nullable
&nbsp;    private V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {
&nbsp;        return (V)this.doTask(key, new ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;V&gt;(new TaskOption[]{ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_BEFORE, ConcurrentReferenceHashMap.TaskOption.RESIZE}) {
&nbsp;            @Nullable
&nbsp;            protected V execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry, @Nullable Entries&lt;V&gt; entries) {
&nbsp;                if (entry != null) {
&nbsp;                    V oldValue = entry.getValue();
&nbsp;                    if (overwriteExisting) {
&nbsp;                        entry.setValue(value);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    return oldValue;</b>
&nbsp;                } else {
&nbsp;                    Assert.state(entries != null, &quot;No entries segment&quot;);
&nbsp;                    entries.add(value);
&nbsp;                    return null;
&nbsp;                }
&nbsp;            }
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public V remove(@Nullable Object key) {
&nbsp;        return (V)this.doTask(key, new ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;V&gt;(new TaskOption[]{ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_AFTER, ConcurrentReferenceHashMap.TaskOption.SKIP_IF_EMPTY}) {
&nbsp;            @Nullable
<b class="fc">&nbsp;            protected V execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry) {</b>
&nbsp;                if (entry != null) {
<b class="pc">&nbsp;                    if (ref != null) {</b>
<b class="pc">&nbsp;                        ref.release();</b>
<b class="pc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    return entry.value;</b>
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    return null;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        });</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;    public boolean remove(@Nullable Object key, @Nullable final Object value) {</b>
<b class="fc">&nbsp;        Boolean result = (Boolean)this.doTask(key, new ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;Boolean&gt;(new TaskOption[]{ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_AFTER, ConcurrentReferenceHashMap.TaskOption.SKIP_IF_EMPTY}) {</b>
&nbsp;            protected Boolean execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry) {
<b class="fc">&nbsp;                if (entry != null &amp;&amp; ObjectUtils.nullSafeEquals(entry.getValue(), value)) {</b>
&nbsp;                    if (ref != null) {
&nbsp;                        ref.release();
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                } else {
&nbsp;                    return false;
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        });
&nbsp;        return Boolean.TRUE.equals(result);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    public boolean replace(@Nullable K key, @Nullable final V oldValue, @Nullable final V newValue) {
&nbsp;        Boolean result = (Boolean)this.doTask(key, new ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;Boolean&gt;(new TaskOption[]{ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_BEFORE, ConcurrentReferenceHashMap.TaskOption.SKIP_IF_EMPTY}) {
&nbsp;            protected Boolean execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry) {
&nbsp;                if (entry != null &amp;&amp; ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {
&nbsp;                    entry.setValue(newValue);
&nbsp;                    return true;
&nbsp;                } else {
&nbsp;                    return false;
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        });
&nbsp;        return Boolean.TRUE.equals(result);
&nbsp;    }
&nbsp;
&nbsp;    @Nullable
&nbsp;    public V replace(@Nullable K key, @Nullable final V value) {
&nbsp;        return (V)this.doTask(key, new ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;V&gt;(new TaskOption[]{ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_BEFORE, ConcurrentReferenceHashMap.TaskOption.SKIP_IF_EMPTY}) {
&nbsp;            @Nullable
&nbsp;            protected V execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry) {
<b class="nc">&nbsp;                if (entry != null) {</b>
<b class="nc">&nbsp;                    V oldValue = entry.getValue();</b>
<b class="nc">&nbsp;                    entry.setValue(value);</b>
<b class="nc">&nbsp;                    return oldValue;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    return null;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        });
&nbsp;    }
&nbsp;
&nbsp;    public void clear() {
&nbsp;        for(ConcurrentReferenceHashMap&lt;K, V&gt;.Segment segment : this.segments) {
<b class="nc">&nbsp;            segment.clear();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;    }
&nbsp;
&nbsp;    public void purgeUnreferencedEntries() {
&nbsp;        for(ConcurrentReferenceHashMap&lt;K, V&gt;.Segment segment : this.segments) {
&nbsp;            segment.restructureIfNecessary(false);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public int size() {
&nbsp;        int size = 0;
&nbsp;
<b class="nc">&nbsp;        for(ConcurrentReferenceHashMap&lt;K, V&gt;.Segment segment : this.segments) {</b>
<b class="nc">&nbsp;            size += segment.getCount();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        return size;
&nbsp;    }
&nbsp;
&nbsp;    public boolean isEmpty() {
&nbsp;        for(ConcurrentReferenceHashMap&lt;K, V&gt;.Segment segment : this.segments) {
&nbsp;            if (segment.getCount() &gt; 0) {
&nbsp;                return false;
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return true;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
&nbsp;        Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = this.entrySet;
&nbsp;        if (entrySet == null) {
&nbsp;            entrySet = new EntrySet();
<b class="nc">&nbsp;            this.entrySet = entrySet;</b>
&nbsp;        }
&nbsp;
&nbsp;        return entrySet;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    @Nullable</b>
&nbsp;    private &lt;T&gt; T doTask(@Nullable Object key, ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;T&gt; task) {
&nbsp;        int hash = this.getHash(key);
&nbsp;        return (T)this.getSegmentForHash(hash).doTask(hash, key, task);
&nbsp;    }
<b class="nc">&nbsp;</b>
&nbsp;    private ConcurrentReferenceHashMap&lt;K, V&gt;.Segment getSegmentForHash(int hash) {
&nbsp;        return this.segments[hash &gt;&gt;&gt; 32 - this.shift &amp; this.segments.length - 1];
&nbsp;    }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected static int calculateShift(int minimumValue, int maximumValue) {</b>
<b class="nc">&nbsp;        int shift = 0;</b>
<b class="nc">&nbsp;</b>
&nbsp;        for(int value = 1; value &lt; minimumValue &amp;&amp; value &lt; maximumValue; ++shift) {
<b class="nc">&nbsp;            value &lt;&lt;= 1;</b>
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        return shift;</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    static {
&nbsp;        DEFAULT_REFERENCE_TYPE = ConcurrentReferenceHashMap.ReferenceType.SOFT;
&nbsp;    }
&nbsp;
&nbsp;    public static enum ReferenceType {
&nbsp;        SOFT,
<b class="nc">&nbsp;        WEAK;</b>
&nbsp;
&nbsp;        private ReferenceType() {
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    protected final class Segment extends ReentrantLock {</b>
&nbsp;        private final ConcurrentReferenceHashMap&lt;K, V&gt;.ReferenceManager referenceManager = ConcurrentReferenceHashMap.this.createReferenceManager();
<b class="nc">&nbsp;        private final int initialSize;</b>
&nbsp;        private volatile Reference&lt;K, V&gt;[] references;
<b class="nc">&nbsp;        private final AtomicInteger count = new AtomicInteger();</b>
&nbsp;        private int resizeThreshold;
&nbsp;
&nbsp;        public Segment(int initialSize, int resizeThreshold) {
&nbsp;            this.initialSize = initialSize;
&nbsp;            this.references = this.createReferenceArray(initialSize);
&nbsp;            this.resizeThreshold = resizeThreshold;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        @Nullable
<b class="nc">&nbsp;        public Reference&lt;K, V&gt; getReference(@Nullable Object key, int hash, Restructure restructure) {</b>
<b class="nc">&nbsp;            if (restructure == ConcurrentReferenceHashMap.Restructure.WHEN_NECESSARY) {</b>
<b class="nc">&nbsp;                this.restructureIfNecessary(false);</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            if (this.count.get() == 0) {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            } else {
&nbsp;                Reference&lt;K, V&gt;[] references = this.references;
<b class="nc">&nbsp;                int index = this.getIndex(hash, references);</b>
&nbsp;                Reference&lt;K, V&gt; head = references[index];
&nbsp;                return this.findInChain(head, key, hash);
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        @Nullable
&nbsp;        public &lt;T&gt; T doTask(final int hash, @Nullable final Object key, final ConcurrentReferenceHashMap&lt;K, V&gt;.Task&lt;T&gt; task) {
<b class="nc">&nbsp;            boolean resize = task.hasOption(ConcurrentReferenceHashMap.TaskOption.RESIZE);</b>
<b class="nc">&nbsp;            if (task.hasOption(ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_BEFORE)) {</b>
<b class="nc">&nbsp;                this.restructureIfNecessary(resize);</b>
&nbsp;            }
<b class="nc">&nbsp;</b>
&nbsp;            if (task.hasOption(ConcurrentReferenceHashMap.TaskOption.SKIP_IF_EMPTY) &amp;&amp; this.count.get() == 0) {
&nbsp;                return task.execute((Reference)null, (Entry)null, (Entries)null);
<b class="nc">&nbsp;            } else {</b>
&nbsp;                this.lock();
&nbsp;
&nbsp;                Object var10;
&nbsp;                try {
&nbsp;                    int index = this.getIndex(hash, this.references);
<b class="nc">&nbsp;                    Reference&lt;K, V&gt; head = this.references[index];</b>
&nbsp;                    Reference&lt;K, V&gt; ref = this.findInChain(head, key, hash);
&nbsp;                    Entry&lt;K, V&gt; entry = ref != null ? ref.get() : null;
&nbsp;                    Entries&lt;V&gt; entries = (value) -&gt; {
<b class="nc">&nbsp;                        Entry&lt;K, V&gt; newEntry = new Entry&lt;K, V&gt;(key, value);</b>
<b class="nc">&nbsp;                        Reference&lt;K, V&gt; newReference = this.referenceManager.createReference(newEntry, hash, head);</b>
<b class="nc">&nbsp;                        this.references[index] = newReference;</b>
<b class="nc">&nbsp;                        this.count.incrementAndGet();</b>
&nbsp;                    };
<b class="nc">&nbsp;                    var10 = task.execute(ref, entry, entries);</b>
&nbsp;                } finally {
&nbsp;                    this.unlock();
&nbsp;                    if (task.hasOption(ConcurrentReferenceHashMap.TaskOption.RESTRUCTURE_AFTER)) {
&nbsp;                        this.restructureIfNecessary(resize);
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                return (T)var10;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        public void clear() {
&nbsp;            if (this.count.get() != 0) {
&nbsp;                this.lock();
&nbsp;
&nbsp;                try {
&nbsp;                    this.references = this.createReferenceArray(this.initialSize);
<b class="nc">&nbsp;                    this.resizeThreshold = (int)((float)this.references.length * ConcurrentReferenceHashMap.this.getLoadFactor());</b>
<b class="nc">&nbsp;                    this.count.set(0);</b>
&nbsp;                } finally {
&nbsp;                    this.unlock();
&nbsp;                }
&nbsp;
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        void restructureIfNecessary(boolean allowResize) {</b>
<b class="nc">&nbsp;            int currCount = this.count.get();</b>
&nbsp;            boolean needsResize = allowResize &amp;&amp; currCount &gt; 0 &amp;&amp; currCount &gt;= this.resizeThreshold;
<b class="nc">&nbsp;            Reference&lt;K, V&gt; ref = this.referenceManager.pollForPurge();</b>
&nbsp;            if (ref != null || needsResize) {
&nbsp;                this.restructure(allowResize, ref);
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private void restructure(boolean allowResize, @Nullable Reference&lt;K, V&gt; ref) {</b>
&nbsp;            this.lock();
&nbsp;
<b class="nc">&nbsp;            try {</b>
&nbsp;                int expectedCount = this.count.get();
&nbsp;                Set&lt;Reference&lt;K, V&gt;&gt; toPurge = Collections.emptySet();
&nbsp;                if (ref != null) {
&nbsp;                    for(toPurge = new HashSet(); ref != null; ref = this.referenceManager.pollForPurge()) {
<b class="nc">&nbsp;                        toPurge.add(ref);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
&nbsp;                expectedCount -= toPurge.size();
<b class="nc">&nbsp;                boolean needsResize = expectedCount &gt; 0 &amp;&amp; expectedCount &gt;= this.resizeThreshold;</b>
&nbsp;                boolean resizing = false;
&nbsp;                int restructureSize = this.references.length;
&nbsp;                if (allowResize &amp;&amp; needsResize &amp;&amp; restructureSize &lt; 1073741824) {
&nbsp;                    restructureSize &lt;&lt;= 1;
<b class="nc">&nbsp;                    resizing = true;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                int newCount = 0;
&nbsp;                if (resizing) {
<b class="nc">&nbsp;                    Reference&lt;K, V&gt;[] restructured = this.createReferenceArray(restructureSize);</b>
&nbsp;
&nbsp;                    for(Reference&lt;K, V&gt; reference : this.references) {
&nbsp;                        for(Reference&lt;K, V&gt; var20 = reference; var20 != null; var20 = var20.getNext()) {
&nbsp;                            if (!toPurge.contains(var20)) {
&nbsp;                                Entry&lt;K, V&gt; entry = var20.get();
&nbsp;                                if (entry != null) {
&nbsp;                                    int index = this.getIndex(var20.getHash(), restructured);
&nbsp;                                    restructured[index] = this.referenceManager.createReference(entry, var20.getHash(), restructured[index]);
&nbsp;                                    ++newCount;
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="pc">&nbsp;                    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;                    this.references = restructured;</b>
&nbsp;                    this.resizeThreshold = (int)((float)this.references.length * ConcurrentReferenceHashMap.this.getLoadFactor());
<b class="fc">&nbsp;                } else {</b>
&nbsp;                    for(int i = 0; i &lt; this.references.length; ++i) {
&nbsp;                        Reference&lt;K, V&gt; purgedRef = null;
&nbsp;
&nbsp;                        for(Reference&lt;K, V&gt; var19 = this.references[i]; var19 != null; var19 = var19.getNext()) {
&nbsp;                            if (!toPurge.contains(var19)) {
&nbsp;                                Entry&lt;K, V&gt; entry = var19.get();
<b class="fc">&nbsp;                                if (entry != null) {</b>
&nbsp;                                    purgedRef = this.referenceManager.createReference(entry, var19.getHash(), purgedRef);
&nbsp;                                }
<b class="fc">&nbsp;</b>
&nbsp;                                ++newCount;
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        this.references[i] = purgedRef;
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                this.count.set(Math.max(newCount, 0));
&nbsp;            } finally {
&nbsp;                this.unlock();
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        private Reference&lt;K, V&gt; findInChain(Reference&lt;K, V&gt; ref, @Nullable Object key, int hash) {
&nbsp;            for(Reference&lt;K, V&gt; currRef = ref; currRef != null; currRef = currRef.getNext()) {
&nbsp;                if (currRef.getHash() == hash) {
&nbsp;                    Entry&lt;K, V&gt; entry = currRef.get();
&nbsp;                    if (entry != null) {
&nbsp;                        K entryKey = entry.getKey();
&nbsp;                        if (ObjectUtils.nullSafeEquals(entryKey, key)) {
&nbsp;                            return currRef;
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            return null;
&nbsp;        }
&nbsp;
&nbsp;        private Reference&lt;K, V&gt;[] createReferenceArray(int size) {
&nbsp;            return new Reference[size];
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;        private int getIndex(int hash, Reference&lt;K, V&gt;[] references) {</b>
<b class="fc">&nbsp;            return hash &amp; references.length - 1;</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        public int getSize() {
&nbsp;            return this.references.length;
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int getCount() {</b>
&nbsp;            return this.count.get();
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    protected static final class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        private final K key;</b>
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        private volatile V value;</b>
&nbsp;
&nbsp;        public Entry(@Nullable K key, @Nullable V value) {
&nbsp;            this.key = key;
&nbsp;            this.value = value;
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        public K getKey() {
&nbsp;            return this.key;
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
<b class="nc">&nbsp;        public V getValue() {</b>
<b class="nc">&nbsp;            return this.value;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        public V setValue(@Nullable V value) {</b>
&nbsp;            V previous = this.value;
<b class="nc">&nbsp;            this.value = value;</b>
&nbsp;            return previous;
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean equals(@Nullable Object other) {</b>
<b class="nc">&nbsp;            boolean var10000;</b>
<b class="nc">&nbsp;            if (this != other) {</b>
&nbsp;                label28: {
<b class="nc">&nbsp;                    if (other instanceof Map.Entry) {</b>
<b class="nc">&nbsp;                        Map.Entry&lt;?, ?&gt; that = (Map.Entry)other;</b>
<b class="nc">&nbsp;                        if (ObjectUtils.nullSafeEquals(this.getKey(), that.getKey()) &amp;&amp; ObjectUtils.nullSafeEquals(this.getValue(), that.getValue())) {</b>
<b class="nc">&nbsp;                            break label28;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    var10000 = false;
<b class="nc">&nbsp;                    return var10000;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            var10000 = true;
&nbsp;            return var10000;
&nbsp;        }
&nbsp;
&nbsp;        public int hashCode() {
&nbsp;            return ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value);
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public String toString() {
&nbsp;            String var10000 = String.valueOf(this.key);
<b class="nc">&nbsp;            return var10000 + &quot;=&quot; + String.valueOf(this.value);</b>
&nbsp;        }
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private abstract class Task&lt;T&gt; {</b>
&nbsp;        private final EnumSet&lt;TaskOption&gt; options;
&nbsp;
<b class="nc">&nbsp;        public Task(TaskOption... options) {</b>
&nbsp;            this.options = options.length == 0 ? EnumSet.noneOf(TaskOption.class) : EnumSet.of(options[0], options);
&nbsp;        }
&nbsp;
&nbsp;        public boolean hasOption(TaskOption option) {
&nbsp;            return this.options.contains(option);
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        protected T execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry, @Nullable Entries&lt;V&gt; entries) {
&nbsp;            return (T)this.execute(ref, entry);
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        protected T execute(@Nullable Reference&lt;K, V&gt; ref, @Nullable Entry&lt;K, V&gt; entry) {</b>
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static enum TaskOption {
&nbsp;        RESTRUCTURE_BEFORE,
<b class="nc">&nbsp;        RESTRUCTURE_AFTER,</b>
&nbsp;        SKIP_IF_EMPTY,
<b class="nc">&nbsp;        RESIZE;</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        private TaskOption() {</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;    }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;    private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {</b>
&nbsp;        private EntrySet() {
&nbsp;        }
<b class="nc">&nbsp;</b>
&nbsp;        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
&nbsp;            return ConcurrentReferenceHashMap.this.new EntryIterator();
&nbsp;        }
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean contains(@Nullable Object o) {</b>
<b class="nc">&nbsp;            if (o instanceof Map.Entry&lt;?, ?&gt; entry) {</b>
<b class="nc">&nbsp;                Reference&lt;K, V&gt; ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), ConcurrentReferenceHashMap.Restructure.NEVER);</b>
<b class="nc">&nbsp;                Entry&lt;K, V&gt; otherEntry = ref != null ? ref.get() : null;</b>
<b class="nc">&nbsp;                if (otherEntry != null) {</b>
&nbsp;                    return ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            return false;</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public boolean remove(Object o) {</b>
<b class="nc">&nbsp;            if (o instanceof Map.Entry&lt;?, ?&gt; entry) {</b>
<b class="nc">&nbsp;                return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());</b>
<b class="nc">&nbsp;            } else {</b>
&nbsp;                return false;
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;        public int size() {</b>
<b class="nc">&nbsp;            return ConcurrentReferenceHashMap.this.size();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void clear() {
<b class="nc">&nbsp;            ConcurrentReferenceHashMap.this.clear();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    private class EntryIterator implements Iterator&lt;Map.Entry&lt;K, V&gt;&gt; {</b>
<b class="nc">&nbsp;        private int segmentIndex;</b>
&nbsp;        private int referenceIndex;
&nbsp;        @Nullable
&nbsp;        private Reference&lt;K, V&gt;[] references;
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        private Reference&lt;K, V&gt; reference;</b>
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        private Entry&lt;K, V&gt; next;</b>
<b class="nc">&nbsp;        @Nullable</b>
<b class="nc">&nbsp;        private Entry&lt;K, V&gt; last;</b>
&nbsp;
&nbsp;        public EntryIterator() {
<b class="nc">&nbsp;            this.moveToNextSegment();</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;</b>
&nbsp;        public boolean hasNext() {
<b class="nc">&nbsp;            this.getNextIfNecessary();</b>
&nbsp;            return this.next != null;
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        public Entry&lt;K, V&gt; next() {</b>
&nbsp;            this.getNextIfNecessary();
&nbsp;            if (this.next == null) {
<b class="nc">&nbsp;                throw new NoSuchElementException();</b>
&nbsp;            } else {
&nbsp;                this.last = this.next;
<b class="nc">&nbsp;                this.next = null;</b>
&nbsp;                return this.last;
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        private void getNextIfNecessary() {
<b class="nc">&nbsp;            while(this.next == null) {</b>
<b class="nc">&nbsp;                this.moveToNextReference();</b>
<b class="nc">&nbsp;                if (this.reference == null) {</b>
<b class="nc">&nbsp;                    return;</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;</b>
<b class="nc">&nbsp;                this.next = this.reference.get();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        private void moveToNextReference() {</b>
&nbsp;            if (this.reference != null) {
<b class="nc">&nbsp;                this.reference = this.reference.getNext();</b>
&nbsp;            }
&nbsp;
&nbsp;            while(this.reference == null &amp;&amp; this.references != null) {
&nbsp;                if (this.referenceIndex &gt;= this.references.length) {
<b class="fc">&nbsp;                    this.moveToNextSegment();</b>
&nbsp;                    this.referenceIndex = 0;
&nbsp;                } else {
&nbsp;                    this.reference = this.references[this.referenceIndex];
<b class="nc">&nbsp;                    ++this.referenceIndex;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        private void moveToNextSegment() {
<b class="nc">&nbsp;            this.reference = null;</b>
&nbsp;            this.references = null;
&nbsp;            if (this.segmentIndex &lt; ConcurrentReferenceHashMap.this.segments.length) {
&nbsp;                this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;
&nbsp;                ++this.segmentIndex;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        public void remove() {
&nbsp;            Assert.state(this.last != null, &quot;No element to remove&quot;);
&nbsp;            ConcurrentReferenceHashMap.this.remove(this.last.getKey());
&nbsp;            this.last = null;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected static enum Restructure {
&nbsp;        WHEN_NECESSARY,
&nbsp;        NEVER;
&nbsp;
&nbsp;        private Restructure() {
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    protected class ReferenceManager {
&nbsp;        private final ReferenceQueue&lt;Entry&lt;K, V&gt;&gt; queue = new ReferenceQueue();
&nbsp;
&nbsp;        protected ReferenceManager() {
&nbsp;        }
&nbsp;
&nbsp;        public Reference&lt;K, V&gt; createReference(Entry&lt;K, V&gt; entry, int hash, @Nullable Reference&lt;K, V&gt; next) {
&nbsp;            return (Reference&lt;K, V&gt;)(ConcurrentReferenceHashMap.this.referenceType == ConcurrentReferenceHashMap.ReferenceType.WEAK ? new WeakEntryReference(entry, hash, next, this.queue) : new SoftEntryReference(entry, hash, next, this.queue));
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        public Reference&lt;K, V&gt; pollForPurge() {
&nbsp;            return (Reference)this.queue.poll();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class SoftEntryReference&lt;K, V&gt; extends SoftReference&lt;Entry&lt;K, V&gt;&gt; implements Reference&lt;K, V&gt; {
&nbsp;        private final int hash;
&nbsp;        @Nullable
&nbsp;        private final Reference&lt;K, V&gt; nextReference;
&nbsp;
&nbsp;        public SoftEntryReference(Entry&lt;K, V&gt; entry, int hash, @Nullable Reference&lt;K, V&gt; next, ReferenceQueue&lt;Entry&lt;K, V&gt;&gt; queue) {
&nbsp;            super(entry, queue);
&nbsp;            this.hash = hash;
&nbsp;            this.nextReference = next;
&nbsp;        }
&nbsp;
&nbsp;        public int getHash() {
&nbsp;            return this.hash;
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        public Reference&lt;K, V&gt; getNext() {
&nbsp;            return this.nextReference;
&nbsp;        }
&nbsp;
&nbsp;        public void release() {
&nbsp;            this.enqueue();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private static final class WeakEntryReference&lt;K, V&gt; extends WeakReference&lt;Entry&lt;K, V&gt;&gt; implements Reference&lt;K, V&gt; {
&nbsp;        private final int hash;
&nbsp;        @Nullable
&nbsp;        private final Reference&lt;K, V&gt; nextReference;
&nbsp;
&nbsp;        public WeakEntryReference(Entry&lt;K, V&gt; entry, int hash, @Nullable Reference&lt;K, V&gt; next, ReferenceQueue&lt;Entry&lt;K, V&gt;&gt; queue) {
&nbsp;            super(entry, queue);
&nbsp;            this.hash = hash;
&nbsp;            this.nextReference = next;
&nbsp;        }
&nbsp;
&nbsp;        public int getHash() {
&nbsp;            return this.hash;
&nbsp;        }
&nbsp;
&nbsp;        @Nullable
&nbsp;        public Reference&lt;K, V&gt; getNext() {
&nbsp;            return this.nextReference;
&nbsp;        }
&nbsp;
&nbsp;        public void release() {
&nbsp;            this.enqueue();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private interface Entries&lt;V&gt; {
&nbsp;        void add(@Nullable V value);
&nbsp;    }
&nbsp;
&nbsp;    protected interface Reference&lt;K, V&gt; {
&nbsp;        @Nullable
&nbsp;        Entry&lt;K, V&gt; get();
&nbsp;
&nbsp;        int getHash();
&nbsp;
&nbsp;        @Nullable
&nbsp;        Reference&lt;K, V&gt; getNext();
&nbsp;
&nbsp;        void release();
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-03-20 13:41</div>
</div>
</body>
</html>
